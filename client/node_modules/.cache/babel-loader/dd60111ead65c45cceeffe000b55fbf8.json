{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getASTNodeAndTypeInfoAtPosition = exports.positionToOffset = exports.positionFromSourceLocation = exports.rangeForASTNode = exports.rangeInContainingDocument = exports.positionInContainingDocument = exports.positionFromPositionInContainingDocument = exports.visitWithTypeInfo = void 0;\n\nconst graphql_1 = require(\"graphql\");\n\nconst location_1 = require(\"graphql/language/location\");\n\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\n\nconst graphql_2 = require(\"./graphql\");\n\nfunction visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter(node) {\n      typeInfo.enter(node);\n      const fn = (0, graphql_1.getVisitFn)(visitor, node.kind, false);\n\n      if (fn) {\n        const result = fn.apply(visitor, arguments);\n\n        if (result !== undefined) {\n          typeInfo.leave(node);\n\n          if ((0, graphql_2.isNode)(result)) {\n            typeInfo.enter(result);\n          }\n        }\n\n        return result;\n      }\n    },\n\n    leave(node) {\n      const fn = (0, graphql_1.getVisitFn)(visitor, node.kind, true);\n      let result;\n\n      if (fn) {\n        result = fn.apply(visitor, arguments);\n      }\n\n      if (result !== graphql_1.BREAK) {\n        typeInfo.leave(node);\n      }\n\n      return result;\n    }\n\n  };\n}\n\nexports.visitWithTypeInfo = visitWithTypeInfo;\n\nfunction positionFromPositionInContainingDocument(source, position) {\n  if (!source.locationOffset) return position;\n  return vscode_languageserver_1.Position.create(position.line - (source.locationOffset.line - 1), position.character);\n}\n\nexports.positionFromPositionInContainingDocument = positionFromPositionInContainingDocument;\n\nfunction positionInContainingDocument(source, position) {\n  if (!source.locationOffset) return position;\n  return vscode_languageserver_1.Position.create(source.locationOffset.line - 1 + position.line, position.character);\n}\n\nexports.positionInContainingDocument = positionInContainingDocument;\n\nfunction rangeInContainingDocument(source, range) {\n  if (!source.locationOffset) return range;\n  return vscode_languageserver_1.Range.create(positionInContainingDocument(source, range.start), positionInContainingDocument(source, range.end));\n}\n\nexports.rangeInContainingDocument = rangeInContainingDocument;\n\nfunction rangeForASTNode(node) {\n  const location = node.loc;\n  const source = location.source;\n  return vscode_languageserver_1.Range.create(positionFromSourceLocation(source, (0, location_1.getLocation)(source, location.start)), positionFromSourceLocation(source, (0, location_1.getLocation)(source, location.end)));\n}\n\nexports.rangeForASTNode = rangeForASTNode;\n\nfunction positionFromSourceLocation(source, location) {\n  return vscode_languageserver_1.Position.create((source.locationOffset ? source.locationOffset.line - 1 : 0) + location.line - 1, (source.locationOffset && location.line === 1 ? source.locationOffset.column - 1 : 0) + location.column - 1);\n}\n\nexports.positionFromSourceLocation = positionFromSourceLocation;\n\nfunction positionToOffset(source, position) {\n  const lineRegexp = /\\r\\n|[\\n\\r]/g;\n  const lineEndingLength = /\\r\\n/g.test(source.body) ? 2 : 1;\n  const linesUntilPosition = source.body.split(lineRegexp).slice(0, position.line);\n  return position.character + linesUntilPosition.map(line => line.length + lineEndingLength).reduce((a, b) => a + b, 0);\n}\n\nexports.positionToOffset = positionToOffset;\n\nfunction getASTNodeAndTypeInfoAtPosition(source, position, root, schema) {\n  const offset = positionToOffset(source, position);\n  let nodeContainingPosition = null;\n  const typeInfo = new graphql_1.TypeInfo(schema);\n  (0, graphql_1.visit)(root, visitWithTypeInfo(typeInfo, {\n    enter(node) {\n      if (node.kind !== graphql_1.Kind.NAME && node.loc && node.loc.start <= offset && offset <= node.loc.end) {\n        nodeContainingPosition = node;\n      } else {\n        return false;\n      }\n\n      return;\n    },\n\n    leave(node) {\n      if (node.loc && node.loc.start <= offset && offset <= node.loc.end) {\n        return graphql_1.BREAK;\n      }\n\n      return;\n    }\n\n  }));\n\n  if (nodeContainingPosition) {\n    return [nodeContainingPosition, typeInfo];\n  } else {\n    return null;\n  }\n}\n\nexports.getASTNodeAndTypeInfoAtPosition = getASTNodeAndTypeInfoAtPosition;","map":{"version":3,"sources":["../../src/utilities/source.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getASTNodeAndTypeInfoAtPosition = exports.positionToOffset = exports.positionFromSourceLocation = exports.rangeForASTNode = exports.rangeInContainingDocument = exports.positionInContainingDocument = exports.positionFromPositionInContainingDocument = exports.visitWithTypeInfo = void 0;\nconst graphql_1 = require(\"graphql\");\nconst location_1 = require(\"graphql/language/location\");\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nconst graphql_2 = require(\"./graphql\");\nfunction visitWithTypeInfo(typeInfo, visitor) {\n    return {\n        enter(node) {\n            typeInfo.enter(node);\n            const fn = (0, graphql_1.getVisitFn)(visitor, node.kind, false);\n            if (fn) {\n                const result = fn.apply(visitor, arguments);\n                if (result !== undefined) {\n                    typeInfo.leave(node);\n                    if ((0, graphql_2.isNode)(result)) {\n                        typeInfo.enter(result);\n                    }\n                }\n                return result;\n            }\n        },\n        leave(node) {\n            const fn = (0, graphql_1.getVisitFn)(visitor, node.kind, true);\n            let result;\n            if (fn) {\n                result = fn.apply(visitor, arguments);\n            }\n            if (result !== graphql_1.BREAK) {\n                typeInfo.leave(node);\n            }\n            return result;\n        },\n    };\n}\nexports.visitWithTypeInfo = visitWithTypeInfo;\nfunction positionFromPositionInContainingDocument(source, position) {\n    if (!source.locationOffset)\n        return position;\n    return vscode_languageserver_1.Position.create(position.line - (source.locationOffset.line - 1), position.character);\n}\nexports.positionFromPositionInContainingDocument = positionFromPositionInContainingDocument;\nfunction positionInContainingDocument(source, position) {\n    if (!source.locationOffset)\n        return position;\n    return vscode_languageserver_1.Position.create(source.locationOffset.line - 1 + position.line, position.character);\n}\nexports.positionInContainingDocument = positionInContainingDocument;\nfunction rangeInContainingDocument(source, range) {\n    if (!source.locationOffset)\n        return range;\n    return vscode_languageserver_1.Range.create(positionInContainingDocument(source, range.start), positionInContainingDocument(source, range.end));\n}\nexports.rangeInContainingDocument = rangeInContainingDocument;\nfunction rangeForASTNode(node) {\n    const location = node.loc;\n    const source = location.source;\n    return vscode_languageserver_1.Range.create(positionFromSourceLocation(source, (0, location_1.getLocation)(source, location.start)), positionFromSourceLocation(source, (0, location_1.getLocation)(source, location.end)));\n}\nexports.rangeForASTNode = rangeForASTNode;\nfunction positionFromSourceLocation(source, location) {\n    return vscode_languageserver_1.Position.create((source.locationOffset ? source.locationOffset.line - 1 : 0) +\n        location.line -\n        1, (source.locationOffset && location.line === 1\n        ? source.locationOffset.column - 1\n        : 0) +\n        location.column -\n        1);\n}\nexports.positionFromSourceLocation = positionFromSourceLocation;\nfunction positionToOffset(source, position) {\n    const lineRegexp = /\\r\\n|[\\n\\r]/g;\n    const lineEndingLength = /\\r\\n/g.test(source.body) ? 2 : 1;\n    const linesUntilPosition = source.body\n        .split(lineRegexp)\n        .slice(0, position.line);\n    return (position.character +\n        linesUntilPosition\n            .map((line) => line.length + lineEndingLength)\n            .reduce((a, b) => a + b, 0));\n}\nexports.positionToOffset = positionToOffset;\nfunction getASTNodeAndTypeInfoAtPosition(source, position, root, schema) {\n    const offset = positionToOffset(source, position);\n    let nodeContainingPosition = null;\n    const typeInfo = new graphql_1.TypeInfo(schema);\n    (0, graphql_1.visit)(root, visitWithTypeInfo(typeInfo, {\n        enter(node) {\n            if (node.kind !== graphql_1.Kind.NAME &&\n                node.loc &&\n                node.loc.start <= offset &&\n                offset <= node.loc.end) {\n                nodeContainingPosition = node;\n            }\n            else {\n                return false;\n            }\n            return;\n        },\n        leave(node) {\n            if (node.loc && node.loc.start <= offset && offset <= node.loc.end) {\n                return graphql_1.BREAK;\n            }\n            return;\n        },\n    }));\n    if (nodeContainingPosition) {\n        return [nodeContainingPosition, typeInfo];\n    }\n    else {\n        return null;\n    }\n}\nexports.getASTNodeAndTypeInfoAtPosition = getASTNodeAndTypeInfoAtPosition;\n//# sourceMappingURL=source.js.map"]},"metadata":{},"sourceType":"script"}