{"ast":null,"code":"\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createMessageConnection = exports.ConnectionOptions = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.Trace = exports.NullLogger = exports.ProgressType = void 0;\n\nconst ral_1 = require(\"./ral\");\n\nconst Is = require(\"./is\");\n\nconst messages_1 = require(\"./messages\");\n\nconst linkedMap_1 = require(\"./linkedMap\");\n\nconst events_1 = require(\"./events\");\n\nconst cancellation_1 = require(\"./cancellation\");\n\nvar CancelNotification;\n\n(function (CancelNotification) {\n  CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');\n})(CancelNotification || (CancelNotification = {}));\n\nvar ProgressNotification;\n\n(function (ProgressNotification) {\n  ProgressNotification.type = new messages_1.NotificationType('$/progress');\n})(ProgressNotification || (ProgressNotification = {}));\n\nclass ProgressType {\n  constructor() {}\n\n}\n\nexports.ProgressType = ProgressType;\nvar StarRequestHandler;\n\n(function (StarRequestHandler) {\n  function is(value) {\n    return Is.func(value);\n  }\n\n  StarRequestHandler.is = is;\n})(StarRequestHandler || (StarRequestHandler = {}));\n\nexports.NullLogger = Object.freeze({\n  error: () => {},\n  warn: () => {},\n  info: () => {},\n  log: () => {}\n});\nvar Trace;\n\n(function (Trace) {\n  Trace[Trace[\"Off\"] = 0] = \"Off\";\n  Trace[Trace[\"Messages\"] = 1] = \"Messages\";\n  Trace[Trace[\"Verbose\"] = 2] = \"Verbose\";\n})(Trace = exports.Trace || (exports.Trace = {}));\n\n(function (Trace) {\n  function fromString(value) {\n    if (!Is.string(value)) {\n      return Trace.Off;\n    }\n\n    value = value.toLowerCase();\n\n    switch (value) {\n      case 'off':\n        return Trace.Off;\n\n      case 'messages':\n        return Trace.Messages;\n\n      case 'verbose':\n        return Trace.Verbose;\n\n      default:\n        return Trace.Off;\n    }\n  }\n\n  Trace.fromString = fromString;\n\n  function toString(value) {\n    switch (value) {\n      case Trace.Off:\n        return 'off';\n\n      case Trace.Messages:\n        return 'messages';\n\n      case Trace.Verbose:\n        return 'verbose';\n\n      default:\n        return 'off';\n    }\n  }\n\n  Trace.toString = toString;\n})(Trace = exports.Trace || (exports.Trace = {}));\n\nvar TraceFormat;\n\n(function (TraceFormat) {\n  TraceFormat[\"Text\"] = \"text\";\n  TraceFormat[\"JSON\"] = \"json\";\n})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));\n\n(function (TraceFormat) {\n  function fromString(value) {\n    value = value.toLowerCase();\n\n    if (value === 'json') {\n      return TraceFormat.JSON;\n    } else {\n      return TraceFormat.Text;\n    }\n  }\n\n  TraceFormat.fromString = fromString;\n})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));\n\nvar SetTraceNotification;\n\n(function (SetTraceNotification) {\n  SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');\n})(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));\n\nvar LogTraceNotification;\n\n(function (LogTraceNotification) {\n  LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');\n})(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));\n\nvar ConnectionErrors;\n\n(function (ConnectionErrors) {\n  /**\n   * The connection is closed.\n   */\n  ConnectionErrors[ConnectionErrors[\"Closed\"] = 1] = \"Closed\";\n  /**\n   * The connection got disposed.\n   */\n\n  ConnectionErrors[ConnectionErrors[\"Disposed\"] = 2] = \"Disposed\";\n  /**\n   * The connection is already in listening mode.\n   */\n\n  ConnectionErrors[ConnectionErrors[\"AlreadyListening\"] = 3] = \"AlreadyListening\";\n})(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));\n\nclass ConnectionError extends Error {\n  constructor(code, message) {\n    super(message);\n    this.code = code;\n    Object.setPrototypeOf(this, ConnectionError.prototype);\n  }\n\n}\n\nexports.ConnectionError = ConnectionError;\nvar ConnectionStrategy;\n\n(function (ConnectionStrategy) {\n  function is(value) {\n    const candidate = value;\n    return candidate && Is.func(candidate.cancelUndispatched);\n  }\n\n  ConnectionStrategy.is = is;\n})(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));\n\nvar CancellationReceiverStrategy;\n\n(function (CancellationReceiverStrategy) {\n  CancellationReceiverStrategy.Message = Object.freeze({\n    createCancellationTokenSource(_) {\n      return new cancellation_1.CancellationTokenSource();\n    }\n\n  });\n\n  function is(value) {\n    const candidate = value;\n    return candidate && Is.func(candidate.createCancellationTokenSource);\n  }\n\n  CancellationReceiverStrategy.is = is;\n})(CancellationReceiverStrategy = exports.CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = {}));\n\nvar CancellationSenderStrategy;\n\n(function (CancellationSenderStrategy) {\n  CancellationSenderStrategy.Message = Object.freeze({\n    sendCancellation(conn, id) {\n      conn.sendNotification(CancelNotification.type, {\n        id\n      });\n    },\n\n    cleanup(_) {}\n\n  });\n\n  function is(value) {\n    const candidate = value;\n    return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);\n  }\n\n  CancellationSenderStrategy.is = is;\n})(CancellationSenderStrategy = exports.CancellationSenderStrategy || (exports.CancellationSenderStrategy = {}));\n\nvar CancellationStrategy;\n\n(function (CancellationStrategy) {\n  CancellationStrategy.Message = Object.freeze({\n    receiver: CancellationReceiverStrategy.Message,\n    sender: CancellationSenderStrategy.Message\n  });\n\n  function is(value) {\n    const candidate = value;\n    return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);\n  }\n\n  CancellationStrategy.is = is;\n})(CancellationStrategy = exports.CancellationStrategy || (exports.CancellationStrategy = {}));\n\nvar ConnectionOptions;\n\n(function (ConnectionOptions) {\n  function is(value) {\n    const candidate = value;\n    return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));\n  }\n\n  ConnectionOptions.is = is;\n})(ConnectionOptions = exports.ConnectionOptions || (exports.ConnectionOptions = {}));\n\nvar ConnectionState;\n\n(function (ConnectionState) {\n  ConnectionState[ConnectionState[\"New\"] = 1] = \"New\";\n  ConnectionState[ConnectionState[\"Listening\"] = 2] = \"Listening\";\n  ConnectionState[ConnectionState[\"Closed\"] = 3] = \"Closed\";\n  ConnectionState[ConnectionState[\"Disposed\"] = 4] = \"Disposed\";\n})(ConnectionState || (ConnectionState = {}));\n\nfunction createMessageConnection(messageReader, messageWriter, _logger, options) {\n  const logger = _logger !== undefined ? _logger : exports.NullLogger;\n  let sequenceNumber = 0;\n  let notificationSquenceNumber = 0;\n  let unknownResponseSquenceNumber = 0;\n  const version = '2.0';\n  let starRequestHandler = undefined;\n  const requestHandlers = Object.create(null);\n  let starNotificationHandler = undefined;\n  const notificationHandlers = Object.create(null);\n  const progressHandlers = new Map();\n  let timer;\n  let messageQueue = new linkedMap_1.LinkedMap();\n  let responsePromises = Object.create(null);\n  let requestTokens = Object.create(null);\n  let trace = Trace.Off;\n  let traceFormat = TraceFormat.Text;\n  let tracer;\n  let state = ConnectionState.New;\n  const errorEmitter = new events_1.Emitter();\n  const closeEmitter = new events_1.Emitter();\n  const unhandledNotificationEmitter = new events_1.Emitter();\n  const unhandledProgressEmitter = new events_1.Emitter();\n  const disposeEmitter = new events_1.Emitter();\n  const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;\n\n  function createRequestQueueKey(id) {\n    if (id === null) {\n      throw new Error(`Can't send requests with id null since the response can't be correlated.`);\n    }\n\n    return 'req-' + id.toString();\n  }\n\n  function createResponseQueueKey(id) {\n    if (id === null) {\n      return 'res-unknown-' + (++unknownResponseSquenceNumber).toString();\n    } else {\n      return 'res-' + id.toString();\n    }\n  }\n\n  function createNotificationQueueKey() {\n    return 'not-' + (++notificationSquenceNumber).toString();\n  }\n\n  function addMessageToQueue(queue, message) {\n    if (messages_1.isRequestMessage(message)) {\n      queue.set(createRequestQueueKey(message.id), message);\n    } else if (messages_1.isResponseMessage(message)) {\n      queue.set(createResponseQueueKey(message.id), message);\n    } else {\n      queue.set(createNotificationQueueKey(), message);\n    }\n  }\n\n  function cancelUndispatched(_message) {\n    return undefined;\n  }\n\n  function isListening() {\n    return state === ConnectionState.Listening;\n  }\n\n  function isClosed() {\n    return state === ConnectionState.Closed;\n  }\n\n  function isDisposed() {\n    return state === ConnectionState.Disposed;\n  }\n\n  function closeHandler() {\n    if (state === ConnectionState.New || state === ConnectionState.Listening) {\n      state = ConnectionState.Closed;\n      closeEmitter.fire(undefined);\n    } // If the connection is disposed don't sent close events.\n\n  }\n\n  function readErrorHandler(error) {\n    errorEmitter.fire([error, undefined, undefined]);\n  }\n\n  function writeErrorHandler(data) {\n    errorEmitter.fire(data);\n  }\n\n  messageReader.onClose(closeHandler);\n  messageReader.onError(readErrorHandler);\n  messageWriter.onClose(closeHandler);\n  messageWriter.onError(writeErrorHandler);\n\n  function triggerMessageQueue() {\n    if (timer || messageQueue.size === 0) {\n      return;\n    }\n\n    timer = ral_1.default().timer.setImmediate(() => {\n      timer = undefined;\n      processMessageQueue();\n    });\n  }\n\n  function processMessageQueue() {\n    if (messageQueue.size === 0) {\n      return;\n    }\n\n    const message = messageQueue.shift();\n\n    try {\n      if (messages_1.isRequestMessage(message)) {\n        handleRequest(message);\n      } else if (messages_1.isNotificationMessage(message)) {\n        handleNotification(message);\n      } else if (messages_1.isResponseMessage(message)) {\n        handleResponse(message);\n      } else {\n        handleInvalidMessage(message);\n      }\n    } finally {\n      triggerMessageQueue();\n    }\n  }\n\n  const callback = message => {\n    try {\n      // We have received a cancellation message. Check if the message is still in the queue\n      // and cancel it if allowed to do so.\n      if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {\n        const key = createRequestQueueKey(message.params.id);\n        const toCancel = messageQueue.get(key);\n\n        if (messages_1.isRequestMessage(toCancel)) {\n          const strategy = options === null || options === void 0 ? void 0 : options.connectionStrategy;\n          const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);\n\n          if (response && (response.error !== undefined || response.result !== undefined)) {\n            messageQueue.delete(key);\n            response.id = toCancel.id;\n            traceSendingResponse(response, message.method, Date.now());\n            messageWriter.write(response);\n            return;\n          }\n        }\n      }\n\n      addMessageToQueue(messageQueue, message);\n    } finally {\n      triggerMessageQueue();\n    }\n  };\n\n  function handleRequest(requestMessage) {\n    if (isDisposed()) {\n      // we return here silently since we fired an event when the\n      // connection got disposed.\n      return;\n    }\n\n    function reply(resultOrError, method, startTime) {\n      const message = {\n        jsonrpc: version,\n        id: requestMessage.id\n      };\n\n      if (resultOrError instanceof messages_1.ResponseError) {\n        message.error = resultOrError.toJson();\n      } else {\n        message.result = resultOrError === undefined ? null : resultOrError;\n      }\n\n      traceSendingResponse(message, method, startTime);\n      messageWriter.write(message);\n    }\n\n    function replyError(error, method, startTime) {\n      const message = {\n        jsonrpc: version,\n        id: requestMessage.id,\n        error: error.toJson()\n      };\n      traceSendingResponse(message, method, startTime);\n      messageWriter.write(message);\n    }\n\n    function replySuccess(result, method, startTime) {\n      // The JSON RPC defines that a response must either have a result or an error\n      // So we can't treat undefined as a valid response result.\n      if (result === undefined) {\n        result = null;\n      }\n\n      const message = {\n        jsonrpc: version,\n        id: requestMessage.id,\n        result: result\n      };\n      traceSendingResponse(message, method, startTime);\n      messageWriter.write(message);\n    }\n\n    traceReceivedRequest(requestMessage);\n    const element = requestHandlers[requestMessage.method];\n    let type;\n    let requestHandler;\n\n    if (element) {\n      type = element.type;\n      requestHandler = element.handler;\n    }\n\n    const startTime = Date.now();\n\n    if (requestHandler || starRequestHandler) {\n      const tokenKey = String(requestMessage.id);\n      const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);\n      requestTokens[tokenKey] = cancellationSource;\n\n      try {\n        let handlerResult;\n\n        if (requestHandler) {\n          if (requestMessage.params === undefined) {\n            if (type !== undefined && type.numberOfParams !== 0) {\n              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but recevied none.`), requestMessage.method, startTime);\n              return;\n            }\n\n            handlerResult = requestHandler(cancellationSource.token);\n          } else if (Array.isArray(requestMessage.params)) {\n            if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {\n              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);\n              return;\n            }\n\n            handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);\n          } else {\n            if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {\n              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);\n              return;\n            }\n\n            handlerResult = requestHandler(requestMessage.params, cancellationSource.token);\n          }\n        } else if (starRequestHandler) {\n          handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);\n        }\n\n        const promise = handlerResult;\n\n        if (!handlerResult) {\n          delete requestTokens[tokenKey];\n          replySuccess(handlerResult, requestMessage.method, startTime);\n        } else if (promise.then) {\n          promise.then(resultOrError => {\n            delete requestTokens[tokenKey];\n            reply(resultOrError, requestMessage.method, startTime);\n          }, error => {\n            delete requestTokens[tokenKey];\n\n            if (error instanceof messages_1.ResponseError) {\n              replyError(error, requestMessage.method, startTime);\n            } else if (error && Is.string(error.message)) {\n              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);\n            } else {\n              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);\n            }\n          });\n        } else {\n          delete requestTokens[tokenKey];\n          reply(handlerResult, requestMessage.method, startTime);\n        }\n      } catch (error) {\n        delete requestTokens[tokenKey];\n\n        if (error instanceof messages_1.ResponseError) {\n          reply(error, requestMessage.method, startTime);\n        } else if (error && Is.string(error.message)) {\n          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);\n        } else {\n          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);\n        }\n      }\n    } else {\n      replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);\n    }\n  }\n\n  function handleResponse(responseMessage) {\n    if (isDisposed()) {\n      // See handle request.\n      return;\n    }\n\n    if (responseMessage.id === null) {\n      if (responseMessage.error) {\n        logger.error(`Received response message without id: Error is: \\n${JSON.stringify(responseMessage.error, undefined, 4)}`);\n      } else {\n        logger.error(`Received response message without id. No further error information provided.`);\n      }\n    } else {\n      const key = String(responseMessage.id);\n      const responsePromise = responsePromises[key];\n      traceReceivedResponse(responseMessage, responsePromise);\n\n      if (responsePromise) {\n        delete responsePromises[key];\n\n        try {\n          if (responseMessage.error) {\n            const error = responseMessage.error;\n            responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));\n          } else if (responseMessage.result !== undefined) {\n            responsePromise.resolve(responseMessage.result);\n          } else {\n            throw new Error('Should never happen.');\n          }\n        } catch (error) {\n          if (error.message) {\n            logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);\n          } else {\n            logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);\n          }\n        }\n      }\n    }\n  }\n\n  function handleNotification(message) {\n    if (isDisposed()) {\n      // See handle request.\n      return;\n    }\n\n    let type = undefined;\n    let notificationHandler;\n\n    if (message.method === CancelNotification.type.method) {\n      notificationHandler = params => {\n        const id = params.id;\n        const source = requestTokens[String(id)];\n\n        if (source) {\n          source.cancel();\n        }\n      };\n    } else {\n      const element = notificationHandlers[message.method];\n\n      if (element) {\n        notificationHandler = element.handler;\n        type = element.type;\n      }\n    }\n\n    if (notificationHandler || starNotificationHandler) {\n      try {\n        traceReceivedNotification(message);\n\n        if (notificationHandler) {\n          if (message.params === undefined) {\n            if (type !== undefined) {\n              if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {\n                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but recevied none.`);\n              }\n            }\n\n            notificationHandler();\n          } else if (Array.isArray(message.params)) {\n            if (type !== undefined) {\n              if (type.parameterStructures === messages_1.ParameterStructures.byName) {\n                logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);\n              }\n\n              if (type.numberOfParams !== message.params.length) {\n                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${message.params.length} argumennts`);\n              }\n            }\n\n            notificationHandler(...message.params);\n          } else {\n            if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {\n              logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);\n            }\n\n            notificationHandler(message.params);\n          }\n        } else if (starNotificationHandler) {\n          starNotificationHandler(message.method, message.params);\n        }\n      } catch (error) {\n        if (error.message) {\n          logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);\n        } else {\n          logger.error(`Notification handler '${message.method}' failed unexpectedly.`);\n        }\n      }\n    } else {\n      unhandledNotificationEmitter.fire(message);\n    }\n  }\n\n  function handleInvalidMessage(message) {\n    if (!message) {\n      logger.error('Received empty message.');\n      return;\n    }\n\n    logger.error(`Received message which is neither a response nor a notification message:\\n${JSON.stringify(message, null, 4)}`); // Test whether we find an id to reject the promise\n\n    const responseMessage = message;\n\n    if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {\n      const key = String(responseMessage.id);\n      const responseHandler = responsePromises[key];\n\n      if (responseHandler) {\n        responseHandler.reject(new Error('The received response has neither a result nor an error property.'));\n      }\n    }\n  }\n\n  function traceSendingRequest(message) {\n    if (trace === Trace.Off || !tracer) {\n      return;\n    }\n\n    if (traceFormat === TraceFormat.Text) {\n      let data = undefined;\n\n      if (trace === Trace.Verbose && message.params) {\n        data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\n      }\n\n      tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);\n    } else {\n      logLSPMessage('send-request', message);\n    }\n  }\n\n  function traceSendingNotification(message) {\n    if (trace === Trace.Off || !tracer) {\n      return;\n    }\n\n    if (traceFormat === TraceFormat.Text) {\n      let data = undefined;\n\n      if (trace === Trace.Verbose) {\n        if (message.params) {\n          data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\n        } else {\n          data = 'No parameters provided.\\n\\n';\n        }\n      }\n\n      tracer.log(`Sending notification '${message.method}'.`, data);\n    } else {\n      logLSPMessage('send-notification', message);\n    }\n  }\n\n  function traceSendingResponse(message, method, startTime) {\n    if (trace === Trace.Off || !tracer) {\n      return;\n    }\n\n    if (traceFormat === TraceFormat.Text) {\n      let data = undefined;\n\n      if (trace === Trace.Verbose) {\n        if (message.error && message.error.data) {\n          data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\\n\\n`;\n        } else {\n          if (message.result) {\n            data = `Result: ${JSON.stringify(message.result, null, 4)}\\n\\n`;\n          } else if (message.error === undefined) {\n            data = 'No result returned.\\n\\n';\n          }\n        }\n      }\n\n      tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);\n    } else {\n      logLSPMessage('send-response', message);\n    }\n  }\n\n  function traceReceivedRequest(message) {\n    if (trace === Trace.Off || !tracer) {\n      return;\n    }\n\n    if (traceFormat === TraceFormat.Text) {\n      let data = undefined;\n\n      if (trace === Trace.Verbose && message.params) {\n        data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\n      }\n\n      tracer.log(`Received request '${message.method} - (${message.id})'.`, data);\n    } else {\n      logLSPMessage('receive-request', message);\n    }\n  }\n\n  function traceReceivedNotification(message) {\n    if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {\n      return;\n    }\n\n    if (traceFormat === TraceFormat.Text) {\n      let data = undefined;\n\n      if (trace === Trace.Verbose) {\n        if (message.params) {\n          data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\n        } else {\n          data = 'No parameters provided.\\n\\n';\n        }\n      }\n\n      tracer.log(`Received notification '${message.method}'.`, data);\n    } else {\n      logLSPMessage('receive-notification', message);\n    }\n  }\n\n  function traceReceivedResponse(message, responsePromise) {\n    if (trace === Trace.Off || !tracer) {\n      return;\n    }\n\n    if (traceFormat === TraceFormat.Text) {\n      let data = undefined;\n\n      if (trace === Trace.Verbose) {\n        if (message.error && message.error.data) {\n          data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\\n\\n`;\n        } else {\n          if (message.result) {\n            data = `Result: ${JSON.stringify(message.result, null, 4)}\\n\\n`;\n          } else if (message.error === undefined) {\n            data = 'No result returned.\\n\\n';\n          }\n        }\n      }\n\n      if (responsePromise) {\n        const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';\n        tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);\n      } else {\n        tracer.log(`Received response ${message.id} without active response promise.`, data);\n      }\n    } else {\n      logLSPMessage('receive-response', message);\n    }\n  }\n\n  function logLSPMessage(type, message) {\n    if (!tracer || trace === Trace.Off) {\n      return;\n    }\n\n    const lspMessage = {\n      isLSPMessage: true,\n      type,\n      message,\n      timestamp: Date.now()\n    };\n    tracer.log(lspMessage);\n  }\n\n  function throwIfClosedOrDisposed() {\n    if (isClosed()) {\n      throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');\n    }\n\n    if (isDisposed()) {\n      throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');\n    }\n  }\n\n  function throwIfListening() {\n    if (isListening()) {\n      throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');\n    }\n  }\n\n  function throwIfNotListening() {\n    if (!isListening()) {\n      throw new Error('Call listen() first.');\n    }\n  }\n\n  function undefinedToNull(param) {\n    if (param === undefined) {\n      return null;\n    } else {\n      return param;\n    }\n  }\n\n  function nullToUndefined(param) {\n    if (param === null) {\n      return undefined;\n    } else {\n      return param;\n    }\n  }\n\n  function isNamedParam(param) {\n    return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';\n  }\n\n  function computeSingleParam(parameterStructures, param) {\n    switch (parameterStructures) {\n      case messages_1.ParameterStructures.auto:\n        if (isNamedParam(param)) {\n          return nullToUndefined(param);\n        } else {\n          return [undefinedToNull(param)];\n        }\n\n        break;\n\n      case messages_1.ParameterStructures.byName:\n        if (!isNamedParam(param)) {\n          throw new Error(`Recevied parameters by name but param is not an object literal.`);\n        }\n\n        return nullToUndefined(param);\n\n      case messages_1.ParameterStructures.byPosition:\n        return [undefinedToNull(param)];\n\n      default:\n        throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);\n    }\n  }\n\n  function computeMessageParams(type, params) {\n    let result;\n    const numberOfParams = type.numberOfParams;\n\n    switch (numberOfParams) {\n      case 0:\n        result = undefined;\n        break;\n\n      case 1:\n        result = computeSingleParam(type.parameterStructures, params[0]);\n        break;\n\n      default:\n        result = [];\n\n        for (let i = 0; i < params.length && i < numberOfParams; i++) {\n          result.push(undefinedToNull(params[i]));\n        }\n\n        if (params.length < numberOfParams) {\n          for (let i = params.length; i < numberOfParams; i++) {\n            result.push(null);\n          }\n        }\n\n        break;\n    }\n\n    return result;\n  }\n\n  const connection = {\n    sendNotification: (type, ...args) => {\n      throwIfClosedOrDisposed();\n      let method;\n      let messageParams;\n\n      if (Is.string(type)) {\n        method = type;\n        const first = args[0];\n        let paramStart = 0;\n        let parameterStructures = messages_1.ParameterStructures.auto;\n\n        if (messages_1.ParameterStructures.is(first)) {\n          paramStart = 1;\n          parameterStructures = first;\n        }\n\n        let paramEnd = args.length;\n        const numberOfParams = paramEnd - paramStart;\n\n        switch (numberOfParams) {\n          case 0:\n            messageParams = undefined;\n            break;\n\n          case 1:\n            messageParams = computeSingleParam(parameterStructures, args[paramStart]);\n            break;\n\n          default:\n            if (parameterStructures === messages_1.ParameterStructures.byName) {\n              throw new Error(`Recevied ${numberOfParams} parameters for 'by Name' notification parameter structure.`);\n            }\n\n            messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));\n            break;\n        }\n      } else {\n        const params = args;\n        method = type.method;\n        messageParams = computeMessageParams(type, params);\n      }\n\n      const notificationMessage = {\n        jsonrpc: version,\n        method: method,\n        params: messageParams\n      };\n      traceSendingNotification(notificationMessage);\n      messageWriter.write(notificationMessage);\n    },\n    onNotification: (type, handler) => {\n      throwIfClosedOrDisposed();\n      let method;\n\n      if (Is.func(type)) {\n        starNotificationHandler = type;\n      } else if (handler) {\n        if (Is.string(type)) {\n          method = type;\n          notificationHandlers[type] = {\n            type: undefined,\n            handler\n          };\n        } else {\n          method = type.method;\n          notificationHandlers[type.method] = {\n            type,\n            handler\n          };\n        }\n      }\n\n      return {\n        dispose: () => {\n          if (method !== undefined) {\n            delete notificationHandlers[method];\n          } else {\n            starNotificationHandler = undefined;\n          }\n        }\n      };\n    },\n    onProgress: (_type, token, handler) => {\n      if (progressHandlers.has(token)) {\n        throw new Error(`Progress handler for token ${token} already registered`);\n      }\n\n      progressHandlers.set(token, handler);\n      return {\n        dispose: () => {\n          progressHandlers.delete(token);\n        }\n      };\n    },\n    sendProgress: (_type, token, value) => {\n      connection.sendNotification(ProgressNotification.type, {\n        token,\n        value\n      });\n    },\n    onUnhandledProgress: unhandledProgressEmitter.event,\n    sendRequest: (type, ...args) => {\n      throwIfClosedOrDisposed();\n      throwIfNotListening();\n      let method;\n      let messageParams;\n      let token = undefined;\n\n      if (Is.string(type)) {\n        method = type;\n        const first = args[0];\n        const last = args[args.length - 1];\n        let paramStart = 0;\n        let parameterStructures = messages_1.ParameterStructures.auto;\n\n        if (messages_1.ParameterStructures.is(first)) {\n          paramStart = 1;\n          parameterStructures = first;\n        }\n\n        let paramEnd = args.length;\n\n        if (cancellation_1.CancellationToken.is(last)) {\n          paramEnd = paramEnd - 1;\n          token = last;\n        }\n\n        const numberOfParams = paramEnd - paramStart;\n\n        switch (numberOfParams) {\n          case 0:\n            messageParams = undefined;\n            break;\n\n          case 1:\n            messageParams = computeSingleParam(parameterStructures, args[paramStart]);\n            break;\n\n          default:\n            if (parameterStructures === messages_1.ParameterStructures.byName) {\n              throw new Error(`Recevied ${numberOfParams} parameters for 'by Name' request parameter structure.`);\n            }\n\n            messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));\n            break;\n        }\n      } else {\n        const params = args;\n        method = type.method;\n        messageParams = computeMessageParams(type, params);\n        const numberOfParams = type.numberOfParams;\n        token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;\n      }\n\n      const id = sequenceNumber++;\n      let disposable;\n\n      if (token) {\n        disposable = token.onCancellationRequested(() => {\n          cancellationStrategy.sender.sendCancellation(connection, id);\n        });\n      }\n\n      const result = new Promise((resolve, reject) => {\n        const requestMessage = {\n          jsonrpc: version,\n          id: id,\n          method: method,\n          params: messageParams\n        };\n\n        const resolveWithCleanup = r => {\n          resolve(r);\n          cancellationStrategy.sender.cleanup(id);\n          disposable === null || disposable === void 0 ? void 0 : disposable.dispose();\n        };\n\n        const rejectWithCleanup = r => {\n          reject(r);\n          cancellationStrategy.sender.cleanup(id);\n          disposable === null || disposable === void 0 ? void 0 : disposable.dispose();\n        };\n\n        let responsePromise = {\n          method: method,\n          timerStart: Date.now(),\n          resolve: resolveWithCleanup,\n          reject: rejectWithCleanup\n        };\n        traceSendingRequest(requestMessage);\n\n        try {\n          messageWriter.write(requestMessage);\n        } catch (e) {\n          // Writing the message failed. So we need to reject the promise.\n          responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : 'Unknown reason'));\n          responsePromise = null;\n        }\n\n        if (responsePromise) {\n          responsePromises[String(id)] = responsePromise;\n        }\n      });\n      return result;\n    },\n    onRequest: (type, handler) => {\n      throwIfClosedOrDisposed();\n      let method = null;\n\n      if (StarRequestHandler.is(type)) {\n        method = undefined;\n        starRequestHandler = type;\n      } else if (Is.string(type)) {\n        method = null;\n\n        if (handler !== undefined) {\n          method = type;\n          requestHandlers[type] = {\n            handler: handler,\n            type: undefined\n          };\n        }\n      } else {\n        if (handler !== undefined) {\n          method = type.method;\n          requestHandlers[type.method] = {\n            type,\n            handler\n          };\n        }\n      }\n\n      return {\n        dispose: () => {\n          if (method === null) {\n            return;\n          }\n\n          if (method !== undefined) {\n            delete requestHandlers[method];\n          } else {\n            starRequestHandler = undefined;\n          }\n        }\n      };\n    },\n    trace: (_value, _tracer, sendNotificationOrTraceOptions) => {\n      let _sendNotification = false;\n      let _traceFormat = TraceFormat.Text;\n\n      if (sendNotificationOrTraceOptions !== undefined) {\n        if (Is.boolean(sendNotificationOrTraceOptions)) {\n          _sendNotification = sendNotificationOrTraceOptions;\n        } else {\n          _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;\n          _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;\n        }\n      }\n\n      trace = _value;\n      traceFormat = _traceFormat;\n\n      if (trace === Trace.Off) {\n        tracer = undefined;\n      } else {\n        tracer = _tracer;\n      }\n\n      if (_sendNotification && !isClosed() && !isDisposed()) {\n        connection.sendNotification(SetTraceNotification.type, {\n          value: Trace.toString(_value)\n        });\n      }\n    },\n    onError: errorEmitter.event,\n    onClose: closeEmitter.event,\n    onUnhandledNotification: unhandledNotificationEmitter.event,\n    onDispose: disposeEmitter.event,\n    end: () => {\n      messageWriter.end();\n    },\n    dispose: () => {\n      if (isDisposed()) {\n        return;\n      }\n\n      state = ConnectionState.Disposed;\n      disposeEmitter.fire(undefined);\n      const error = new Error('Connection got disposed.');\n      Object.keys(responsePromises).forEach(key => {\n        responsePromises[key].reject(error);\n      });\n      responsePromises = Object.create(null);\n      requestTokens = Object.create(null);\n      messageQueue = new linkedMap_1.LinkedMap(); // Test for backwards compatibility\n\n      if (Is.func(messageWriter.dispose)) {\n        messageWriter.dispose();\n      }\n\n      if (Is.func(messageReader.dispose)) {\n        messageReader.dispose();\n      }\n    },\n    listen: () => {\n      throwIfClosedOrDisposed();\n      throwIfListening();\n      state = ConnectionState.Listening;\n      messageReader.listen(callback);\n    },\n    inspect: () => {\n      // eslint-disable-next-line no-console\n      ral_1.default().console.log('inspect');\n    }\n  };\n  connection.onNotification(LogTraceNotification.type, params => {\n    if (trace === Trace.Off || !tracer) {\n      return;\n    }\n\n    tracer.log(params.message, trace === Trace.Verbose ? params.verbose : undefined);\n  });\n  connection.onNotification(ProgressNotification.type, params => {\n    const handler = progressHandlers.get(params.token);\n\n    if (handler) {\n      handler(params.value);\n    } else {\n      unhandledProgressEmitter.fire(params);\n    }\n  });\n  return connection;\n}\n\nexports.createMessageConnection = createMessageConnection;","map":{"version":3,"names":["Object","defineProperty","exports","value","createMessageConnection","ConnectionOptions","CancellationStrategy","CancellationSenderStrategy","CancellationReceiverStrategy","ConnectionStrategy","ConnectionError","ConnectionErrors","LogTraceNotification","SetTraceNotification","TraceFormat","Trace","NullLogger","ProgressType","ral_1","require","Is","messages_1","linkedMap_1","events_1","cancellation_1","CancelNotification","type","NotificationType","ProgressNotification","constructor","StarRequestHandler","is","func","freeze","error","warn","info","log","fromString","string","Off","toLowerCase","Messages","Verbose","toString","JSON","Text","Error","code","message","setPrototypeOf","prototype","candidate","cancelUndispatched","Message","createCancellationTokenSource","_","CancellationTokenSource","sendCancellation","conn","id","sendNotification","cleanup","receiver","sender","cancellationStrategy","connectionStrategy","ConnectionState","messageReader","messageWriter","_logger","options","logger","undefined","sequenceNumber","notificationSquenceNumber","unknownResponseSquenceNumber","version","starRequestHandler","requestHandlers","create","starNotificationHandler","notificationHandlers","progressHandlers","Map","timer","messageQueue","LinkedMap","responsePromises","requestTokens","trace","traceFormat","tracer","state","New","errorEmitter","Emitter","closeEmitter","unhandledNotificationEmitter","unhandledProgressEmitter","disposeEmitter","createRequestQueueKey","createResponseQueueKey","createNotificationQueueKey","addMessageToQueue","queue","isRequestMessage","set","isResponseMessage","_message","isListening","Listening","isClosed","Closed","isDisposed","Disposed","closeHandler","fire","readErrorHandler","writeErrorHandler","data","onClose","onError","triggerMessageQueue","size","default","setImmediate","processMessageQueue","shift","handleRequest","isNotificationMessage","handleNotification","handleResponse","handleInvalidMessage","callback","method","key","params","toCancel","get","strategy","response","result","delete","traceSendingResponse","Date","now","write","requestMessage","reply","resultOrError","startTime","jsonrpc","ResponseError","toJson","replyError","replySuccess","traceReceivedRequest","element","requestHandler","handler","tokenKey","String","cancellationSource","handlerResult","numberOfParams","ErrorCodes","InvalidParams","token","Array","isArray","parameterStructures","ParameterStructures","byName","byPosition","promise","then","InternalError","MethodNotFound","responseMessage","stringify","responsePromise","traceReceivedResponse","reject","resolve","notificationHandler","source","cancel","traceReceivedNotification","length","number","responseHandler","traceSendingRequest","logLSPMessage","traceSendingNotification","timerStart","lspMessage","isLSPMessage","timestamp","throwIfClosedOrDisposed","throwIfListening","AlreadyListening","throwIfNotListening","undefinedToNull","param","nullToUndefined","isNamedParam","computeSingleParam","auto","computeMessageParams","i","push","connection","args","messageParams","first","paramStart","paramEnd","slice","map","notificationMessage","onNotification","dispose","onProgress","_type","has","sendProgress","onUnhandledProgress","event","sendRequest","last","CancellationToken","disposable","onCancellationRequested","Promise","resolveWithCleanup","r","rejectWithCleanup","e","MessageWriteError","onRequest","_value","_tracer","sendNotificationOrTraceOptions","_sendNotification","_traceFormat","boolean","onUnhandledNotification","onDispose","end","keys","forEach","listen","inspect","console","verbose"],"sources":["/Users/Ellie/Desktop/projects/book-search-engine/client/node_modules/vscode-jsonrpc/lib/common/connection.js"],"sourcesContent":["\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createMessageConnection = exports.ConnectionOptions = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.Trace = exports.NullLogger = exports.ProgressType = void 0;\nconst ral_1 = require(\"./ral\");\nconst Is = require(\"./is\");\nconst messages_1 = require(\"./messages\");\nconst linkedMap_1 = require(\"./linkedMap\");\nconst events_1 = require(\"./events\");\nconst cancellation_1 = require(\"./cancellation\");\nvar CancelNotification;\n(function (CancelNotification) {\n    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');\n})(CancelNotification || (CancelNotification = {}));\nvar ProgressNotification;\n(function (ProgressNotification) {\n    ProgressNotification.type = new messages_1.NotificationType('$/progress');\n})(ProgressNotification || (ProgressNotification = {}));\nclass ProgressType {\n    constructor() {\n    }\n}\nexports.ProgressType = ProgressType;\nvar StarRequestHandler;\n(function (StarRequestHandler) {\n    function is(value) {\n        return Is.func(value);\n    }\n    StarRequestHandler.is = is;\n})(StarRequestHandler || (StarRequestHandler = {}));\nexports.NullLogger = Object.freeze({\n    error: () => { },\n    warn: () => { },\n    info: () => { },\n    log: () => { }\n});\nvar Trace;\n(function (Trace) {\n    Trace[Trace[\"Off\"] = 0] = \"Off\";\n    Trace[Trace[\"Messages\"] = 1] = \"Messages\";\n    Trace[Trace[\"Verbose\"] = 2] = \"Verbose\";\n})(Trace = exports.Trace || (exports.Trace = {}));\n(function (Trace) {\n    function fromString(value) {\n        if (!Is.string(value)) {\n            return Trace.Off;\n        }\n        value = value.toLowerCase();\n        switch (value) {\n            case 'off':\n                return Trace.Off;\n            case 'messages':\n                return Trace.Messages;\n            case 'verbose':\n                return Trace.Verbose;\n            default:\n                return Trace.Off;\n        }\n    }\n    Trace.fromString = fromString;\n    function toString(value) {\n        switch (value) {\n            case Trace.Off:\n                return 'off';\n            case Trace.Messages:\n                return 'messages';\n            case Trace.Verbose:\n                return 'verbose';\n            default:\n                return 'off';\n        }\n    }\n    Trace.toString = toString;\n})(Trace = exports.Trace || (exports.Trace = {}));\nvar TraceFormat;\n(function (TraceFormat) {\n    TraceFormat[\"Text\"] = \"text\";\n    TraceFormat[\"JSON\"] = \"json\";\n})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));\n(function (TraceFormat) {\n    function fromString(value) {\n        value = value.toLowerCase();\n        if (value === 'json') {\n            return TraceFormat.JSON;\n        }\n        else {\n            return TraceFormat.Text;\n        }\n    }\n    TraceFormat.fromString = fromString;\n})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));\nvar SetTraceNotification;\n(function (SetTraceNotification) {\n    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');\n})(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));\nvar LogTraceNotification;\n(function (LogTraceNotification) {\n    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');\n})(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));\nvar ConnectionErrors;\n(function (ConnectionErrors) {\n    /**\n     * The connection is closed.\n     */\n    ConnectionErrors[ConnectionErrors[\"Closed\"] = 1] = \"Closed\";\n    /**\n     * The connection got disposed.\n     */\n    ConnectionErrors[ConnectionErrors[\"Disposed\"] = 2] = \"Disposed\";\n    /**\n     * The connection is already in listening mode.\n     */\n    ConnectionErrors[ConnectionErrors[\"AlreadyListening\"] = 3] = \"AlreadyListening\";\n})(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));\nclass ConnectionError extends Error {\n    constructor(code, message) {\n        super(message);\n        this.code = code;\n        Object.setPrototypeOf(this, ConnectionError.prototype);\n    }\n}\nexports.ConnectionError = ConnectionError;\nvar ConnectionStrategy;\n(function (ConnectionStrategy) {\n    function is(value) {\n        const candidate = value;\n        return candidate && Is.func(candidate.cancelUndispatched);\n    }\n    ConnectionStrategy.is = is;\n})(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));\nvar CancellationReceiverStrategy;\n(function (CancellationReceiverStrategy) {\n    CancellationReceiverStrategy.Message = Object.freeze({\n        createCancellationTokenSource(_) {\n            return new cancellation_1.CancellationTokenSource();\n        }\n    });\n    function is(value) {\n        const candidate = value;\n        return candidate && Is.func(candidate.createCancellationTokenSource);\n    }\n    CancellationReceiverStrategy.is = is;\n})(CancellationReceiverStrategy = exports.CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = {}));\nvar CancellationSenderStrategy;\n(function (CancellationSenderStrategy) {\n    CancellationSenderStrategy.Message = Object.freeze({\n        sendCancellation(conn, id) {\n            conn.sendNotification(CancelNotification.type, { id });\n        },\n        cleanup(_) { }\n    });\n    function is(value) {\n        const candidate = value;\n        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);\n    }\n    CancellationSenderStrategy.is = is;\n})(CancellationSenderStrategy = exports.CancellationSenderStrategy || (exports.CancellationSenderStrategy = {}));\nvar CancellationStrategy;\n(function (CancellationStrategy) {\n    CancellationStrategy.Message = Object.freeze({\n        receiver: CancellationReceiverStrategy.Message,\n        sender: CancellationSenderStrategy.Message\n    });\n    function is(value) {\n        const candidate = value;\n        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);\n    }\n    CancellationStrategy.is = is;\n})(CancellationStrategy = exports.CancellationStrategy || (exports.CancellationStrategy = {}));\nvar ConnectionOptions;\n(function (ConnectionOptions) {\n    function is(value) {\n        const candidate = value;\n        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));\n    }\n    ConnectionOptions.is = is;\n})(ConnectionOptions = exports.ConnectionOptions || (exports.ConnectionOptions = {}));\nvar ConnectionState;\n(function (ConnectionState) {\n    ConnectionState[ConnectionState[\"New\"] = 1] = \"New\";\n    ConnectionState[ConnectionState[\"Listening\"] = 2] = \"Listening\";\n    ConnectionState[ConnectionState[\"Closed\"] = 3] = \"Closed\";\n    ConnectionState[ConnectionState[\"Disposed\"] = 4] = \"Disposed\";\n})(ConnectionState || (ConnectionState = {}));\nfunction createMessageConnection(messageReader, messageWriter, _logger, options) {\n    const logger = _logger !== undefined ? _logger : exports.NullLogger;\n    let sequenceNumber = 0;\n    let notificationSquenceNumber = 0;\n    let unknownResponseSquenceNumber = 0;\n    const version = '2.0';\n    let starRequestHandler = undefined;\n    const requestHandlers = Object.create(null);\n    let starNotificationHandler = undefined;\n    const notificationHandlers = Object.create(null);\n    const progressHandlers = new Map();\n    let timer;\n    let messageQueue = new linkedMap_1.LinkedMap();\n    let responsePromises = Object.create(null);\n    let requestTokens = Object.create(null);\n    let trace = Trace.Off;\n    let traceFormat = TraceFormat.Text;\n    let tracer;\n    let state = ConnectionState.New;\n    const errorEmitter = new events_1.Emitter();\n    const closeEmitter = new events_1.Emitter();\n    const unhandledNotificationEmitter = new events_1.Emitter();\n    const unhandledProgressEmitter = new events_1.Emitter();\n    const disposeEmitter = new events_1.Emitter();\n    const cancellationStrategy = (options && options.cancellationStrategy) ? options.cancellationStrategy : CancellationStrategy.Message;\n    function createRequestQueueKey(id) {\n        if (id === null) {\n            throw new Error(`Can't send requests with id null since the response can't be correlated.`);\n        }\n        return 'req-' + id.toString();\n    }\n    function createResponseQueueKey(id) {\n        if (id === null) {\n            return 'res-unknown-' + (++unknownResponseSquenceNumber).toString();\n        }\n        else {\n            return 'res-' + id.toString();\n        }\n    }\n    function createNotificationQueueKey() {\n        return 'not-' + (++notificationSquenceNumber).toString();\n    }\n    function addMessageToQueue(queue, message) {\n        if (messages_1.isRequestMessage(message)) {\n            queue.set(createRequestQueueKey(message.id), message);\n        }\n        else if (messages_1.isResponseMessage(message)) {\n            queue.set(createResponseQueueKey(message.id), message);\n        }\n        else {\n            queue.set(createNotificationQueueKey(), message);\n        }\n    }\n    function cancelUndispatched(_message) {\n        return undefined;\n    }\n    function isListening() {\n        return state === ConnectionState.Listening;\n    }\n    function isClosed() {\n        return state === ConnectionState.Closed;\n    }\n    function isDisposed() {\n        return state === ConnectionState.Disposed;\n    }\n    function closeHandler() {\n        if (state === ConnectionState.New || state === ConnectionState.Listening) {\n            state = ConnectionState.Closed;\n            closeEmitter.fire(undefined);\n        }\n        // If the connection is disposed don't sent close events.\n    }\n    function readErrorHandler(error) {\n        errorEmitter.fire([error, undefined, undefined]);\n    }\n    function writeErrorHandler(data) {\n        errorEmitter.fire(data);\n    }\n    messageReader.onClose(closeHandler);\n    messageReader.onError(readErrorHandler);\n    messageWriter.onClose(closeHandler);\n    messageWriter.onError(writeErrorHandler);\n    function triggerMessageQueue() {\n        if (timer || messageQueue.size === 0) {\n            return;\n        }\n        timer = ral_1.default().timer.setImmediate(() => {\n            timer = undefined;\n            processMessageQueue();\n        });\n    }\n    function processMessageQueue() {\n        if (messageQueue.size === 0) {\n            return;\n        }\n        const message = messageQueue.shift();\n        try {\n            if (messages_1.isRequestMessage(message)) {\n                handleRequest(message);\n            }\n            else if (messages_1.isNotificationMessage(message)) {\n                handleNotification(message);\n            }\n            else if (messages_1.isResponseMessage(message)) {\n                handleResponse(message);\n            }\n            else {\n                handleInvalidMessage(message);\n            }\n        }\n        finally {\n            triggerMessageQueue();\n        }\n    }\n    const callback = (message) => {\n        try {\n            // We have received a cancellation message. Check if the message is still in the queue\n            // and cancel it if allowed to do so.\n            if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {\n                const key = createRequestQueueKey(message.params.id);\n                const toCancel = messageQueue.get(key);\n                if (messages_1.isRequestMessage(toCancel)) {\n                    const strategy = options === null || options === void 0 ? void 0 : options.connectionStrategy;\n                    const response = (strategy && strategy.cancelUndispatched) ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);\n                    if (response && (response.error !== undefined || response.result !== undefined)) {\n                        messageQueue.delete(key);\n                        response.id = toCancel.id;\n                        traceSendingResponse(response, message.method, Date.now());\n                        messageWriter.write(response);\n                        return;\n                    }\n                }\n            }\n            addMessageToQueue(messageQueue, message);\n        }\n        finally {\n            triggerMessageQueue();\n        }\n    };\n    function handleRequest(requestMessage) {\n        if (isDisposed()) {\n            // we return here silently since we fired an event when the\n            // connection got disposed.\n            return;\n        }\n        function reply(resultOrError, method, startTime) {\n            const message = {\n                jsonrpc: version,\n                id: requestMessage.id\n            };\n            if (resultOrError instanceof messages_1.ResponseError) {\n                message.error = resultOrError.toJson();\n            }\n            else {\n                message.result = resultOrError === undefined ? null : resultOrError;\n            }\n            traceSendingResponse(message, method, startTime);\n            messageWriter.write(message);\n        }\n        function replyError(error, method, startTime) {\n            const message = {\n                jsonrpc: version,\n                id: requestMessage.id,\n                error: error.toJson()\n            };\n            traceSendingResponse(message, method, startTime);\n            messageWriter.write(message);\n        }\n        function replySuccess(result, method, startTime) {\n            // The JSON RPC defines that a response must either have a result or an error\n            // So we can't treat undefined as a valid response result.\n            if (result === undefined) {\n                result = null;\n            }\n            const message = {\n                jsonrpc: version,\n                id: requestMessage.id,\n                result: result\n            };\n            traceSendingResponse(message, method, startTime);\n            messageWriter.write(message);\n        }\n        traceReceivedRequest(requestMessage);\n        const element = requestHandlers[requestMessage.method];\n        let type;\n        let requestHandler;\n        if (element) {\n            type = element.type;\n            requestHandler = element.handler;\n        }\n        const startTime = Date.now();\n        if (requestHandler || starRequestHandler) {\n            const tokenKey = String(requestMessage.id);\n            const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);\n            requestTokens[tokenKey] = cancellationSource;\n            try {\n                let handlerResult;\n                if (requestHandler) {\n                    if (requestMessage.params === undefined) {\n                        if (type !== undefined && type.numberOfParams !== 0) {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but recevied none.`), requestMessage.method, startTime);\n                            return;\n                        }\n                        handlerResult = requestHandler(cancellationSource.token);\n                    }\n                    else if (Array.isArray(requestMessage.params)) {\n                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);\n                            return;\n                        }\n                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);\n                    }\n                    else {\n                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);\n                            return;\n                        }\n                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);\n                    }\n                }\n                else if (starRequestHandler) {\n                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);\n                }\n                const promise = handlerResult;\n                if (!handlerResult) {\n                    delete requestTokens[tokenKey];\n                    replySuccess(handlerResult, requestMessage.method, startTime);\n                }\n                else if (promise.then) {\n                    promise.then((resultOrError) => {\n                        delete requestTokens[tokenKey];\n                        reply(resultOrError, requestMessage.method, startTime);\n                    }, error => {\n                        delete requestTokens[tokenKey];\n                        if (error instanceof messages_1.ResponseError) {\n                            replyError(error, requestMessage.method, startTime);\n                        }\n                        else if (error && Is.string(error.message)) {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);\n                        }\n                        else {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);\n                        }\n                    });\n                }\n                else {\n                    delete requestTokens[tokenKey];\n                    reply(handlerResult, requestMessage.method, startTime);\n                }\n            }\n            catch (error) {\n                delete requestTokens[tokenKey];\n                if (error instanceof messages_1.ResponseError) {\n                    reply(error, requestMessage.method, startTime);\n                }\n                else if (error && Is.string(error.message)) {\n                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);\n                }\n                else {\n                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);\n                }\n            }\n        }\n        else {\n            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);\n        }\n    }\n    function handleResponse(responseMessage) {\n        if (isDisposed()) {\n            // See handle request.\n            return;\n        }\n        if (responseMessage.id === null) {\n            if (responseMessage.error) {\n                logger.error(`Received response message without id: Error is: \\n${JSON.stringify(responseMessage.error, undefined, 4)}`);\n            }\n            else {\n                logger.error(`Received response message without id. No further error information provided.`);\n            }\n        }\n        else {\n            const key = String(responseMessage.id);\n            const responsePromise = responsePromises[key];\n            traceReceivedResponse(responseMessage, responsePromise);\n            if (responsePromise) {\n                delete responsePromises[key];\n                try {\n                    if (responseMessage.error) {\n                        const error = responseMessage.error;\n                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));\n                    }\n                    else if (responseMessage.result !== undefined) {\n                        responsePromise.resolve(responseMessage.result);\n                    }\n                    else {\n                        throw new Error('Should never happen.');\n                    }\n                }\n                catch (error) {\n                    if (error.message) {\n                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);\n                    }\n                    else {\n                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);\n                    }\n                }\n            }\n        }\n    }\n    function handleNotification(message) {\n        if (isDisposed()) {\n            // See handle request.\n            return;\n        }\n        let type = undefined;\n        let notificationHandler;\n        if (message.method === CancelNotification.type.method) {\n            notificationHandler = (params) => {\n                const id = params.id;\n                const source = requestTokens[String(id)];\n                if (source) {\n                    source.cancel();\n                }\n            };\n        }\n        else {\n            const element = notificationHandlers[message.method];\n            if (element) {\n                notificationHandler = element.handler;\n                type = element.type;\n            }\n        }\n        if (notificationHandler || starNotificationHandler) {\n            try {\n                traceReceivedNotification(message);\n                if (notificationHandler) {\n                    if (message.params === undefined) {\n                        if (type !== undefined) {\n                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {\n                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but recevied none.`);\n                            }\n                        }\n                        notificationHandler();\n                    }\n                    else if (Array.isArray(message.params)) {\n                        if (type !== undefined) {\n                            if (type.parameterStructures === messages_1.ParameterStructures.byName) {\n                                logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);\n                            }\n                            if (type.numberOfParams !== message.params.length) {\n                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${message.params.length} argumennts`);\n                            }\n                        }\n                        notificationHandler(...message.params);\n                    }\n                    else {\n                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {\n                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);\n                        }\n                        notificationHandler(message.params);\n                    }\n                }\n                else if (starNotificationHandler) {\n                    starNotificationHandler(message.method, message.params);\n                }\n            }\n            catch (error) {\n                if (error.message) {\n                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);\n                }\n                else {\n                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);\n                }\n            }\n        }\n        else {\n            unhandledNotificationEmitter.fire(message);\n        }\n    }\n    function handleInvalidMessage(message) {\n        if (!message) {\n            logger.error('Received empty message.');\n            return;\n        }\n        logger.error(`Received message which is neither a response nor a notification message:\\n${JSON.stringify(message, null, 4)}`);\n        // Test whether we find an id to reject the promise\n        const responseMessage = message;\n        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {\n            const key = String(responseMessage.id);\n            const responseHandler = responsePromises[key];\n            if (responseHandler) {\n                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));\n            }\n        }\n    }\n    function traceSendingRequest(message) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if (trace === Trace.Verbose && message.params) {\n                data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\n            }\n            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);\n        }\n        else {\n            logLSPMessage('send-request', message);\n        }\n    }\n    function traceSendingNotification(message) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if (trace === Trace.Verbose) {\n                if (message.params) {\n                    data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\n                }\n                else {\n                    data = 'No parameters provided.\\n\\n';\n                }\n            }\n            tracer.log(`Sending notification '${message.method}'.`, data);\n        }\n        else {\n            logLSPMessage('send-notification', message);\n        }\n    }\n    function traceSendingResponse(message, method, startTime) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if (trace === Trace.Verbose) {\n                if (message.error && message.error.data) {\n                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\\n\\n`;\n                }\n                else {\n                    if (message.result) {\n                        data = `Result: ${JSON.stringify(message.result, null, 4)}\\n\\n`;\n                    }\n                    else if (message.error === undefined) {\n                        data = 'No result returned.\\n\\n';\n                    }\n                }\n            }\n            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);\n        }\n        else {\n            logLSPMessage('send-response', message);\n        }\n    }\n    function traceReceivedRequest(message) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if (trace === Trace.Verbose && message.params) {\n                data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\n            }\n            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);\n        }\n        else {\n            logLSPMessage('receive-request', message);\n        }\n    }\n    function traceReceivedNotification(message) {\n        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if (trace === Trace.Verbose) {\n                if (message.params) {\n                    data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\n                }\n                else {\n                    data = 'No parameters provided.\\n\\n';\n                }\n            }\n            tracer.log(`Received notification '${message.method}'.`, data);\n        }\n        else {\n            logLSPMessage('receive-notification', message);\n        }\n    }\n    function traceReceivedResponse(message, responsePromise) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if (trace === Trace.Verbose) {\n                if (message.error && message.error.data) {\n                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\\n\\n`;\n                }\n                else {\n                    if (message.result) {\n                        data = `Result: ${JSON.stringify(message.result, null, 4)}\\n\\n`;\n                    }\n                    else if (message.error === undefined) {\n                        data = 'No result returned.\\n\\n';\n                    }\n                }\n            }\n            if (responsePromise) {\n                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';\n                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);\n            }\n            else {\n                tracer.log(`Received response ${message.id} without active response promise.`, data);\n            }\n        }\n        else {\n            logLSPMessage('receive-response', message);\n        }\n    }\n    function logLSPMessage(type, message) {\n        if (!tracer || trace === Trace.Off) {\n            return;\n        }\n        const lspMessage = {\n            isLSPMessage: true,\n            type,\n            message,\n            timestamp: Date.now()\n        };\n        tracer.log(lspMessage);\n    }\n    function throwIfClosedOrDisposed() {\n        if (isClosed()) {\n            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');\n        }\n        if (isDisposed()) {\n            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');\n        }\n    }\n    function throwIfListening() {\n        if (isListening()) {\n            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');\n        }\n    }\n    function throwIfNotListening() {\n        if (!isListening()) {\n            throw new Error('Call listen() first.');\n        }\n    }\n    function undefinedToNull(param) {\n        if (param === undefined) {\n            return null;\n        }\n        else {\n            return param;\n        }\n    }\n    function nullToUndefined(param) {\n        if (param === null) {\n            return undefined;\n        }\n        else {\n            return param;\n        }\n    }\n    function isNamedParam(param) {\n        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';\n    }\n    function computeSingleParam(parameterStructures, param) {\n        switch (parameterStructures) {\n            case messages_1.ParameterStructures.auto:\n                if (isNamedParam(param)) {\n                    return nullToUndefined(param);\n                }\n                else {\n                    return [undefinedToNull(param)];\n                }\n                break;\n            case messages_1.ParameterStructures.byName:\n                if (!isNamedParam(param)) {\n                    throw new Error(`Recevied parameters by name but param is not an object literal.`);\n                }\n                return nullToUndefined(param);\n            case messages_1.ParameterStructures.byPosition:\n                return [undefinedToNull(param)];\n            default:\n                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);\n        }\n    }\n    function computeMessageParams(type, params) {\n        let result;\n        const numberOfParams = type.numberOfParams;\n        switch (numberOfParams) {\n            case 0:\n                result = undefined;\n                break;\n            case 1:\n                result = computeSingleParam(type.parameterStructures, params[0]);\n                break;\n            default:\n                result = [];\n                for (let i = 0; i < params.length && i < numberOfParams; i++) {\n                    result.push(undefinedToNull(params[i]));\n                }\n                if (params.length < numberOfParams) {\n                    for (let i = params.length; i < numberOfParams; i++) {\n                        result.push(null);\n                    }\n                }\n                break;\n        }\n        return result;\n    }\n    const connection = {\n        sendNotification: (type, ...args) => {\n            throwIfClosedOrDisposed();\n            let method;\n            let messageParams;\n            if (Is.string(type)) {\n                method = type;\n                const first = args[0];\n                let paramStart = 0;\n                let parameterStructures = messages_1.ParameterStructures.auto;\n                if (messages_1.ParameterStructures.is(first)) {\n                    paramStart = 1;\n                    parameterStructures = first;\n                }\n                let paramEnd = args.length;\n                const numberOfParams = paramEnd - paramStart;\n                switch (numberOfParams) {\n                    case 0:\n                        messageParams = undefined;\n                        break;\n                    case 1:\n                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);\n                        break;\n                    default:\n                        if (parameterStructures === messages_1.ParameterStructures.byName) {\n                            throw new Error(`Recevied ${numberOfParams} parameters for 'by Name' notification parameter structure.`);\n                        }\n                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));\n                        break;\n                }\n            }\n            else {\n                const params = args;\n                method = type.method;\n                messageParams = computeMessageParams(type, params);\n            }\n            const notificationMessage = {\n                jsonrpc: version,\n                method: method,\n                params: messageParams\n            };\n            traceSendingNotification(notificationMessage);\n            messageWriter.write(notificationMessage);\n        },\n        onNotification: (type, handler) => {\n            throwIfClosedOrDisposed();\n            let method;\n            if (Is.func(type)) {\n                starNotificationHandler = type;\n            }\n            else if (handler) {\n                if (Is.string(type)) {\n                    method = type;\n                    notificationHandlers[type] = { type: undefined, handler };\n                }\n                else {\n                    method = type.method;\n                    notificationHandlers[type.method] = { type, handler };\n                }\n            }\n            return {\n                dispose: () => {\n                    if (method !== undefined) {\n                        delete notificationHandlers[method];\n                    }\n                    else {\n                        starNotificationHandler = undefined;\n                    }\n                }\n            };\n        },\n        onProgress: (_type, token, handler) => {\n            if (progressHandlers.has(token)) {\n                throw new Error(`Progress handler for token ${token} already registered`);\n            }\n            progressHandlers.set(token, handler);\n            return {\n                dispose: () => {\n                    progressHandlers.delete(token);\n                }\n            };\n        },\n        sendProgress: (_type, token, value) => {\n            connection.sendNotification(ProgressNotification.type, { token, value });\n        },\n        onUnhandledProgress: unhandledProgressEmitter.event,\n        sendRequest: (type, ...args) => {\n            throwIfClosedOrDisposed();\n            throwIfNotListening();\n            let method;\n            let messageParams;\n            let token = undefined;\n            if (Is.string(type)) {\n                method = type;\n                const first = args[0];\n                const last = args[args.length - 1];\n                let paramStart = 0;\n                let parameterStructures = messages_1.ParameterStructures.auto;\n                if (messages_1.ParameterStructures.is(first)) {\n                    paramStart = 1;\n                    parameterStructures = first;\n                }\n                let paramEnd = args.length;\n                if (cancellation_1.CancellationToken.is(last)) {\n                    paramEnd = paramEnd - 1;\n                    token = last;\n                }\n                const numberOfParams = paramEnd - paramStart;\n                switch (numberOfParams) {\n                    case 0:\n                        messageParams = undefined;\n                        break;\n                    case 1:\n                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);\n                        break;\n                    default:\n                        if (parameterStructures === messages_1.ParameterStructures.byName) {\n                            throw new Error(`Recevied ${numberOfParams} parameters for 'by Name' request parameter structure.`);\n                        }\n                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));\n                        break;\n                }\n            }\n            else {\n                const params = args;\n                method = type.method;\n                messageParams = computeMessageParams(type, params);\n                const numberOfParams = type.numberOfParams;\n                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;\n            }\n            const id = sequenceNumber++;\n            let disposable;\n            if (token) {\n                disposable = token.onCancellationRequested(() => {\n                    cancellationStrategy.sender.sendCancellation(connection, id);\n                });\n            }\n            const result = new Promise((resolve, reject) => {\n                const requestMessage = {\n                    jsonrpc: version,\n                    id: id,\n                    method: method,\n                    params: messageParams\n                };\n                const resolveWithCleanup = (r) => {\n                    resolve(r);\n                    cancellationStrategy.sender.cleanup(id);\n                    disposable === null || disposable === void 0 ? void 0 : disposable.dispose();\n                };\n                const rejectWithCleanup = (r) => {\n                    reject(r);\n                    cancellationStrategy.sender.cleanup(id);\n                    disposable === null || disposable === void 0 ? void 0 : disposable.dispose();\n                };\n                let responsePromise = { method: method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };\n                traceSendingRequest(requestMessage);\n                try {\n                    messageWriter.write(requestMessage);\n                }\n                catch (e) {\n                    // Writing the message failed. So we need to reject the promise.\n                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : 'Unknown reason'));\n                    responsePromise = null;\n                }\n                if (responsePromise) {\n                    responsePromises[String(id)] = responsePromise;\n                }\n            });\n            return result;\n        },\n        onRequest: (type, handler) => {\n            throwIfClosedOrDisposed();\n            let method = null;\n            if (StarRequestHandler.is(type)) {\n                method = undefined;\n                starRequestHandler = type;\n            }\n            else if (Is.string(type)) {\n                method = null;\n                if (handler !== undefined) {\n                    method = type;\n                    requestHandlers[type] = { handler: handler, type: undefined };\n                }\n            }\n            else {\n                if (handler !== undefined) {\n                    method = type.method;\n                    requestHandlers[type.method] = { type, handler };\n                }\n            }\n            return {\n                dispose: () => {\n                    if (method === null) {\n                        return;\n                    }\n                    if (method !== undefined) {\n                        delete requestHandlers[method];\n                    }\n                    else {\n                        starRequestHandler = undefined;\n                    }\n                }\n            };\n        },\n        trace: (_value, _tracer, sendNotificationOrTraceOptions) => {\n            let _sendNotification = false;\n            let _traceFormat = TraceFormat.Text;\n            if (sendNotificationOrTraceOptions !== undefined) {\n                if (Is.boolean(sendNotificationOrTraceOptions)) {\n                    _sendNotification = sendNotificationOrTraceOptions;\n                }\n                else {\n                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;\n                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;\n                }\n            }\n            trace = _value;\n            traceFormat = _traceFormat;\n            if (trace === Trace.Off) {\n                tracer = undefined;\n            }\n            else {\n                tracer = _tracer;\n            }\n            if (_sendNotification && !isClosed() && !isDisposed()) {\n                connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });\n            }\n        },\n        onError: errorEmitter.event,\n        onClose: closeEmitter.event,\n        onUnhandledNotification: unhandledNotificationEmitter.event,\n        onDispose: disposeEmitter.event,\n        end: () => {\n            messageWriter.end();\n        },\n        dispose: () => {\n            if (isDisposed()) {\n                return;\n            }\n            state = ConnectionState.Disposed;\n            disposeEmitter.fire(undefined);\n            const error = new Error('Connection got disposed.');\n            Object.keys(responsePromises).forEach((key) => {\n                responsePromises[key].reject(error);\n            });\n            responsePromises = Object.create(null);\n            requestTokens = Object.create(null);\n            messageQueue = new linkedMap_1.LinkedMap();\n            // Test for backwards compatibility\n            if (Is.func(messageWriter.dispose)) {\n                messageWriter.dispose();\n            }\n            if (Is.func(messageReader.dispose)) {\n                messageReader.dispose();\n            }\n        },\n        listen: () => {\n            throwIfClosedOrDisposed();\n            throwIfListening();\n            state = ConnectionState.Listening;\n            messageReader.listen(callback);\n        },\n        inspect: () => {\n            // eslint-disable-next-line no-console\n            ral_1.default().console.log('inspect');\n        }\n    };\n    connection.onNotification(LogTraceNotification.type, (params) => {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        tracer.log(params.message, trace === Trace.Verbose ? params.verbose : undefined);\n    });\n    connection.onNotification(ProgressNotification.type, (params) => {\n        const handler = progressHandlers.get(params.token);\n        if (handler) {\n            handler(params.value);\n        }\n        else {\n            unhandledProgressEmitter.fire(params);\n        }\n    });\n    return connection;\n}\nexports.createMessageConnection = createMessageConnection;\n//# sourceMappingURL=connection.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script"}