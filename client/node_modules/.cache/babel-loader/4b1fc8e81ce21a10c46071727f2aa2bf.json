{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tagDirective = void 0;\n\nconst directives_1 = require(\"../../../directives\");\n\nconst graphql_1 = require(\"graphql\");\n\nconst KnownArgumentNamesRule_1 = require(\"graphql/validation/rules/KnownArgumentNamesRule\");\n\nconst ProvidedRequiredArgumentsRule_1 = require(\"graphql/validation/rules/ProvidedRequiredArgumentsRule\");\n\nconst validate_1 = require(\"graphql/validation/validate\");\n\nconst utils_1 = require(\"../../utils\");\n\nconst errorsMessagesToFilter = directives_1.federationDirectives.map(directive => `Unknown directive \"@${directive.name}\".`);\n\nconst tagDirective = ({\n  name: serviceName,\n  typeDefs\n}) => {\n  const directiveRules = [KnownArgumentNamesRule_1.KnownArgumentNamesOnDirectivesRule, graphql_1.KnownDirectivesRule, ProvidedRequiredArgumentsRule_1.ProvidedRequiredArgumentsOnDirectivesRule];\n  const errors = validate_1.validateSDL(typeDefs, undefined, directiveRules);\n  let tagDirectiveDefinition;\n  graphql_1.visit(typeDefs, {\n    DirectiveDefinition(node) {\n      if (node.name.value === 'tag') {\n        tagDirectiveDefinition = node;\n        return graphql_1.BREAK;\n      }\n    }\n\n  });\n\n  if (tagDirectiveDefinition) {\n    const printedTagDefinition = 'directive @tag(name: String!) repeatable on FIELD_DEFINITION';\n\n    if (graphql_1.print(utils_1.stripDescriptions(tagDirectiveDefinition)) !== printedTagDefinition) {\n      errors.push(utils_1.errorWithCode('TAG_DIRECTIVE_DEFINITION_INVALID', utils_1.logDirective('tag') + `Found @tag definition in service ${serviceName}, but the @tag directive definition was invalid. Please ensure the directive definition in your schema's type definitions matches the following:\\n\\t${printedTagDefinition}`, tagDirectiveDefinition));\n    }\n  }\n\n  return errors.filter(({\n    message\n  }) => !errorsMessagesToFilter.some(keyWord => message === keyWord));\n};\n\nexports.tagDirective = tagDirective;","map":{"version":3,"sources":["../../../../src/composition/validate/preNormalization/tagDirective.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,YAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;;AACA,MAAA,SAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AAOA,MAAA,wBAAA,GAAA,OAAA,CAAA,iDAAA,CAAA;;AACA,MAAA,+BAAA,GAAA,OAAA,CAAA,wDAAA,CAAA;;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,6BAAA,CAAA;;AAEA,MAAA,OAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AAKA,MAAM,sBAAsB,GAAG,YAAA,CAAA,oBAAA,CAAqB,GAArB,CAC5B,SAAD,IAAe,uBAAuB,SAAS,CAAC,IAAI,IADvB,CAA/B;;AAOO,MAAM,YAAY,GAAG,CAAC;EAC3B,IAAI,EAAE,WADqB;EAE3B;AAF2B,CAAD,KAGJ;EAGtB,MAAM,cAAc,GAAG,CACrB,wBAAA,CAAA,kCADqB,EAErB,SAAA,CAAA,mBAFqB,EAGrB,+BAAA,CAAA,yCAHqB,CAAvB;EAMA,MAAM,MAAM,GAAG,UAAA,CAAA,WAAA,CAAY,QAAZ,EAAsB,SAAtB,EAAiC,cAAjC,CAAf;EAEA,IAAI,sBAAJ;EACA,SAAA,CAAA,KAAA,CAAM,QAAN,EAAgB;IACd,mBAAmB,CAAC,IAAD,EAAK;MACtB,IAAI,IAAI,CAAC,IAAL,CAAU,KAAV,KAAoB,KAAxB,EAA+B;QAC7B,sBAAsB,GAAG,IAAzB;QACA,OAAO,SAAA,CAAA,KAAP;MACD;IACF;;EANa,CAAhB;;EAUA,IAAI,sBAAJ,EAA4B;IAC1B,MAAM,oBAAoB,GACxB,8DADF;;IAGA,IACE,SAAA,CAAA,KAAA,CAAM,OAAA,CAAA,iBAAA,CAAkB,sBAAlB,CAAN,MAAqD,oBADvD,EAEE;MACA,MAAM,CAAC,IAAP,CACE,OAAA,CAAA,aAAA,CACE,kCADF,EAEE,OAAA,CAAA,YAAA,CAAa,KAAb,IACE,oCAAoC,WAAW,uJAAuJ,oBAAoB,EAH9N,EAIE,sBAJF,CADF;IAQD;EACF;;EAED,OAAO,MAAM,CAAC,MAAP,CACL,CAAC;IAAE;EAAF,CAAD,KACE,CAAC,sBAAsB,CAAC,IAAvB,CAA6B,OAAD,IAAa,OAAO,KAAK,OAArD,CAFE,CAAP;AAID,CA/CM;;AAAM,OAAA,CAAA,YAAA,GAAY,YAAZ","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.tagDirective = void 0;\nconst directives_1 = require(\"../../../directives\");\nconst graphql_1 = require(\"graphql\");\nconst KnownArgumentNamesRule_1 = require(\"graphql/validation/rules/KnownArgumentNamesRule\");\nconst ProvidedRequiredArgumentsRule_1 = require(\"graphql/validation/rules/ProvidedRequiredArgumentsRule\");\nconst validate_1 = require(\"graphql/validation/validate\");\nconst utils_1 = require(\"../../utils\");\nconst errorsMessagesToFilter = directives_1.federationDirectives.map((directive) => `Unknown directive \"@${directive.name}\".`);\nconst tagDirective = ({ name: serviceName, typeDefs, }) => {\n    const directiveRules = [\n        KnownArgumentNamesRule_1.KnownArgumentNamesOnDirectivesRule,\n        graphql_1.KnownDirectivesRule,\n        ProvidedRequiredArgumentsRule_1.ProvidedRequiredArgumentsOnDirectivesRule,\n    ];\n    const errors = validate_1.validateSDL(typeDefs, undefined, directiveRules);\n    let tagDirectiveDefinition;\n    graphql_1.visit(typeDefs, {\n        DirectiveDefinition(node) {\n            if (node.name.value === 'tag') {\n                tagDirectiveDefinition = node;\n                return graphql_1.BREAK;\n            }\n        },\n    });\n    if (tagDirectiveDefinition) {\n        const printedTagDefinition = 'directive @tag(name: String!) repeatable on FIELD_DEFINITION';\n        if (graphql_1.print(utils_1.stripDescriptions(tagDirectiveDefinition)) !== printedTagDefinition) {\n            errors.push(utils_1.errorWithCode('TAG_DIRECTIVE_DEFINITION_INVALID', utils_1.logDirective('tag') +\n                `Found @tag definition in service ${serviceName}, but the @tag directive definition was invalid. Please ensure the directive definition in your schema's type definitions matches the following:\\n\\t${printedTagDefinition}`, tagDirectiveDefinition));\n        }\n    }\n    return errors.filter(({ message }) => !errorsMessagesToFilter.some((keyWord) => message === keyWord));\n};\nexports.tagDirective = tagDirective;\n//# sourceMappingURL=tagDirective.js.map"]},"metadata":{},"sourceType":"script"}