{"ast":null,"code":"// code is originally from https://github.com/AnAppAMonth/linewrap\n// Presets\nvar presetMap = {\n  'html': {\n    skipScheme: 'html',\n    lineBreakScheme: 'html',\n    whitespace: 'collapse'\n  }\n}; // lineBreak Schemes\n\nvar brPat = /<\\s*br(?:[\\s/]*|\\s[^>]*)>/gi;\nvar lineBreakSchemeMap = {\n  'unix': [/\\n/g, '\\n'],\n  'dos': [/\\r\\n/g, '\\r\\n'],\n  'mac': [/\\r/g, '\\r'],\n  'html': [brPat, '<br>'],\n  'xhtml': [brPat, '<br/>']\n}; // skip Schemes\n\nvar skipSchemeMap = {\n  'ansi-color': /\\x1B\\[[^m]*m/g,\n  'html': /<[^>]*>/g,\n  'bbcode': /\\[[^]]*\\]/g\n};\nvar modeMap = {\n  'soft': 1,\n  'hard': 1\n};\nvar wsMap = {\n  'collapse': 1,\n  'default': 1,\n  'line': 1,\n  'all': 1\n};\nvar rlbMap = {\n  'all': 1,\n  'multi': 1,\n  'none': 1\n};\nvar rlbSMPat = /([sm])(\\d+)/;\nvar escapePat = /[-/\\\\^$*+?.()|[\\]{}]/g;\n\nfunction escapeRegExp(s) {\n  return s.replace(escapePat, '\\\\$&');\n}\n\nvar linewrap = module.exports = function (start, stop, params) {\n  if (typeof start === 'object') {\n    params = start;\n    start = params.start;\n    stop = params.stop;\n  }\n\n  if (typeof stop === 'object') {\n    params = stop;\n    start = start || params.start;\n    stop = undefined;\n  }\n\n  if (!stop) {\n    stop = start;\n    start = 0;\n  }\n\n  if (!params) {\n    params = {};\n  } // Supported options and default values.\n\n\n  var preset,\n      mode = 'soft',\n      whitespace = 'default',\n      tabWidth = 4,\n      skip,\n      skipScheme,\n      lineBreak,\n      lineBreakScheme,\n      respectLineBreaks = 'all',\n      respectNum,\n      preservedLineIndent,\n      wrapLineIndent,\n      wrapLineIndentBase;\n  var skipPat;\n  var lineBreakPat, lineBreakStr;\n  var multiLineBreakPat;\n  var preservedLinePrefix = '';\n  var wrapLineIndentPat,\n      wrapLineInitPrefix = '';\n  var tabRepl;\n  var item, flags;\n  var i; // First process presets, because these settings can be overwritten later.\n\n  preset = params.preset;\n\n  if (preset) {\n    if (!(preset instanceof Array)) {\n      preset = [preset];\n    }\n\n    for (i = 0; i < preset.length; i++) {\n      item = presetMap[preset[i]];\n\n      if (item) {\n        if (item.mode) {\n          mode = item.mode;\n        }\n\n        if (item.whitespace) {\n          whitespace = item.whitespace;\n        }\n\n        if (item.tabWidth !== undefined) {\n          tabWidth = item.tabWidth;\n        }\n\n        if (item.skip) {\n          skip = item.skip;\n        }\n\n        if (item.skipScheme) {\n          skipScheme = item.skipScheme;\n        }\n\n        if (item.lineBreak) {\n          lineBreak = item.lineBreak;\n        }\n\n        if (item.lineBreakScheme) {\n          lineBreakScheme = item.lineBreakScheme;\n        }\n\n        if (item.respectLineBreaks) {\n          respectLineBreaks = item.respectLineBreaks;\n        }\n\n        if (item.preservedLineIndent !== undefined) {\n          preservedLineIndent = item.preservedLineIndent;\n        }\n\n        if (item.wrapLineIndent !== undefined) {\n          wrapLineIndent = item.wrapLineIndent;\n        }\n\n        if (item.wrapLineIndentBase) {\n          wrapLineIndentBase = item.wrapLineIndentBase;\n        }\n      } else {\n        throw new TypeError('preset must be one of \"' + Object.keys(presetMap).join('\", \"') + '\"');\n      }\n    }\n  }\n\n  if (params.mode) {\n    if (modeMap[params.mode]) {\n      mode = params.mode;\n    } else {\n      throw new TypeError('mode must be one of \"' + Object.keys(modeMap).join('\", \"') + '\"');\n    }\n  } // Available options: 'collapse', 'default', 'line', and 'all'\n\n\n  if (params.whitespace) {\n    if (wsMap[params.whitespace]) {\n      whitespace = params.whitespace;\n    } else {\n      throw new TypeError('whitespace must be one of \"' + Object.keys(wsMap).join('\", \"') + '\"');\n    }\n  }\n\n  if (params.tabWidth !== undefined) {\n    if (parseInt(params.tabWidth, 10) >= 0) {\n      tabWidth = parseInt(params.tabWidth, 10);\n    } else {\n      throw new TypeError('tabWidth must be a non-negative integer');\n    }\n  }\n\n  tabRepl = new Array(tabWidth + 1).join(' '); // Available options: 'all', 'multi', 'm\\d+', 's\\d+', 'none'\n\n  if (params.respectLineBreaks) {\n    if (rlbMap[params.respectLineBreaks] || rlbSMPat.test(params.respectLineBreaks)) {\n      respectLineBreaks = params.respectLineBreaks;\n    } else {\n      throw new TypeError('respectLineBreaks must be one of \"' + Object.keys(rlbMap).join('\", \"') + '\", \"m<num>\", \"s<num>\"');\n    }\n  } // After these conversions, now we have 4 options in `respectLineBreaks`:\n  // 'all', 'none', 'm' and 's'.\n  // `respectNum` is applicable iff `respectLineBreaks` is either 'm' or 's'.\n\n\n  if (respectLineBreaks === 'multi') {\n    respectLineBreaks = 'm';\n    respectNum = 2;\n  } else if (!rlbMap[respectLineBreaks]) {\n    var match = rlbSMPat.exec(respectLineBreaks);\n    respectLineBreaks = match[1];\n    respectNum = parseInt(match[2], 10);\n  }\n\n  if (params.preservedLineIndent !== undefined) {\n    if (parseInt(params.preservedLineIndent, 10) >= 0) {\n      preservedLineIndent = parseInt(params.preservedLineIndent, 10);\n    } else {\n      throw new TypeError('preservedLineIndent must be a non-negative integer');\n    }\n  }\n\n  if (preservedLineIndent > 0) {\n    preservedLinePrefix = new Array(preservedLineIndent + 1).join(' ');\n  }\n\n  if (params.wrapLineIndent !== undefined) {\n    if (!isNaN(parseInt(params.wrapLineIndent, 10))) {\n      wrapLineIndent = parseInt(params.wrapLineIndent, 10);\n    } else {\n      throw new TypeError('wrapLineIndent must be an integer');\n    }\n  }\n\n  if (params.wrapLineIndentBase) {\n    wrapLineIndentBase = params.wrapLineIndentBase;\n  }\n\n  if (wrapLineIndentBase) {\n    if (wrapLineIndent === undefined) {\n      throw new TypeError('wrapLineIndent must be specified when wrapLineIndentBase is specified');\n    }\n\n    if (wrapLineIndentBase instanceof RegExp) {\n      wrapLineIndentPat = wrapLineIndentBase;\n    } else if (typeof wrapLineIndentBase === 'string') {\n      wrapLineIndentPat = new RegExp(escapeRegExp(wrapLineIndentBase));\n    } else {\n      throw new TypeError('wrapLineIndentBase must be either a RegExp object or a string');\n    }\n  } else if (wrapLineIndent > 0) {\n    wrapLineInitPrefix = new Array(wrapLineIndent + 1).join(' ');\n  } else if (wrapLineIndent < 0) {\n    throw new TypeError('wrapLineIndent must be non-negative when a base is not specified');\n  } // NOTE: For the two RegExps `skipPat` and `lineBreakPat` that can be specified\n  //       by the user:\n  //       1. We require them to be \"global\", so we have to convert them to global\n  //          if the user specifies a non-global regex.\n  //       2. We cannot call `split()` on them, because they may or may not contain\n  //          capturing parentheses which affect the output of `split()`.\n  // Precedence: Regex = Str > Scheme\n\n\n  if (params.skipScheme) {\n    if (skipSchemeMap[params.skipScheme]) {\n      skipScheme = params.skipScheme;\n    } else {\n      throw new TypeError('skipScheme must be one of \"' + Object.keys(skipSchemeMap).join('\", \"') + '\"');\n    }\n  }\n\n  if (params.skip) {\n    skip = params.skip;\n  }\n\n  if (skip) {\n    if (skip instanceof RegExp) {\n      skipPat = skip;\n\n      if (!skipPat.global) {\n        flags = 'g';\n\n        if (skipPat.ignoreCase) {\n          flags += 'i';\n        }\n\n        if (skipPat.multiline) {\n          flags += 'm';\n        }\n\n        skipPat = new RegExp(skipPat.source, flags);\n      }\n    } else if (typeof skip === 'string') {\n      skipPat = new RegExp(escapeRegExp(skip), 'g');\n    } else {\n      throw new TypeError('skip must be either a RegExp object or a string');\n    }\n  }\n\n  if (!skipPat && skipScheme) {\n    skipPat = skipSchemeMap[skipScheme];\n  } // Precedence:\n  // - for lineBreakPat: Regex > Scheme > Str\n  // - for lineBreakStr: Str > Scheme > Regex\n\n\n  if (params.lineBreakScheme) {\n    if (lineBreakSchemeMap[params.lineBreakScheme]) {\n      lineBreakScheme = params.lineBreakScheme;\n    } else {\n      throw new TypeError('lineBreakScheme must be one of \"' + Object.keys(lineBreakSchemeMap).join('\", \"') + '\"');\n    }\n  }\n\n  if (params.lineBreak) {\n    lineBreak = params.lineBreak;\n  }\n\n  if (lineBreakScheme) {\n    // Supported schemes: 'unix', 'dos', 'mac', 'html', 'xhtml'\n    item = lineBreakSchemeMap[lineBreakScheme];\n\n    if (item) {\n      lineBreakPat = item[0];\n      lineBreakStr = item[1];\n    }\n  }\n\n  if (lineBreak) {\n    if (lineBreak instanceof Array) {\n      if (lineBreak.length === 1) {\n        lineBreak = lineBreak[0];\n      } else if (lineBreak.length >= 2) {\n        if (lineBreak[0] instanceof RegExp) {\n          lineBreakPat = lineBreak[0];\n\n          if (typeof lineBreak[1] === 'string') {\n            lineBreakStr = lineBreak[1];\n          }\n        } else if (lineBreak[1] instanceof RegExp) {\n          lineBreakPat = lineBreak[1];\n\n          if (typeof lineBreak[0] === 'string') {\n            lineBreakStr = lineBreak[0];\n          }\n        } else if (typeof lineBreak[0] === 'string' && typeof lineBreak[1] === 'string') {\n          lineBreakPat = new RegExp(escapeRegExp(lineBreak[0]), 'g');\n          lineBreakStr = lineBreak[1];\n        } else {\n          lineBreak = lineBreak[0];\n        }\n      }\n    }\n\n    if (typeof lineBreak === 'string') {\n      lineBreakStr = lineBreak;\n\n      if (!lineBreakPat) {\n        lineBreakPat = new RegExp(escapeRegExp(lineBreak), 'g');\n      }\n    } else if (lineBreak instanceof RegExp) {\n      lineBreakPat = lineBreak;\n    } else if (!(lineBreak instanceof Array)) {\n      throw new TypeError('lineBreak must be a RegExp object, a string, or an array consisted of a RegExp object and a string');\n    }\n  } // Only assign defaults when `lineBreakPat` is not assigned.\n  // So if `params.lineBreak` is a RegExp, we don't have a value in `lineBreakStr`\n  // yet. We will try to get the value from the input string, and if failed, we\n  // will throw an exception.\n\n\n  if (!lineBreakPat) {\n    lineBreakPat = /\\n/g;\n    lineBreakStr = '\\n';\n  } // Create `multiLineBreakPat` based on `lineBreakPat`, that matches strings\n  // consisted of one or more line breaks and zero or more whitespaces.\n  // Also convert `lineBreakPat` to global if not already so.\n\n\n  flags = 'g';\n\n  if (lineBreakPat.ignoreCase) {\n    flags += 'i';\n  }\n\n  if (lineBreakPat.multiline) {\n    flags += 'm';\n  }\n\n  multiLineBreakPat = new RegExp('\\\\s*(?:' + lineBreakPat.source + ')(?:' + lineBreakPat.source + '|\\\\s)*', flags);\n\n  if (!lineBreakPat.global) {\n    lineBreakPat = new RegExp(lineBreakPat.source, flags);\n  } // Initialize other useful variables.\n\n\n  var re = mode === 'hard' ? /\\b/ : /(\\S+\\s+)/;\n  var prefix = new Array(start + 1).join(' ');\n  var wsStrip = whitespace === 'default' || whitespace === 'collapse',\n      wsCollapse = whitespace === 'collapse',\n      wsLine = whitespace === 'line',\n      wsAll = whitespace === 'all';\n  var tabPat = /\\t/g,\n      collapsePat = /  +/g,\n      pPat = /^\\s+/,\n      tPat = /\\s+$/,\n      nonWsPat = /\\S/,\n      wsPat = /\\s/;\n  var wrapLen = stop - start;\n  return function (text) {\n    text = text.toString().replace(tabPat, tabRepl);\n    var match;\n\n    if (!lineBreakStr) {\n      // Try to get lineBreakStr from `text`\n      lineBreakPat.lastIndex = 0;\n      match = lineBreakPat.exec(text);\n\n      if (match) {\n        lineBreakStr = match[0];\n      } else {\n        throw new TypeError('Line break string for the output not specified');\n      }\n    } // text -> blocks; each bloc -> segments; each segment -> chunks\n\n\n    var blocks,\n        base = 0;\n    var mo, arr, b, res; // Split `text` by line breaks.\n\n    blocks = [];\n    multiLineBreakPat.lastIndex = 0;\n    match = multiLineBreakPat.exec(text);\n\n    while (match) {\n      blocks.push(text.substring(base, match.index));\n\n      if (respectLineBreaks !== 'none') {\n        arr = [];\n        b = 0;\n        lineBreakPat.lastIndex = 0;\n        mo = lineBreakPat.exec(match[0]);\n\n        while (mo) {\n          arr.push(match[0].substring(b, mo.index));\n          b = mo.index + mo[0].length;\n          mo = lineBreakPat.exec(match[0]);\n        }\n\n        arr.push(match[0].substring(b));\n        blocks.push({\n          type: 'break',\n          breaks: arr\n        });\n      } else {\n        // Strip line breaks and insert spaces when necessary.\n        if (wsCollapse) {\n          res = ' ';\n        } else {\n          res = match[0].replace(lineBreakPat, '');\n        }\n\n        blocks.push({\n          type: 'break',\n          remaining: res\n        });\n      }\n\n      base = match.index + match[0].length;\n      match = multiLineBreakPat.exec(text);\n    }\n\n    blocks.push(text.substring(base));\n    var i, j, k;\n    var segments;\n\n    if (skipPat) {\n      segments = [];\n\n      for (i = 0; i < blocks.length; i++) {\n        var bloc = blocks[i];\n\n        if (typeof bloc !== 'string') {\n          // This is an object.\n          segments.push(bloc);\n        } else {\n          base = 0;\n          skipPat.lastIndex = 0;\n          match = skipPat.exec(bloc);\n\n          while (match) {\n            segments.push(bloc.substring(base, match.index));\n            segments.push({\n              type: 'skip',\n              value: match[0]\n            });\n            base = match.index + match[0].length;\n            match = skipPat.exec(bloc);\n          }\n\n          segments.push(bloc.substring(base));\n        }\n      }\n    } else {\n      segments = blocks;\n    }\n\n    var chunks = [];\n\n    for (i = 0; i < segments.length; i++) {\n      var segment = segments[i];\n\n      if (typeof segment !== 'string') {\n        // This is an object.\n        chunks.push(segment);\n      } else {\n        if (wsCollapse) {\n          segment = segment.replace(collapsePat, ' ');\n        }\n\n        var parts = segment.split(re),\n            acc = [];\n\n        for (j = 0; j < parts.length; j++) {\n          var x = parts[j];\n\n          if (mode === 'hard') {\n            for (k = 0; k < x.length; k += wrapLen) {\n              acc.push(x.slice(k, k + wrapLen));\n            }\n          } else {\n            acc.push(x);\n          }\n        }\n\n        chunks = chunks.concat(acc);\n      }\n    }\n\n    var curLine = 0,\n        curLineLength = start + preservedLinePrefix.length,\n        lines = [prefix + preservedLinePrefix],\n        // Holds the \"real length\" (excluding trailing whitespaces) of the\n    // current line if it exceeds `stop`, otherwise 0.\n    // ONLY USED when `wsAll` is true, in `finishOffCurLine()`.\n    bulge = 0,\n        // `cleanLine` is true iff we are at the beginning of an output line. By\n    // \"beginning\" we mean it doesn't contain any non-whitespace char yet.\n    // But its `curLineLength` can be greater than `start`, or even possibly\n    // be greater than `stop`, if `wsStrip` is false.\n    //\n    // Note that a \"clean\" line can still contain skip strings, in addition\n    // to whitespaces.\n    //\n    // This variable is used to allow us strip preceding whitespaces when\n    // `wsStrip` is true, or `wsLine` is true and `preservedLine` is false.\n    cleanLine = true,\n        // `preservedLine` is true iff we are in a preserved input line.\n    //\n    // It's used when `wsLine` is true to (combined with `cleanLine`) decide\n    // whether a whitespace is at the beginning of a preserved input line and\n    // should not be stripped.\n    preservedLine = true,\n        // The current indent prefix for wrapped lines.\n    wrapLinePrefix = wrapLineInitPrefix,\n        remnant; // Always returns '' if `beforeHardBreak` is true.\n    //\n    // Assumption: Each call of this function is always followed by a `lines.push()` call.\n    //\n    // This function can change the status of `cleanLine`, but we don't modify the value of\n    // `cleanLine` in this function. It's fine because `cleanLine` will be set to the correct\n    // value after the `lines.push()` call following this function call. We also don't update\n    // `curLineLength` when pushing a new line and it's safe for the same reason.\n\n    function finishOffCurLine(beforeHardBreak) {\n      var str = lines[curLine],\n          idx,\n          ln,\n          rBase;\n\n      if (!wsAll) {\n        // Strip all trailing whitespaces past `start`.\n        idx = str.length - 1;\n\n        while (idx >= start && str[idx] === ' ') {\n          idx--;\n        }\n\n        while (idx >= start && wsPat.test(str[idx])) {\n          idx--;\n        }\n\n        idx++;\n\n        if (idx !== str.length) {\n          lines[curLine] = str.substring(0, idx);\n        }\n\n        if (preservedLine && cleanLine && wsLine && curLineLength > stop) {\n          // Add the remnants to the next line, just like when `wsAll` is true.\n          rBase = str.length - (curLineLength - stop);\n\n          if (rBase < idx) {\n            // We didn't reach `stop` when stripping due to a bulge.\n            rBase = idx;\n          }\n        }\n      } else {\n        // Strip trailing whitespaces exceeding stop.\n        if (curLineLength > stop) {\n          bulge = bulge || stop;\n          rBase = str.length - (curLineLength - bulge);\n          lines[curLine] = str.substring(0, rBase);\n        }\n\n        bulge = 0;\n      } // Bug: the current implementation of `wrapLineIndent` is buggy: we are not\n      // taking the extra space occupied by the additional indentation into account\n      // when wrapping the line. For example, in \"hard\" mode, we should hard-wrap\n      // long words at `wrapLen - wrapLinePrefix.length` instead of `wrapLen`\n      // and remnants should also be wrapped at `wrapLen - wrapLinePrefix.length`.\n\n\n      if (preservedLine) {\n        // This is a preserved line, and the next output line isn't a\n        // preserved line.\n        preservedLine = false;\n\n        if (wrapLineIndentPat) {\n          idx = lines[curLine].substring(start).search(wrapLineIndentPat);\n\n          if (idx >= 0 && idx + wrapLineIndent > 0) {\n            wrapLinePrefix = new Array(idx + wrapLineIndent + 1).join(' ');\n          } else {\n            wrapLinePrefix = '';\n          }\n        }\n      } // Some remnants are left to the next line.\n\n\n      if (rBase) {\n        while (rBase + wrapLen < str.length) {\n          if (wsAll) {\n            ln = str.substring(rBase, rBase + wrapLen);\n            lines.push(prefix + wrapLinePrefix + ln);\n          } else {\n            lines.push(prefix + wrapLinePrefix);\n          }\n\n          rBase += wrapLen;\n          curLine++;\n        }\n\n        if (beforeHardBreak) {\n          if (wsAll) {\n            ln = str.substring(rBase);\n            lines.push(prefix + wrapLinePrefix + ln);\n          } else {\n            lines.push(prefix + wrapLinePrefix);\n          }\n\n          curLine++;\n        } else {\n          ln = str.substring(rBase);\n          return wrapLinePrefix + ln;\n        }\n      }\n\n      return '';\n    }\n\n    for (i = 0; i < chunks.length; i++) {\n      var chunk = chunks[i];\n\n      if (chunk === '') {\n        continue;\n      }\n\n      if (typeof chunk !== 'string') {\n        if (chunk.type === 'break') {\n          // This is one or more line breaks.\n          // Each entry in `breaks` is just zero or more whitespaces.\n          if (respectLineBreaks !== 'none') {\n            // Note that if `whitespace` is \"collapse\", we still need\n            // to collapse whitespaces in entries of `breaks`.\n            var breaks = chunk.breaks;\n            var num = breaks.length - 1;\n\n            if (respectLineBreaks === 's') {\n              // This is the most complex scenario. We have to check\n              // the line breaks one by one.\n              for (j = 0; j < num; j++) {\n                if (breaks[j + 1].length < respectNum) {\n                  // This line break should be stripped.\n                  if (wsCollapse) {\n                    breaks[j + 1] = ' ';\n                  } else {\n                    breaks[j + 1] = breaks[j] + breaks[j + 1];\n                  }\n                } else {\n                  // This line break should be preserved.\n                  // First finish off the current line.\n                  if (wsAll) {\n                    lines[curLine] += breaks[j];\n                    curLineLength += breaks[j].length;\n                  }\n\n                  finishOffCurLine(true);\n                  lines.push(prefix + preservedLinePrefix);\n                  curLine++;\n                  curLineLength = start + preservedLinePrefix.length;\n                  preservedLine = cleanLine = true;\n                }\n              } // We are adding to either the existing line (if no line break\n              // is qualified for preservance) or a \"new\" line.\n\n\n              if (!cleanLine || wsAll || wsLine && preservedLine) {\n                if (wsCollapse || !cleanLine && breaks[num] === '') {\n                  breaks[num] = ' ';\n                }\n\n                lines[curLine] += breaks[num];\n                curLineLength += breaks[num].length;\n              }\n            } else if (respectLineBreaks === 'm' && num < respectNum) {\n              // These line breaks should be stripped.\n              if (!cleanLine || wsAll || wsLine && preservedLine) {\n                if (wsCollapse) {\n                  chunk = ' ';\n                } else {\n                  chunk = breaks.join('');\n\n                  if (!cleanLine && chunk === '') {\n                    chunk = ' ';\n                  }\n                }\n\n                lines[curLine] += chunk;\n                curLineLength += chunk.length;\n              }\n            } else {\n              // 'all' || ('m' && num >= respectNum)\n              // These line breaks should be preserved.\n              if (wsStrip) {\n                // Finish off the current line.\n                finishOffCurLine(true);\n\n                for (j = 0; j < num; j++) {\n                  lines.push(prefix + preservedLinePrefix);\n                  curLine++;\n                }\n\n                curLineLength = start + preservedLinePrefix.length;\n                preservedLine = cleanLine = true;\n              } else {\n                if (wsAll || preservedLine && cleanLine) {\n                  lines[curLine] += breaks[0];\n                  curLineLength += breaks[0].length;\n                }\n\n                for (j = 0; j < num; j++) {\n                  // Finish off the current line.\n                  finishOffCurLine(true);\n                  lines.push(prefix + preservedLinePrefix + breaks[j + 1]);\n                  curLine++;\n                  curLineLength = start + preservedLinePrefix.length + breaks[j + 1].length;\n                  preservedLine = cleanLine = true;\n                }\n              }\n            }\n          } else {\n            // These line breaks should be stripped.\n            if (!cleanLine || wsAll || wsLine && preservedLine) {\n              chunk = chunk.remaining; // Bug: If `wsAll` is true, `cleanLine` is false, and `chunk`\n              // is '', we insert a space to replace the line break. This\n              // space will be preserved even if we are at the end of an\n              // output line, which is wrong behavior. However, I'm not\n              // sure it's worth it to fix this edge case.\n\n              if (wsCollapse || !cleanLine && chunk === '') {\n                chunk = ' ';\n              }\n\n              lines[curLine] += chunk;\n              curLineLength += chunk.length;\n            }\n          }\n        } else if (chunk.type === 'skip') {\n          // This is a skip string.\n          // Assumption: skip strings don't end with whitespaces.\n          if (curLineLength > stop) {\n            remnant = finishOffCurLine(false);\n            lines.push(prefix + wrapLinePrefix);\n            curLine++;\n            curLineLength = start + wrapLinePrefix.length;\n\n            if (remnant) {\n              lines[curLine] += remnant;\n              curLineLength += remnant.length;\n            }\n\n            cleanLine = true;\n          }\n\n          lines[curLine] += chunk.value;\n        }\n\n        continue;\n      }\n\n      var chunk2;\n\n      while (1) {\n        chunk2 = undefined;\n\n        if (curLineLength + chunk.length > stop && curLineLength + (chunk2 = chunk.replace(tPat, '')).length > stop && chunk2 !== '' && curLineLength > start) {\n          // This line is full, add `chunk` to the next line\n          remnant = finishOffCurLine(false);\n          lines.push(prefix + wrapLinePrefix);\n          curLine++;\n          curLineLength = start + wrapLinePrefix.length;\n\n          if (remnant) {\n            lines[curLine] += remnant;\n            curLineLength += remnant.length;\n            cleanLine = true;\n            continue;\n          }\n\n          if (wsStrip || wsLine && !(preservedLine && cleanLine)) {\n            chunk = chunk.replace(pPat, '');\n          }\n\n          cleanLine = false;\n        } else {\n          // Add `chunk` to this line\n          if (cleanLine) {\n            if (wsStrip || wsLine && !(preservedLine && cleanLine)) {\n              chunk = chunk.replace(pPat, '');\n\n              if (chunk !== '') {\n                cleanLine = false;\n              }\n            } else {\n              if (nonWsPat.test(chunk)) {\n                cleanLine = false;\n              }\n            }\n          }\n        }\n\n        break;\n      }\n\n      if (wsAll && chunk2 && curLineLength + chunk2.length > stop) {\n        bulge = curLineLength + chunk2.length;\n      }\n\n      lines[curLine] += chunk;\n      curLineLength += chunk.length;\n    } // Finally, finish off the last line.\n\n\n    finishOffCurLine(true);\n    return lines.join(lineBreakStr);\n  };\n};\n\nlinewrap.soft = linewrap;\n\nlinewrap.hard = function ()\n/*start, stop, params*/\n{\n  var args = [].slice.call(arguments);\n  var last = args.length - 1;\n\n  if (typeof args[last] === 'object') {\n    args[last].mode = 'hard';\n  } else {\n    args.push({\n      mode: 'hard'\n    });\n  }\n\n  return linewrap.apply(null, args);\n};\n\nlinewrap.wrap = function (text\n/*, start, stop, params*/\n) {\n  var args = [].slice.call(arguments);\n  args.shift();\n  return linewrap.apply(null, args)(text);\n};","map":{"version":3,"names":["presetMap","skipScheme","lineBreakScheme","whitespace","brPat","lineBreakSchemeMap","skipSchemeMap","modeMap","wsMap","rlbMap","rlbSMPat","escapePat","escapeRegExp","s","replace","linewrap","module","exports","start","stop","params","undefined","preset","mode","tabWidth","skip","lineBreak","respectLineBreaks","respectNum","preservedLineIndent","wrapLineIndent","wrapLineIndentBase","skipPat","lineBreakPat","lineBreakStr","multiLineBreakPat","preservedLinePrefix","wrapLineIndentPat","wrapLineInitPrefix","tabRepl","item","flags","i","Array","length","TypeError","Object","keys","join","parseInt","test","match","exec","isNaN","RegExp","global","ignoreCase","multiline","source","re","prefix","wsStrip","wsCollapse","wsLine","wsAll","tabPat","collapsePat","pPat","tPat","nonWsPat","wsPat","wrapLen","text","toString","lastIndex","blocks","base","mo","arr","b","res","push","substring","index","type","breaks","remaining","j","k","segments","bloc","value","chunks","segment","parts","split","acc","x","slice","concat","curLine","curLineLength","lines","bulge","cleanLine","preservedLine","wrapLinePrefix","remnant","finishOffCurLine","beforeHardBreak","str","idx","ln","rBase","search","chunk","num","chunk2","soft","hard","args","call","arguments","last","apply","wrap","shift"],"sources":["/Users/Ellie/Desktop/projects/book-search-engine/client/node_modules/@oclif/linewrap/linewrap.js"],"sourcesContent":["// code is originally from https://github.com/AnAppAMonth/linewrap\n\n// Presets\nvar presetMap = {\n  'html': {\n    skipScheme: 'html',\n    lineBreakScheme: 'html',\n    whitespace: 'collapse'\n  }\n}\n\n// lineBreak Schemes\nvar brPat = /<\\s*br(?:[\\s/]*|\\s[^>]*)>/gi\nvar lineBreakSchemeMap = {\n  'unix': [/\\n/g, '\\n'],\n  'dos': [/\\r\\n/g, '\\r\\n'],\n  'mac': [/\\r/g, '\\r'],\n  'html': [brPat, '<br>'],\n  'xhtml': [brPat, '<br/>']\n}\n\n// skip Schemes\nvar skipSchemeMap = {\n  'ansi-color': /\\x1B\\[[^m]*m/g,\n  'html': /<[^>]*>/g,\n  'bbcode': /\\[[^]]*\\]/g\n}\n\nvar modeMap = {\n  'soft': 1,\n  'hard': 1\n}\n\nvar wsMap = {\n  'collapse': 1,\n  'default': 1,\n  'line': 1,\n  'all': 1\n}\n\nvar rlbMap = {\n  'all': 1,\n  'multi': 1,\n  'none': 1\n}\nvar rlbSMPat = /([sm])(\\d+)/\n\nvar escapePat = /[-/\\\\^$*+?.()|[\\]{}]/g\nfunction escapeRegExp (s) {\n  return s.replace(escapePat, '\\\\$&')\n}\n\nvar linewrap = module.exports = function (start, stop, params) {\n  if (typeof start === 'object') {\n    params = start\n    start = params.start\n    stop = params.stop\n  }\n\n  if (typeof stop === 'object') {\n    params = stop\n    start = start || params.start\n    stop = undefined\n  }\n\n  if (!stop) {\n    stop = start\n    start = 0\n  }\n\n  if (!params) { params = {}; }\n  // Supported options and default values.\n  var preset,\n    mode = 'soft',\n    whitespace = 'default',\n    tabWidth = 4,\n    skip, skipScheme, lineBreak, lineBreakScheme,\n    respectLineBreaks = 'all',\n    respectNum,\n    preservedLineIndent,\n    wrapLineIndent, wrapLineIndentBase\n\n  var skipPat\n  var lineBreakPat, lineBreakStr\n  var multiLineBreakPat\n  var preservedLinePrefix = ''\n  var wrapLineIndentPat, wrapLineInitPrefix = ''\n  var tabRepl\n  var item, flags\n  var i\n\n  // First process presets, because these settings can be overwritten later.\n  preset = params.preset\n  if (preset) {\n    if (!(preset instanceof Array)) {\n      preset = [preset]\n    }\n    for (i = 0; i < preset.length; i++) {\n      item = presetMap[preset[i]]\n      if (item) {\n        if (item.mode) {\n          mode = item.mode\n        }\n        if (item.whitespace) {\n          whitespace = item.whitespace\n        }\n        if (item.tabWidth !== undefined) {\n          tabWidth = item.tabWidth\n        }\n        if (item.skip) {\n          skip = item.skip\n        }\n        if (item.skipScheme) {\n          skipScheme = item.skipScheme\n        }\n        if (item.lineBreak) {\n          lineBreak = item.lineBreak\n        }\n        if (item.lineBreakScheme) {\n          lineBreakScheme = item.lineBreakScheme\n        }\n        if (item.respectLineBreaks) {\n          respectLineBreaks = item.respectLineBreaks\n        }\n        if (item.preservedLineIndent !== undefined) {\n          preservedLineIndent = item.preservedLineIndent\n        }\n        if (item.wrapLineIndent !== undefined) {\n          wrapLineIndent = item.wrapLineIndent\n        }\n        if (item.wrapLineIndentBase) {\n          wrapLineIndentBase = item.wrapLineIndentBase\n        }\n      } else {\n        throw new TypeError('preset must be one of \"' + Object.keys(presetMap).join('\", \"') + '\"')\n      }\n    }\n  }\n\n  if (params.mode) {\n    if (modeMap[params.mode]) {\n      mode = params.mode\n    } else {\n      throw new TypeError('mode must be one of \"' + Object.keys(modeMap).join('\", \"') + '\"')\n    }\n  }\n  // Available options: 'collapse', 'default', 'line', and 'all'\n  if (params.whitespace) {\n    if (wsMap[params.whitespace]) {\n      whitespace = params.whitespace\n    } else {\n      throw new TypeError('whitespace must be one of \"' + Object.keys(wsMap).join('\", \"') + '\"')\n    }\n  }\n\n  if (params.tabWidth !== undefined) {\n    if (parseInt(params.tabWidth, 10) >= 0) {\n      tabWidth = parseInt(params.tabWidth, 10)\n    } else {\n      throw new TypeError('tabWidth must be a non-negative integer')\n    }\n  }\n  tabRepl = new Array(tabWidth + 1).join(' ')\n\n  // Available options: 'all', 'multi', 'm\\d+', 's\\d+', 'none'\n  if (params.respectLineBreaks) {\n    if (rlbMap[params.respectLineBreaks] || rlbSMPat.test(params.respectLineBreaks)) {\n      respectLineBreaks = params.respectLineBreaks\n    } else {\n      throw new TypeError('respectLineBreaks must be one of \"' + Object.keys(rlbMap).join('\", \"') +\n        '\", \"m<num>\", \"s<num>\"')\n    }\n  }\n  // After these conversions, now we have 4 options in `respectLineBreaks`:\n  // 'all', 'none', 'm' and 's'.\n  // `respectNum` is applicable iff `respectLineBreaks` is either 'm' or 's'.\n  if (respectLineBreaks === 'multi') {\n    respectLineBreaks = 'm'\n    respectNum = 2\n  } else if (!rlbMap[respectLineBreaks]) {\n    var match = rlbSMPat.exec(respectLineBreaks)\n    respectLineBreaks = match[1]\n    respectNum = parseInt(match[2], 10)\n  }\n\n  if (params.preservedLineIndent !== undefined) {\n    if (parseInt(params.preservedLineIndent, 10) >= 0) {\n      preservedLineIndent = parseInt(params.preservedLineIndent, 10)\n    } else {\n      throw new TypeError('preservedLineIndent must be a non-negative integer')\n    }\n  }\n\n  if (preservedLineIndent > 0) {\n    preservedLinePrefix = new Array(preservedLineIndent + 1).join(' ')\n  }\n\n  if (params.wrapLineIndent !== undefined) {\n    if (!isNaN(parseInt(params.wrapLineIndent, 10))) {\n      wrapLineIndent = parseInt(params.wrapLineIndent, 10)\n    } else {\n      throw new TypeError('wrapLineIndent must be an integer')\n    }\n  }\n  if (params.wrapLineIndentBase) {\n    wrapLineIndentBase = params.wrapLineIndentBase\n  }\n\n  if (wrapLineIndentBase) {\n    if (wrapLineIndent === undefined) {\n      throw new TypeError('wrapLineIndent must be specified when wrapLineIndentBase is specified')\n    }\n    if (wrapLineIndentBase instanceof RegExp) {\n      wrapLineIndentPat = wrapLineIndentBase\n    } else if (typeof wrapLineIndentBase === 'string') {\n      wrapLineIndentPat = new RegExp(escapeRegExp(wrapLineIndentBase))\n    } else {\n      throw new TypeError('wrapLineIndentBase must be either a RegExp object or a string')\n    }\n  } else if (wrapLineIndent > 0) {\n    wrapLineInitPrefix = new Array(wrapLineIndent + 1).join(' ')\n  } else if (wrapLineIndent < 0) {\n    throw new TypeError('wrapLineIndent must be non-negative when a base is not specified')\n  }\n\n  // NOTE: For the two RegExps `skipPat` and `lineBreakPat` that can be specified\n  //       by the user:\n  //       1. We require them to be \"global\", so we have to convert them to global\n  //          if the user specifies a non-global regex.\n  //       2. We cannot call `split()` on them, because they may or may not contain\n  //          capturing parentheses which affect the output of `split()`.\n\n  // Precedence: Regex = Str > Scheme\n  if (params.skipScheme) {\n    if (skipSchemeMap[params.skipScheme]) {\n      skipScheme = params.skipScheme\n    } else {\n      throw new TypeError('skipScheme must be one of \"' + Object.keys(skipSchemeMap).join('\", \"') + '\"')\n    }\n  }\n  if (params.skip) {\n    skip = params.skip\n  }\n\n  if (skip) {\n    if (skip instanceof RegExp) {\n      skipPat = skip\n      if (!skipPat.global) {\n        flags = 'g'\n        if (skipPat.ignoreCase) { flags += 'i'; }\n        if (skipPat.multiline) { flags += 'm'; }\n        skipPat = new RegExp(skipPat.source, flags)\n      }\n    } else if (typeof skip === 'string') {\n      skipPat = new RegExp(escapeRegExp(skip), 'g')\n    } else {\n      throw new TypeError('skip must be either a RegExp object or a string')\n    }\n  }\n  if (!skipPat && skipScheme) {\n    skipPat = skipSchemeMap[skipScheme]\n  }\n\n  // Precedence:\n  // - for lineBreakPat: Regex > Scheme > Str\n  // - for lineBreakStr: Str > Scheme > Regex\n  if (params.lineBreakScheme) {\n    if (lineBreakSchemeMap[params.lineBreakScheme]) {\n      lineBreakScheme = params.lineBreakScheme\n    } else {\n      throw new TypeError('lineBreakScheme must be one of \"' + Object.keys(lineBreakSchemeMap).join('\", \"') + '\"')\n    }\n  }\n  if (params.lineBreak) {\n    lineBreak = params.lineBreak\n  }\n\n  if (lineBreakScheme) {\n    // Supported schemes: 'unix', 'dos', 'mac', 'html', 'xhtml'\n    item = lineBreakSchemeMap[lineBreakScheme]\n    if (item) {\n      lineBreakPat = item[0]\n      lineBreakStr = item[1]\n    }\n  }\n  if (lineBreak) {\n    if (lineBreak instanceof Array) {\n      if (lineBreak.length === 1) {\n        lineBreak = lineBreak[0]\n      } else if (lineBreak.length >= 2) {\n        if (lineBreak[0] instanceof RegExp) {\n          lineBreakPat = lineBreak[0]\n          if (typeof lineBreak[1] === 'string') {\n            lineBreakStr = lineBreak[1]\n          }\n        } else if (lineBreak[1] instanceof RegExp) {\n          lineBreakPat = lineBreak[1]\n          if (typeof lineBreak[0] === 'string') {\n            lineBreakStr = lineBreak[0]\n          }\n        } else if (typeof lineBreak[0] === 'string' && typeof lineBreak[1] === 'string') {\n          lineBreakPat = new RegExp(escapeRegExp(lineBreak[0]), 'g')\n          lineBreakStr = lineBreak[1]\n        } else {\n          lineBreak = lineBreak[0]\n        }\n      }\n    }\n    if (typeof lineBreak === 'string') {\n      lineBreakStr = lineBreak\n      if (!lineBreakPat) {\n        lineBreakPat = new RegExp(escapeRegExp(lineBreak), 'g')\n      }\n    } else if (lineBreak instanceof RegExp) {\n      lineBreakPat = lineBreak\n    } else if (!(lineBreak instanceof Array)) {\n      throw new TypeError('lineBreak must be a RegExp object, a string, or an array consisted of a RegExp object and a string')\n    }\n  }\n  // Only assign defaults when `lineBreakPat` is not assigned.\n  // So if `params.lineBreak` is a RegExp, we don't have a value in `lineBreakStr`\n  // yet. We will try to get the value from the input string, and if failed, we\n  // will throw an exception.\n  if (!lineBreakPat) {\n    lineBreakPat = /\\n/g\n    lineBreakStr = '\\n'\n  }\n\n  // Create `multiLineBreakPat` based on `lineBreakPat`, that matches strings\n  // consisted of one or more line breaks and zero or more whitespaces.\n  // Also convert `lineBreakPat` to global if not already so.\n  flags = 'g'\n  if (lineBreakPat.ignoreCase) { flags += 'i'; }\n  if (lineBreakPat.multiline) { flags += 'm'; }\n  multiLineBreakPat = new RegExp('\\\\s*(?:' + lineBreakPat.source + ')(?:' +\n    lineBreakPat.source + '|\\\\s)*', flags)\n  if (!lineBreakPat.global) {\n    lineBreakPat = new RegExp(lineBreakPat.source, flags)\n  }\n\n  // Initialize other useful variables.\n  var re = mode === 'hard' ? /\\b/ : /(\\S+\\s+)/\n  var prefix = new Array(start + 1).join(' ')\n  var wsStrip = (whitespace === 'default' || whitespace === 'collapse'),\n    wsCollapse = (whitespace === 'collapse'),\n    wsLine = (whitespace === 'line'),\n    wsAll = (whitespace === 'all')\n  var tabPat = /\\t/g,\n    collapsePat = /  +/g,\n    pPat = /^\\s+/,\n    tPat = /\\s+$/,\n    nonWsPat = /\\S/,\n    wsPat = /\\s/\n  var wrapLen = stop - start\n\n  return function (text) {\n    text = text.toString().replace(tabPat, tabRepl)\n\n    var match\n    if (!lineBreakStr) {\n      // Try to get lineBreakStr from `text`\n      lineBreakPat.lastIndex = 0\n      match = lineBreakPat.exec(text)\n      if (match) {\n        lineBreakStr = match[0]\n      } else {\n        throw new TypeError('Line break string for the output not specified')\n      }\n    }\n\n    // text -> blocks; each bloc -> segments; each segment -> chunks\n    var blocks, base = 0\n    var mo, arr, b, res\n    // Split `text` by line breaks.\n    blocks = []\n    multiLineBreakPat.lastIndex = 0\n    match = multiLineBreakPat.exec(text)\n    while(match) {\n      blocks.push(text.substring(base, match.index))\n\n      if (respectLineBreaks !== 'none') {\n        arr = []\n        b = 0\n        lineBreakPat.lastIndex = 0\n        mo = lineBreakPat.exec(match[0])\n        while(mo) {\n          arr.push(match[0].substring(b, mo.index))\n          b = mo.index + mo[0].length\n          mo = lineBreakPat.exec(match[0])\n        }\n        arr.push(match[0].substring(b))\n        blocks.push({type: 'break', breaks: arr})\n      } else {\n        // Strip line breaks and insert spaces when necessary.\n        if (wsCollapse) {\n          res = ' '\n        } else {\n          res = match[0].replace(lineBreakPat, '')\n        }\n        blocks.push({type: 'break', remaining: res})\n      }\n\n      base = match.index + match[0].length\n      match = multiLineBreakPat.exec(text)\n    }\n    blocks.push(text.substring(base))\n\n    var i, j, k\n    var segments\n    if (skipPat) {\n      segments = []\n      for (i = 0; i < blocks.length; i++) {\n        var bloc = blocks[i]\n        if (typeof bloc !== 'string') {\n          // This is an object.\n          segments.push(bloc)\n        } else {\n          base = 0\n          skipPat.lastIndex = 0\n          match = skipPat.exec(bloc)\n          while(match) {\n            segments.push(bloc.substring(base, match.index))\n            segments.push({type: 'skip', value: match[0]})\n            base = match.index + match[0].length\n            match = skipPat.exec(bloc)\n          }\n          segments.push(bloc.substring(base))\n        }\n      }\n    } else {\n      segments = blocks\n    }\n\n    var chunks = []\n    for (i = 0; i < segments.length; i++) {\n      var segment = segments[i]\n      if (typeof segment !== 'string') {\n        // This is an object.\n        chunks.push(segment)\n      } else {\n        if (wsCollapse) {\n          segment = segment.replace(collapsePat, ' ')\n        }\n\n        var parts = segment.split(re),\n          acc = []\n\n        for (j = 0; j < parts.length; j++) {\n          var x = parts[j]\n          if (mode === 'hard') {\n            for (k = 0; k < x.length; k += wrapLen) {\n              acc.push(x.slice(k, k + wrapLen))\n            }\n          } else { acc.push(x); }\n        }\n        chunks = chunks.concat(acc)\n      }\n    }\n\n    var curLine = 0,\n      curLineLength = start + preservedLinePrefix.length,\n      lines = [ prefix + preservedLinePrefix ],\n      // Holds the \"real length\" (excluding trailing whitespaces) of the\n      // current line if it exceeds `stop`, otherwise 0.\n      // ONLY USED when `wsAll` is true, in `finishOffCurLine()`.\n      bulge = 0,\n      // `cleanLine` is true iff we are at the beginning of an output line. By\n      // \"beginning\" we mean it doesn't contain any non-whitespace char yet.\n      // But its `curLineLength` can be greater than `start`, or even possibly\n      // be greater than `stop`, if `wsStrip` is false.\n      //\n      // Note that a \"clean\" line can still contain skip strings, in addition\n      // to whitespaces.\n      //\n      // This variable is used to allow us strip preceding whitespaces when\n      // `wsStrip` is true, or `wsLine` is true and `preservedLine` is false.\n      cleanLine = true,\n      // `preservedLine` is true iff we are in a preserved input line.\n      //\n      // It's used when `wsLine` is true to (combined with `cleanLine`) decide\n      // whether a whitespace is at the beginning of a preserved input line and\n      // should not be stripped.\n      preservedLine = true,\n      // The current indent prefix for wrapped lines.\n      wrapLinePrefix = wrapLineInitPrefix,\n      remnant\n\n    // Always returns '' if `beforeHardBreak` is true.\n    //\n    // Assumption: Each call of this function is always followed by a `lines.push()` call.\n    //\n    // This function can change the status of `cleanLine`, but we don't modify the value of\n    // `cleanLine` in this function. It's fine because `cleanLine` will be set to the correct\n    // value after the `lines.push()` call following this function call. We also don't update\n    // `curLineLength` when pushing a new line and it's safe for the same reason.\n    function finishOffCurLine (beforeHardBreak) {\n      var str = lines[curLine],\n        idx, ln, rBase\n\n      if (!wsAll) {\n        // Strip all trailing whitespaces past `start`.\n        idx = str.length - 1\n        while (idx >= start && str[idx] === ' ') { idx--; }\n        while (idx >= start && wsPat.test(str[idx])) { idx--; }\n        idx++\n\n        if (idx !== str.length) {\n          lines[curLine] = str.substring(0, idx)\n        }\n\n        if (preservedLine && cleanLine && wsLine && curLineLength > stop) {\n          // Add the remnants to the next line, just like when `wsAll` is true.\n          rBase = str.length - (curLineLength - stop)\n          if (rBase < idx) {\n            // We didn't reach `stop` when stripping due to a bulge.\n            rBase = idx\n          }\n        }\n      } else {\n        // Strip trailing whitespaces exceeding stop.\n        if (curLineLength > stop) {\n          bulge = bulge || stop\n          rBase = str.length - (curLineLength - bulge)\n          lines[curLine] = str.substring(0, rBase)\n        }\n        bulge = 0\n      }\n\n      // Bug: the current implementation of `wrapLineIndent` is buggy: we are not\n      // taking the extra space occupied by the additional indentation into account\n      // when wrapping the line. For example, in \"hard\" mode, we should hard-wrap\n      // long words at `wrapLen - wrapLinePrefix.length` instead of `wrapLen`\n      // and remnants should also be wrapped at `wrapLen - wrapLinePrefix.length`.\n      if (preservedLine) {\n        // This is a preserved line, and the next output line isn't a\n        // preserved line.\n        preservedLine = false\n        if (wrapLineIndentPat) {\n          idx = lines[curLine].substring(start).search(wrapLineIndentPat)\n          if (idx >= 0 && idx + wrapLineIndent > 0) {\n            wrapLinePrefix = new Array(idx + wrapLineIndent + 1).join(' ')\n          } else {\n            wrapLinePrefix = ''\n          }\n        }\n      }\n\n      // Some remnants are left to the next line.\n      if (rBase) {\n        while (rBase + wrapLen < str.length) {\n          if (wsAll) {\n            ln = str.substring(rBase, rBase + wrapLen)\n            lines.push(prefix + wrapLinePrefix + ln)\n          } else {\n            lines.push(prefix + wrapLinePrefix)\n          }\n          rBase += wrapLen\n          curLine++\n        }\n        if (beforeHardBreak) {\n          if (wsAll) {\n            ln = str.substring(rBase)\n            lines.push(prefix + wrapLinePrefix + ln)\n          } else {\n            lines.push(prefix + wrapLinePrefix)\n          }\n          curLine++\n        } else {\n          ln = str.substring(rBase)\n          return wrapLinePrefix + ln\n        }\n      }\n\n      return ''\n    }\n\n    for (i = 0; i < chunks.length; i++) {\n      var chunk = chunks[i]\n\n      if (chunk === '') { continue; }\n\n      if (typeof chunk !== 'string') {\n        if (chunk.type === 'break') {\n          // This is one or more line breaks.\n          // Each entry in `breaks` is just zero or more whitespaces.\n          if (respectLineBreaks !== 'none') {\n            // Note that if `whitespace` is \"collapse\", we still need\n            // to collapse whitespaces in entries of `breaks`.\n            var breaks = chunk.breaks\n            var num = breaks.length - 1\n\n            if (respectLineBreaks === 's') {\n              // This is the most complex scenario. We have to check\n              // the line breaks one by one.\n              for (j = 0; j < num; j++) {\n                if (breaks[j + 1].length < respectNum) {\n                  // This line break should be stripped.\n                  if (wsCollapse) {\n                    breaks[j + 1] = ' '\n                  } else {\n                    breaks[j + 1] = breaks[j] + breaks[j + 1]\n                  }\n                } else {\n                  // This line break should be preserved.\n                  // First finish off the current line.\n                  if (wsAll) {\n                    lines[curLine] += breaks[j]\n                    curLineLength += breaks[j].length\n                  }\n                  finishOffCurLine(true)\n\n                  lines.push(prefix + preservedLinePrefix)\n                  curLine++\n                  curLineLength = start + preservedLinePrefix.length\n\n                  preservedLine = cleanLine = true\n                }\n              }\n              // We are adding to either the existing line (if no line break\n              // is qualified for preservance) or a \"new\" line.\n              if (!cleanLine || wsAll || (wsLine && preservedLine)) {\n                if (wsCollapse || (!cleanLine && breaks[num] === '')) {\n                  breaks[num] = ' '\n                }\n                lines[curLine] += breaks[num]\n                curLineLength += breaks[num].length\n              }\n            } else if (respectLineBreaks === 'm' && num < respectNum) {\n              // These line breaks should be stripped.\n              if (!cleanLine || wsAll || (wsLine && preservedLine)) {\n                if (wsCollapse) {\n                  chunk = ' '\n                } else {\n                  chunk = breaks.join('')\n                  if (!cleanLine && chunk === '') {\n                    chunk = ' '\n                  }\n                }\n                lines[curLine] += chunk\n                curLineLength += chunk.length\n              }\n            } else { // 'all' || ('m' && num >= respectNum)\n              // These line breaks should be preserved.\n              if (wsStrip) {\n                // Finish off the current line.\n                finishOffCurLine(true)\n\n                for (j = 0; j < num; j++) {\n                  lines.push(prefix + preservedLinePrefix)\n                  curLine++\n                }\n\n                curLineLength = start + preservedLinePrefix.length\n                preservedLine = cleanLine = true\n              } else {\n                if (wsAll || (preservedLine && cleanLine)) {\n                  lines[curLine] += breaks[0]\n                  curLineLength += breaks[0].length\n                }\n\n                for (j = 0; j < num; j++) {\n                  // Finish off the current line.\n                  finishOffCurLine(true)\n\n                  lines.push(prefix + preservedLinePrefix + breaks[j + 1])\n                  curLine++\n                  curLineLength = start + preservedLinePrefix.length + breaks[j + 1].length\n\n                  preservedLine = cleanLine = true\n                }\n              }\n            }\n          } else {\n            // These line breaks should be stripped.\n            if (!cleanLine || wsAll || (wsLine && preservedLine)) {\n              chunk = chunk.remaining\n\n              // Bug: If `wsAll` is true, `cleanLine` is false, and `chunk`\n              // is '', we insert a space to replace the line break. This\n              // space will be preserved even if we are at the end of an\n              // output line, which is wrong behavior. However, I'm not\n              // sure it's worth it to fix this edge case.\n              if (wsCollapse || (!cleanLine && chunk === '')) {\n                chunk = ' '\n              }\n              lines[curLine] += chunk\n              curLineLength += chunk.length\n            }\n          }\n        } else if (chunk.type === 'skip') {\n          // This is a skip string.\n          // Assumption: skip strings don't end with whitespaces.\n          if (curLineLength > stop) {\n            remnant = finishOffCurLine(false)\n\n            lines.push(prefix + wrapLinePrefix)\n            curLine++\n            curLineLength = start + wrapLinePrefix.length\n\n            if (remnant) {\n              lines[curLine] += remnant\n              curLineLength += remnant.length\n            }\n\n            cleanLine = true\n          }\n          lines[curLine] += chunk.value\n        }\n        continue\n      }\n\n      var chunk2\n      while (1) {\n        chunk2 = undefined\n        if (curLineLength + chunk.length > stop &&\n          curLineLength + (chunk2 = chunk.replace(tPat, '')).length > stop &&\n          chunk2 !== '' &&\n          curLineLength > start) {\n          // This line is full, add `chunk` to the next line\n          remnant = finishOffCurLine(false)\n\n          lines.push(prefix + wrapLinePrefix)\n          curLine++\n          curLineLength = start + wrapLinePrefix.length\n\n          if (remnant) {\n            lines[curLine] += remnant\n            curLineLength += remnant.length\n            cleanLine = true\n            continue\n          }\n\n          if (wsStrip || (wsLine && !(preservedLine && cleanLine))) {\n            chunk = chunk.replace(pPat, '')\n          }\n          cleanLine = false\n        } else {\n          // Add `chunk` to this line\n          if (cleanLine) {\n            if (wsStrip || (wsLine && !(preservedLine && cleanLine))) {\n              chunk = chunk.replace(pPat, '')\n              if (chunk !== '') {\n                cleanLine = false\n              }\n            } else {\n              if (nonWsPat.test(chunk)) {\n                cleanLine = false\n              }\n            }\n          }\n        }\n        break\n      }\n      if (wsAll && chunk2 && curLineLength + chunk2.length > stop) {\n        bulge = curLineLength + chunk2.length\n      }\n      lines[curLine] += chunk\n      curLineLength += chunk.length\n    }\n    // Finally, finish off the last line.\n    finishOffCurLine(true)\n    return lines.join(lineBreakStr)\n  }\n}\n\nlinewrap.soft = linewrap\n\nlinewrap.hard = function ( /*start, stop, params*/) {\n  var args = [].slice.call(arguments)\n  var last = args.length - 1\n  if (typeof args[last] === 'object') {\n    args[last].mode = 'hard'\n  } else {\n    args.push({ mode: 'hard' })\n  }\n  return linewrap.apply(null, args)\n}\n\nlinewrap.wrap = function (text /*, start, stop, params*/) {\n  var args = [].slice.call(arguments)\n  args.shift()\n  return linewrap.apply(null, args)(text)\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}