{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst fs = require(\"fs\");\n\nconst path = require(\"path\");\n\nconst debug_1 = require(\"./debug\"); // eslint-disable-next-line new-cap\n\n\nconst debug = debug_1.default();\nconst tsconfigs = {};\nconst rootDirs = [];\nconst typeRoots = [`${__dirname}/../node_modules/@types`];\n\nfunction loadTSConfig(root) {\n  const tsconfigPath = path.join(root, 'tsconfig.json');\n  let typescript;\n\n  try {\n    typescript = require('typescript');\n  } catch (_a) {\n    try {\n      typescript = require(root + '/node_modules/typescript');\n    } catch (_b) {}\n  }\n\n  if (fs.existsSync(tsconfigPath) && typescript) {\n    const tsconfig = typescript.parseConfigFileTextToJson(tsconfigPath, fs.readFileSync(tsconfigPath, 'utf8')).config;\n\n    if (!tsconfig || !tsconfig.compilerOptions) {\n      throw new Error(`Could not read and parse tsconfig.json at ${tsconfigPath}, or it ` + 'did not contain a \"compilerOptions\" section.');\n    }\n\n    return tsconfig;\n  }\n}\n\nfunction registerTSNode(root) {\n  if (process.env.OCLIF_TS_NODE === '0') return;\n  if (tsconfigs[root]) return;\n  const tsconfig = loadTSConfig(root);\n  if (!tsconfig) return;\n  debug('registering ts-node at', root);\n\n  const tsNodePath = require.resolve('ts-node', {\n    paths: [root, __dirname]\n  });\n\n  const tsNode = require(tsNodePath);\n\n  tsconfigs[root] = tsconfig;\n  typeRoots.push(`${root}/node_modules/@types`);\n\n  if (tsconfig.compilerOptions.rootDirs) {\n    rootDirs.push(...tsconfig.compilerOptions.rootDirs.map(r => path.join(root, r)));\n  } else {\n    rootDirs.push(`${root}/src`);\n  }\n\n  const cwd = process.cwd();\n\n  try {\n    process.chdir(root);\n    tsNode.register({\n      skipProject: true,\n      transpileOnly: true,\n      // cache: false,\n      // typeCheck: true,\n      compilerOptions: {\n        esModuleInterop: tsconfig.compilerOptions.esModuleInterop,\n        target: tsconfig.compilerOptions.target || 'es2017',\n        experimentalDecorators: tsconfig.compilerOptions.experimentalDecorators || false,\n        emitDecoratorMetadata: tsconfig.compilerOptions.emitDecoratorMetadata || false,\n        module: 'commonjs',\n        sourceMap: true,\n        rootDirs,\n        typeRoots,\n        jsx: 'react'\n      }\n    });\n  } finally {\n    process.chdir(cwd);\n  }\n}\n\nfunction tsPath(root, orig) {\n  if (!orig) return orig;\n  orig = path.join(root, orig);\n\n  try {\n    registerTSNode(root);\n    const tsconfig = tsconfigs[root];\n    if (!tsconfig) return orig;\n    const {\n      rootDir,\n      rootDirs,\n      outDir\n    } = tsconfig.compilerOptions;\n    const rootDirPath = rootDir || (rootDirs || [])[0];\n    if (!rootDirPath || !outDir) return orig; // rewrite path from ./lib/foo to ./src/foo\n\n    const lib = path.join(root, outDir); // ./lib\n\n    const src = path.join(root, rootDirPath); // ./src\n\n    const relative = path.relative(lib, orig); // ./commands\n\n    const out = path.join(src, relative); // ./src/commands\n    // this can be a directory of commands or point to a hook file\n    // if it's a directory, we check if the path exists. If so, return the path to the directory.\n    // For hooks, it might point to a module, not a file. Something like \"./hooks/myhook\"\n    // That file doesn't exist, and the real file is \"./hooks/myhook.ts\"\n    // In that case we attempt to resolve to the filename. If it fails it will revert back to the lib path\n\n    if (fs.existsSync(out) || fs.existsSync(out + '.ts')) return out;\n    return orig;\n  } catch (error) {\n    debug(error);\n    return orig;\n  }\n}\n\nexports.tsPath = tsPath;","map":{"version":3,"names":["Object","defineProperty","exports","value","fs","require","path","debug_1","debug","default","tsconfigs","rootDirs","typeRoots","__dirname","loadTSConfig","root","tsconfigPath","join","typescript","_a","_b","existsSync","tsconfig","parseConfigFileTextToJson","readFileSync","config","compilerOptions","Error","registerTSNode","process","env","OCLIF_TS_NODE","tsNodePath","resolve","paths","tsNode","push","map","r","cwd","chdir","register","skipProject","transpileOnly","esModuleInterop","target","experimentalDecorators","emitDecoratorMetadata","module","sourceMap","jsx","tsPath","orig","rootDir","outDir","rootDirPath","lib","src","relative","out","error"],"sources":["/Users/Ellie/Desktop/projects/book-search-engine/client/node_modules/@oclif/help/node_modules/@oclif/config/lib/ts-node.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst debug_1 = require(\"./debug\");\n// eslint-disable-next-line new-cap\nconst debug = debug_1.default();\nconst tsconfigs = {};\nconst rootDirs = [];\nconst typeRoots = [`${__dirname}/../node_modules/@types`];\nfunction loadTSConfig(root) {\n    const tsconfigPath = path.join(root, 'tsconfig.json');\n    let typescript;\n    try {\n        typescript = require('typescript');\n    }\n    catch (_a) {\n        try {\n            typescript = require(root + '/node_modules/typescript');\n        }\n        catch (_b) { }\n    }\n    if (fs.existsSync(tsconfigPath) && typescript) {\n        const tsconfig = typescript.parseConfigFileTextToJson(tsconfigPath, fs.readFileSync(tsconfigPath, 'utf8')).config;\n        if (!tsconfig || !tsconfig.compilerOptions) {\n            throw new Error(`Could not read and parse tsconfig.json at ${tsconfigPath}, or it ` +\n                'did not contain a \"compilerOptions\" section.');\n        }\n        return tsconfig;\n    }\n}\nfunction registerTSNode(root) {\n    if (process.env.OCLIF_TS_NODE === '0')\n        return;\n    if (tsconfigs[root])\n        return;\n    const tsconfig = loadTSConfig(root);\n    if (!tsconfig)\n        return;\n    debug('registering ts-node at', root);\n    const tsNodePath = require.resolve('ts-node', { paths: [root, __dirname] });\n    const tsNode = require(tsNodePath);\n    tsconfigs[root] = tsconfig;\n    typeRoots.push(`${root}/node_modules/@types`);\n    if (tsconfig.compilerOptions.rootDirs) {\n        rootDirs.push(...tsconfig.compilerOptions.rootDirs.map(r => path.join(root, r)));\n    }\n    else {\n        rootDirs.push(`${root}/src`);\n    }\n    const cwd = process.cwd();\n    try {\n        process.chdir(root);\n        tsNode.register({\n            skipProject: true,\n            transpileOnly: true,\n            // cache: false,\n            // typeCheck: true,\n            compilerOptions: {\n                esModuleInterop: tsconfig.compilerOptions.esModuleInterop,\n                target: tsconfig.compilerOptions.target || 'es2017',\n                experimentalDecorators: tsconfig.compilerOptions.experimentalDecorators || false,\n                emitDecoratorMetadata: tsconfig.compilerOptions.emitDecoratorMetadata || false,\n                module: 'commonjs',\n                sourceMap: true,\n                rootDirs,\n                typeRoots,\n                jsx: 'react',\n            },\n        });\n    }\n    finally {\n        process.chdir(cwd);\n    }\n}\nfunction tsPath(root, orig) {\n    if (!orig)\n        return orig;\n    orig = path.join(root, orig);\n    try {\n        registerTSNode(root);\n        const tsconfig = tsconfigs[root];\n        if (!tsconfig)\n            return orig;\n        const { rootDir, rootDirs, outDir } = tsconfig.compilerOptions;\n        const rootDirPath = rootDir || (rootDirs || [])[0];\n        if (!rootDirPath || !outDir)\n            return orig;\n        // rewrite path from ./lib/foo to ./src/foo\n        const lib = path.join(root, outDir); // ./lib\n        const src = path.join(root, rootDirPath); // ./src\n        const relative = path.relative(lib, orig); // ./commands\n        const out = path.join(src, relative); // ./src/commands\n        // this can be a directory of commands or point to a hook file\n        // if it's a directory, we check if the path exists. If so, return the path to the directory.\n        // For hooks, it might point to a module, not a file. Something like \"./hooks/myhook\"\n        // That file doesn't exist, and the real file is \"./hooks/myhook.ts\"\n        // In that case we attempt to resolve to the filename. If it fails it will revert back to the lib path\n        if (fs.existsSync(out) || fs.existsSync(out + '.ts'))\n            return out;\n        return orig;\n    }\n    catch (error) {\n        debug(error);\n        return orig;\n    }\n}\nexports.tsPath = tsPath;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}