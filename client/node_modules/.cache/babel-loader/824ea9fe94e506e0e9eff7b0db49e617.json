{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addResolversToSchema = exports.buildSchemaFromSDL = exports.modulesFromSDL = void 0;\n\nconst graphql_1 = require(\"graphql\");\n\nconst validate_1 = require(\"graphql/validation/validate\");\n\nconst graphql_2 = require(\"../utilities/graphql\");\n\nconst GraphQLSchemaValidationError_1 = require(\"./GraphQLSchemaValidationError\");\n\nconst specifiedRules_1 = require(\"graphql/validation/specifiedRules\");\n\nconst flat_1 = __importDefault(require(\"core-js-pure/features/array/flat\"));\n\nconst validation_1 = require(\"graphql/validation\");\n\nconst mapValues_1 = require(\"../utilities/mapValues\");\n\nconst skippedSDLRules = [validation_1.KnownTypeNamesRule, validation_1.UniqueDirectivesPerLocationRule];\n\ntry {\n  const PossibleTypeExtensions = require(\"graphql/validation/rules/PossibleTypeExtensions\").PossibleTypeExtensions;\n\n  if (PossibleTypeExtensions) {\n    skippedSDLRules.push(PossibleTypeExtensions);\n  }\n} catch (e) {}\n\nconst sdlRules = specifiedRules_1.specifiedSDLRules.filter(rule => !skippedSDLRules.includes(rule));\n\nfunction modulesFromSDL(modulesOrSDL) {\n  if (Array.isArray(modulesOrSDL)) {\n    return modulesOrSDL.map(moduleOrSDL => {\n      if ((0, graphql_2.isNode)(moduleOrSDL) && (0, graphql_2.isDocumentNode)(moduleOrSDL)) {\n        return {\n          typeDefs: moduleOrSDL\n        };\n      } else {\n        return moduleOrSDL;\n      }\n    });\n  } else {\n    return [{\n      typeDefs: modulesOrSDL\n    }];\n  }\n}\n\nexports.modulesFromSDL = modulesFromSDL;\n\nfunction buildSchemaFromSDL(modulesOrSDL, schemaToExtend) {\n  const modules = modulesFromSDL(modulesOrSDL);\n  const documentAST = (0, graphql_1.concatAST)(modules.map(module => module.typeDefs));\n  const errors = (0, validate_1.validateSDL)(documentAST, schemaToExtend, sdlRules);\n\n  if (errors.length > 0) {\n    throw new GraphQLSchemaValidationError_1.GraphQLSchemaValidationError(errors);\n  }\n\n  const definitionsMap = Object.create(null);\n  const extensionsMap = Object.create(null);\n  const directiveDefinitions = [];\n  const schemaDefinitions = [];\n  const schemaExtensions = [];\n  const schemaDirectives = [];\n\n  for (const definition of documentAST.definitions) {\n    if ((0, graphql_1.isTypeDefinitionNode)(definition)) {\n      const typeName = definition.name.value;\n\n      if (definitionsMap[typeName]) {\n        definitionsMap[typeName].push(definition);\n      } else {\n        definitionsMap[typeName] = [definition];\n      }\n    } else if ((0, graphql_1.isTypeExtensionNode)(definition)) {\n      const typeName = definition.name.value;\n\n      if (extensionsMap[typeName]) {\n        extensionsMap[typeName].push(definition);\n      } else {\n        extensionsMap[typeName] = [definition];\n      }\n    } else if (definition.kind === graphql_1.Kind.DIRECTIVE_DEFINITION) {\n      directiveDefinitions.push(definition);\n    } else if (definition.kind === graphql_1.Kind.SCHEMA_DEFINITION) {\n      schemaDefinitions.push(definition);\n      schemaDirectives.push(...(definition.directives ? definition.directives : []));\n    } else if (definition.kind === graphql_1.Kind.SCHEMA_EXTENSION) {\n      schemaExtensions.push(definition);\n    }\n  }\n\n  let schema = schemaToExtend ? schemaToExtend : new graphql_1.GraphQLSchema({\n    query: undefined\n  });\n  const missingTypeDefinitions = [];\n\n  for (const [extendedTypeName, extensions] of Object.entries(extensionsMap)) {\n    if (!definitionsMap[extendedTypeName]) {\n      const extension = extensions[0];\n      const kind = extension.kind;\n      const definition = {\n        kind: extKindToDefKind[kind],\n        name: extension.name\n      };\n      missingTypeDefinitions.push(definition);\n    }\n  }\n\n  schema = (0, graphql_1.extendSchema)(schema, {\n    kind: graphql_1.Kind.DOCUMENT,\n    definitions: [...(0, flat_1.default)(Object.values(definitionsMap)), ...missingTypeDefinitions, ...directiveDefinitions]\n  }, {\n    assumeValidSDL: true\n  });\n  schema = (0, graphql_1.extendSchema)(schema, {\n    kind: graphql_1.Kind.DOCUMENT,\n    definitions: (0, flat_1.default)(Object.values(extensionsMap))\n  }, {\n    assumeValidSDL: true\n  });\n  let operationTypeMap;\n\n  if (schemaDefinitions.length > 0 || schemaExtensions.length > 0) {\n    operationTypeMap = {};\n    const operationTypes = (0, flat_1.default)([...schemaDefinitions, ...schemaExtensions].map(node => node.operationTypes).filter(isNotNullOrUndefined));\n\n    for (const {\n      operation,\n      type\n    } of operationTypes) {\n      operationTypeMap[operation] = type.name.value;\n    }\n  } else {\n    operationTypeMap = {\n      query: \"Query\",\n      mutation: \"Mutation\",\n      subscription: \"Subscription\"\n    };\n  }\n\n  schema = new graphql_1.GraphQLSchema(Object.assign(Object.assign(Object.assign({}, schema.toConfig()), (0, mapValues_1.mapValues)(operationTypeMap, typeName => typeName ? schema.getType(typeName) : undefined)), {\n    astNode: {\n      kind: graphql_1.Kind.SCHEMA_DEFINITION,\n      directives: schemaDirectives,\n      operationTypes: []\n    }\n  }));\n\n  for (const module of modules) {\n    if (!module.resolvers) continue;\n    addResolversToSchema(schema, module.resolvers);\n  }\n\n  return schema;\n}\n\nexports.buildSchemaFromSDL = buildSchemaFromSDL;\nconst extKindToDefKind = {\n  [graphql_1.Kind.SCALAR_TYPE_EXTENSION]: graphql_1.Kind.SCALAR_TYPE_DEFINITION,\n  [graphql_1.Kind.OBJECT_TYPE_EXTENSION]: graphql_1.Kind.OBJECT_TYPE_DEFINITION,\n  [graphql_1.Kind.INTERFACE_TYPE_EXTENSION]: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,\n  [graphql_1.Kind.UNION_TYPE_EXTENSION]: graphql_1.Kind.UNION_TYPE_DEFINITION,\n  [graphql_1.Kind.ENUM_TYPE_EXTENSION]: graphql_1.Kind.ENUM_TYPE_DEFINITION,\n  [graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION]: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION\n};\n\nfunction addResolversToSchema(schema, resolvers) {\n  for (const [typeName, fieldConfigs] of Object.entries(resolvers)) {\n    const type = schema.getType(typeName);\n\n    if ((0, graphql_1.isAbstractType)(type)) {\n      for (const [fieldName, fieldConfig] of Object.entries(fieldConfigs)) {\n        if (fieldName.startsWith(\"__\")) {\n          type[fieldName.substring(2)] = fieldConfig;\n        }\n      }\n    }\n\n    if ((0, graphql_1.isScalarType)(type)) {\n      for (const fn in fieldConfigs) {\n        type[fn] = fieldConfigs[fn];\n      }\n    }\n\n    if ((0, graphql_1.isEnumType)(type)) {\n      const values = type.getValues();\n      const newValues = {};\n      values.forEach(value => {\n        let newValue = fieldConfigs[value.name];\n\n        if (newValue === undefined) {\n          newValue = value.name;\n        }\n\n        newValues[value.name] = {\n          value: newValue,\n          deprecationReason: value.deprecationReason,\n          description: value.description,\n          astNode: value.astNode,\n          extensions: undefined\n        };\n      });\n      Object.assign(type, new graphql_1.GraphQLEnumType(Object.assign(Object.assign({}, type.toConfig()), {\n        values: newValues\n      })));\n    }\n\n    if (!(0, graphql_1.isObjectType)(type)) continue;\n    const fieldMap = type.getFields();\n\n    for (const [fieldName, fieldConfig] of Object.entries(fieldConfigs)) {\n      if (fieldName.startsWith(\"__\")) {\n        type[fieldName.substring(2)] = fieldConfig;\n        continue;\n      }\n\n      const field = fieldMap[fieldName];\n      if (!field) continue;\n\n      if (typeof fieldConfig === \"function\") {\n        field.resolve = fieldConfig;\n      } else {\n        field.resolve = fieldConfig.resolve;\n      }\n    }\n  }\n}\n\nexports.addResolversToSchema = addResolversToSchema;\n\nfunction isNotNullOrUndefined(value) {\n  return value !== null && typeof value !== \"undefined\";\n}","map":{"version":3,"sources":["../../src/schema/buildSchemaFromSDL.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addResolversToSchema = exports.buildSchemaFromSDL = exports.modulesFromSDL = void 0;\nconst graphql_1 = require(\"graphql\");\nconst validate_1 = require(\"graphql/validation/validate\");\nconst graphql_2 = require(\"../utilities/graphql\");\nconst GraphQLSchemaValidationError_1 = require(\"./GraphQLSchemaValidationError\");\nconst specifiedRules_1 = require(\"graphql/validation/specifiedRules\");\nconst flat_1 = __importDefault(require(\"core-js-pure/features/array/flat\"));\nconst validation_1 = require(\"graphql/validation\");\nconst mapValues_1 = require(\"../utilities/mapValues\");\nconst skippedSDLRules = [\n    validation_1.KnownTypeNamesRule,\n    validation_1.UniqueDirectivesPerLocationRule,\n];\ntry {\n    const PossibleTypeExtensions = require(\"graphql/validation/rules/PossibleTypeExtensions\").PossibleTypeExtensions;\n    if (PossibleTypeExtensions) {\n        skippedSDLRules.push(PossibleTypeExtensions);\n    }\n}\ncatch (e) {\n}\nconst sdlRules = specifiedRules_1.specifiedSDLRules.filter((rule) => !skippedSDLRules.includes(rule));\nfunction modulesFromSDL(modulesOrSDL) {\n    if (Array.isArray(modulesOrSDL)) {\n        return modulesOrSDL.map((moduleOrSDL) => {\n            if ((0, graphql_2.isNode)(moduleOrSDL) && (0, graphql_2.isDocumentNode)(moduleOrSDL)) {\n                return { typeDefs: moduleOrSDL };\n            }\n            else {\n                return moduleOrSDL;\n            }\n        });\n    }\n    else {\n        return [{ typeDefs: modulesOrSDL }];\n    }\n}\nexports.modulesFromSDL = modulesFromSDL;\nfunction buildSchemaFromSDL(modulesOrSDL, schemaToExtend) {\n    const modules = modulesFromSDL(modulesOrSDL);\n    const documentAST = (0, graphql_1.concatAST)(modules.map((module) => module.typeDefs));\n    const errors = (0, validate_1.validateSDL)(documentAST, schemaToExtend, sdlRules);\n    if (errors.length > 0) {\n        throw new GraphQLSchemaValidationError_1.GraphQLSchemaValidationError(errors);\n    }\n    const definitionsMap = Object.create(null);\n    const extensionsMap = Object.create(null);\n    const directiveDefinitions = [];\n    const schemaDefinitions = [];\n    const schemaExtensions = [];\n    const schemaDirectives = [];\n    for (const definition of documentAST.definitions) {\n        if ((0, graphql_1.isTypeDefinitionNode)(definition)) {\n            const typeName = definition.name.value;\n            if (definitionsMap[typeName]) {\n                definitionsMap[typeName].push(definition);\n            }\n            else {\n                definitionsMap[typeName] = [definition];\n            }\n        }\n        else if ((0, graphql_1.isTypeExtensionNode)(definition)) {\n            const typeName = definition.name.value;\n            if (extensionsMap[typeName]) {\n                extensionsMap[typeName].push(definition);\n            }\n            else {\n                extensionsMap[typeName] = [definition];\n            }\n        }\n        else if (definition.kind === graphql_1.Kind.DIRECTIVE_DEFINITION) {\n            directiveDefinitions.push(definition);\n        }\n        else if (definition.kind === graphql_1.Kind.SCHEMA_DEFINITION) {\n            schemaDefinitions.push(definition);\n            schemaDirectives.push(...(definition.directives ? definition.directives : []));\n        }\n        else if (definition.kind === graphql_1.Kind.SCHEMA_EXTENSION) {\n            schemaExtensions.push(definition);\n        }\n    }\n    let schema = schemaToExtend\n        ? schemaToExtend\n        : new graphql_1.GraphQLSchema({\n            query: undefined,\n        });\n    const missingTypeDefinitions = [];\n    for (const [extendedTypeName, extensions] of Object.entries(extensionsMap)) {\n        if (!definitionsMap[extendedTypeName]) {\n            const extension = extensions[0];\n            const kind = extension.kind;\n            const definition = {\n                kind: extKindToDefKind[kind],\n                name: extension.name,\n            };\n            missingTypeDefinitions.push(definition);\n        }\n    }\n    schema = (0, graphql_1.extendSchema)(schema, {\n        kind: graphql_1.Kind.DOCUMENT,\n        definitions: [\n            ...(0, flat_1.default)(Object.values(definitionsMap)),\n            ...missingTypeDefinitions,\n            ...directiveDefinitions,\n        ],\n    }, {\n        assumeValidSDL: true,\n    });\n    schema = (0, graphql_1.extendSchema)(schema, {\n        kind: graphql_1.Kind.DOCUMENT,\n        definitions: (0, flat_1.default)(Object.values(extensionsMap)),\n    }, {\n        assumeValidSDL: true,\n    });\n    let operationTypeMap;\n    if (schemaDefinitions.length > 0 || schemaExtensions.length > 0) {\n        operationTypeMap = {};\n        const operationTypes = (0, flat_1.default)([...schemaDefinitions, ...schemaExtensions]\n            .map((node) => node.operationTypes)\n            .filter(isNotNullOrUndefined));\n        for (const { operation, type } of operationTypes) {\n            operationTypeMap[operation] = type.name.value;\n        }\n    }\n    else {\n        operationTypeMap = {\n            query: \"Query\",\n            mutation: \"Mutation\",\n            subscription: \"Subscription\",\n        };\n    }\n    schema = new graphql_1.GraphQLSchema(Object.assign(Object.assign(Object.assign({}, schema.toConfig()), (0, mapValues_1.mapValues)(operationTypeMap, (typeName) => typeName\n        ? schema.getType(typeName)\n        : undefined)), { astNode: {\n            kind: graphql_1.Kind.SCHEMA_DEFINITION,\n            directives: schemaDirectives,\n            operationTypes: [],\n        } }));\n    for (const module of modules) {\n        if (!module.resolvers)\n            continue;\n        addResolversToSchema(schema, module.resolvers);\n    }\n    return schema;\n}\nexports.buildSchemaFromSDL = buildSchemaFromSDL;\nconst extKindToDefKind = {\n    [graphql_1.Kind.SCALAR_TYPE_EXTENSION]: graphql_1.Kind.SCALAR_TYPE_DEFINITION,\n    [graphql_1.Kind.OBJECT_TYPE_EXTENSION]: graphql_1.Kind.OBJECT_TYPE_DEFINITION,\n    [graphql_1.Kind.INTERFACE_TYPE_EXTENSION]: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,\n    [graphql_1.Kind.UNION_TYPE_EXTENSION]: graphql_1.Kind.UNION_TYPE_DEFINITION,\n    [graphql_1.Kind.ENUM_TYPE_EXTENSION]: graphql_1.Kind.ENUM_TYPE_DEFINITION,\n    [graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION]: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,\n};\nfunction addResolversToSchema(schema, resolvers) {\n    for (const [typeName, fieldConfigs] of Object.entries(resolvers)) {\n        const type = schema.getType(typeName);\n        if ((0, graphql_1.isAbstractType)(type)) {\n            for (const [fieldName, fieldConfig] of Object.entries(fieldConfigs)) {\n                if (fieldName.startsWith(\"__\")) {\n                    type[fieldName.substring(2)] = fieldConfig;\n                }\n            }\n        }\n        if ((0, graphql_1.isScalarType)(type)) {\n            for (const fn in fieldConfigs) {\n                type[fn] = fieldConfigs[fn];\n            }\n        }\n        if ((0, graphql_1.isEnumType)(type)) {\n            const values = type.getValues();\n            const newValues = {};\n            values.forEach((value) => {\n                let newValue = fieldConfigs[value.name];\n                if (newValue === undefined) {\n                    newValue = value.name;\n                }\n                newValues[value.name] = {\n                    value: newValue,\n                    deprecationReason: value.deprecationReason,\n                    description: value.description,\n                    astNode: value.astNode,\n                    extensions: undefined,\n                };\n            });\n            Object.assign(type, new graphql_1.GraphQLEnumType(Object.assign(Object.assign({}, type.toConfig()), { values: newValues })));\n        }\n        if (!(0, graphql_1.isObjectType)(type))\n            continue;\n        const fieldMap = type.getFields();\n        for (const [fieldName, fieldConfig] of Object.entries(fieldConfigs)) {\n            if (fieldName.startsWith(\"__\")) {\n                type[fieldName.substring(2)] = fieldConfig;\n                continue;\n            }\n            const field = fieldMap[fieldName];\n            if (!field)\n                continue;\n            if (typeof fieldConfig === \"function\") {\n                field.resolve = fieldConfig;\n            }\n            else {\n                field.resolve = fieldConfig.resolve;\n            }\n        }\n    }\n}\nexports.addResolversToSchema = addResolversToSchema;\nfunction isNotNullOrUndefined(value) {\n    return value !== null && typeof value !== \"undefined\";\n}\n//# sourceMappingURL=buildSchemaFromSDL.js.map"]},"metadata":{},"sourceType":"script"}