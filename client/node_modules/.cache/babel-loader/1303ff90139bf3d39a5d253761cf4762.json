{"ast":null,"code":"\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbstractMessageBuffer = void 0;\nconst CR = 13;\nconst LF = 10;\nconst CRLF = '\\r\\n';\n\nclass AbstractMessageBuffer {\n  constructor(encoding = 'utf-8') {\n    this._encoding = encoding;\n    this._chunks = [];\n    this._totalLength = 0;\n  }\n\n  get encoding() {\n    return this._encoding;\n  }\n\n  append(chunk) {\n    const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;\n\n    this._chunks.push(toAppend);\n\n    this._totalLength += toAppend.byteLength;\n  }\n\n  tryReadHeaders() {\n    if (this._chunks.length === 0) {\n      return undefined;\n    }\n\n    let state = 0;\n    let chunkIndex = 0;\n    let offset = 0;\n    let chunkBytesRead = 0;\n\n    row: while (chunkIndex < this._chunks.length) {\n      const chunk = this._chunks[chunkIndex];\n      offset = 0;\n\n      column: while (offset < chunk.length) {\n        const value = chunk[offset];\n\n        switch (value) {\n          case CR:\n            switch (state) {\n              case 0:\n                state = 1;\n                break;\n\n              case 2:\n                state = 3;\n                break;\n\n              default:\n                state = 0;\n            }\n\n            break;\n\n          case LF:\n            switch (state) {\n              case 1:\n                state = 2;\n                break;\n\n              case 3:\n                state = 4;\n                offset++;\n                break row;\n\n              default:\n                state = 0;\n            }\n\n            break;\n\n          default:\n            state = 0;\n        }\n\n        offset++;\n      }\n\n      chunkBytesRead += chunk.byteLength;\n      chunkIndex++;\n    }\n\n    if (state !== 4) {\n      return undefined;\n    } // The buffer contains the two CRLF at the end. So we will\n    // have two empty lines after the split at the end as well.\n\n\n    const buffer = this._read(chunkBytesRead + offset);\n\n    const result = new Map();\n    const headers = this.toString(buffer, 'ascii').split(CRLF);\n\n    if (headers.length < 2) {\n      return result;\n    }\n\n    for (let i = 0; i < headers.length - 2; i++) {\n      const header = headers[i];\n      const index = header.indexOf(':');\n\n      if (index === -1) {\n        throw new Error('Message header must separate key and value using :');\n      }\n\n      const key = header.substr(0, index);\n      const value = header.substr(index + 1).trim();\n      result.set(key, value);\n    }\n\n    return result;\n  }\n\n  tryReadBody(length) {\n    if (this._totalLength < length) {\n      return undefined;\n    }\n\n    return this._read(length);\n  }\n\n  get numberOfBytes() {\n    return this._totalLength;\n  }\n\n  _read(byteCount) {\n    if (byteCount === 0) {\n      return this.emptyBuffer();\n    }\n\n    if (byteCount > this._totalLength) {\n      throw new Error(`Cannot read so many bytes!`);\n    }\n\n    if (this._chunks[0].byteLength === byteCount) {\n      // super fast path, precisely first chunk must be returned\n      const chunk = this._chunks[0];\n\n      this._chunks.shift();\n\n      this._totalLength -= byteCount;\n      return this.asNative(chunk);\n    }\n\n    if (this._chunks[0].byteLength > byteCount) {\n      // fast path, the reading is entirely within the first chunk\n      const chunk = this._chunks[0];\n      const result = this.asNative(chunk, byteCount);\n      this._chunks[0] = chunk.slice(byteCount);\n      this._totalLength -= byteCount;\n      return result;\n    }\n\n    const result = this.allocNative(byteCount);\n    let resultOffset = 0;\n    let chunkIndex = 0;\n\n    while (byteCount > 0) {\n      const chunk = this._chunks[chunkIndex];\n\n      if (chunk.byteLength > byteCount) {\n        // this chunk will survive\n        const chunkPart = chunk.slice(0, byteCount);\n        result.set(chunkPart, resultOffset);\n        resultOffset += byteCount;\n        this._chunks[chunkIndex] = chunk.slice(byteCount);\n        this._totalLength -= byteCount;\n        byteCount -= byteCount;\n      } else {\n        // this chunk will be entirely read\n        result.set(chunk, resultOffset);\n        resultOffset += chunk.byteLength;\n\n        this._chunks.shift();\n\n        this._totalLength -= chunk.byteLength;\n        byteCount -= chunk.byteLength;\n      }\n    }\n\n    return result;\n  }\n\n}\n\nexports.AbstractMessageBuffer = AbstractMessageBuffer;","map":{"version":3,"names":["Object","defineProperty","exports","value","AbstractMessageBuffer","CR","LF","CRLF","constructor","encoding","_encoding","_chunks","_totalLength","append","chunk","toAppend","fromString","push","byteLength","tryReadHeaders","length","undefined","state","chunkIndex","offset","chunkBytesRead","row","column","buffer","_read","result","Map","headers","toString","split","i","header","index","indexOf","Error","key","substr","trim","set","tryReadBody","numberOfBytes","byteCount","emptyBuffer","shift","asNative","slice","allocNative","resultOffset","chunkPart"],"sources":["/Users/Ellie/Desktop/projects/book-search-engine/client/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"],"sourcesContent":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbstractMessageBuffer = void 0;\nconst CR = 13;\nconst LF = 10;\nconst CRLF = '\\r\\n';\nclass AbstractMessageBuffer {\n    constructor(encoding = 'utf-8') {\n        this._encoding = encoding;\n        this._chunks = [];\n        this._totalLength = 0;\n    }\n    get encoding() {\n        return this._encoding;\n    }\n    append(chunk) {\n        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;\n        this._chunks.push(toAppend);\n        this._totalLength += toAppend.byteLength;\n    }\n    tryReadHeaders() {\n        if (this._chunks.length === 0) {\n            return undefined;\n        }\n        let state = 0;\n        let chunkIndex = 0;\n        let offset = 0;\n        let chunkBytesRead = 0;\n        row: while (chunkIndex < this._chunks.length) {\n            const chunk = this._chunks[chunkIndex];\n            offset = 0;\n            column: while (offset < chunk.length) {\n                const value = chunk[offset];\n                switch (value) {\n                    case CR:\n                        switch (state) {\n                            case 0:\n                                state = 1;\n                                break;\n                            case 2:\n                                state = 3;\n                                break;\n                            default:\n                                state = 0;\n                        }\n                        break;\n                    case LF:\n                        switch (state) {\n                            case 1:\n                                state = 2;\n                                break;\n                            case 3:\n                                state = 4;\n                                offset++;\n                                break row;\n                            default:\n                                state = 0;\n                        }\n                        break;\n                    default:\n                        state = 0;\n                }\n                offset++;\n            }\n            chunkBytesRead += chunk.byteLength;\n            chunkIndex++;\n        }\n        if (state !== 4) {\n            return undefined;\n        }\n        // The buffer contains the two CRLF at the end. So we will\n        // have two empty lines after the split at the end as well.\n        const buffer = this._read(chunkBytesRead + offset);\n        const result = new Map();\n        const headers = this.toString(buffer, 'ascii').split(CRLF);\n        if (headers.length < 2) {\n            return result;\n        }\n        for (let i = 0; i < headers.length - 2; i++) {\n            const header = headers[i];\n            const index = header.indexOf(':');\n            if (index === -1) {\n                throw new Error('Message header must separate key and value using :');\n            }\n            const key = header.substr(0, index);\n            const value = header.substr(index + 1).trim();\n            result.set(key, value);\n        }\n        return result;\n    }\n    tryReadBody(length) {\n        if (this._totalLength < length) {\n            return undefined;\n        }\n        return this._read(length);\n    }\n    get numberOfBytes() {\n        return this._totalLength;\n    }\n    _read(byteCount) {\n        if (byteCount === 0) {\n            return this.emptyBuffer();\n        }\n        if (byteCount > this._totalLength) {\n            throw new Error(`Cannot read so many bytes!`);\n        }\n        if (this._chunks[0].byteLength === byteCount) {\n            // super fast path, precisely first chunk must be returned\n            const chunk = this._chunks[0];\n            this._chunks.shift();\n            this._totalLength -= byteCount;\n            return this.asNative(chunk);\n        }\n        if (this._chunks[0].byteLength > byteCount) {\n            // fast path, the reading is entirely within the first chunk\n            const chunk = this._chunks[0];\n            const result = this.asNative(chunk, byteCount);\n            this._chunks[0] = chunk.slice(byteCount);\n            this._totalLength -= byteCount;\n            return result;\n        }\n        const result = this.allocNative(byteCount);\n        let resultOffset = 0;\n        let chunkIndex = 0;\n        while (byteCount > 0) {\n            const chunk = this._chunks[chunkIndex];\n            if (chunk.byteLength > byteCount) {\n                // this chunk will survive\n                const chunkPart = chunk.slice(0, byteCount);\n                result.set(chunkPart, resultOffset);\n                resultOffset += byteCount;\n                this._chunks[chunkIndex] = chunk.slice(byteCount);\n                this._totalLength -= byteCount;\n                byteCount -= byteCount;\n            }\n            else {\n                // this chunk will be entirely read\n                result.set(chunk, resultOffset);\n                resultOffset += chunk.byteLength;\n                this._chunks.shift();\n                this._totalLength -= chunk.byteLength;\n                byteCount -= chunk.byteLength;\n            }\n        }\n        return result;\n    }\n}\nexports.AbstractMessageBuffer = AbstractMessageBuffer;\n//# sourceMappingURL=messageBuffer.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script"}