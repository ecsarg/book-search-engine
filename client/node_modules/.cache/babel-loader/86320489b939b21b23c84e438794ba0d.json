{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isFederationType = exports.federationTypes = exports.serviceField = exports.entitiesField = exports.AnyType = exports.ServiceType = exports.EntityType = void 0;\n\nconst graphql_1 = require(\"graphql\");\n\nexports.EntityType = new graphql_1.GraphQLUnionType({\n  name: '_Entity',\n  types: []\n});\nexports.ServiceType = new graphql_1.GraphQLObjectType({\n  name: '_Service',\n  fields: {\n    sdl: {\n      type: graphql_1.GraphQLString,\n      description: 'The sdl representing the federated service capabilities. Includes federation directives, removes federation types, and includes rest of full schema after schema directives have been applied'\n    }\n  }\n});\nexports.AnyType = new graphql_1.GraphQLScalarType({\n  name: '_Any',\n\n  serialize(value) {\n    return value;\n  }\n\n});\n\nfunction isPromise(value) {\n  return Boolean(value && 'then' in value && typeof value.then === 'function');\n}\n\nfunction addTypeNameToPossibleReturn(maybeObject, typename) {\n  if (maybeObject !== null && typeof maybeObject === 'object') {\n    Object.defineProperty(maybeObject, '__typename', {\n      value: typename\n    });\n  }\n\n  return maybeObject;\n}\n\nexports.entitiesField = {\n  type: new graphql_1.GraphQLNonNull(new graphql_1.GraphQLList(exports.EntityType)),\n  args: {\n    representations: {\n      type: new graphql_1.GraphQLNonNull(new graphql_1.GraphQLList(new graphql_1.GraphQLNonNull(exports.AnyType)))\n    }\n  },\n\n  resolve(_source, {\n    representations\n  }, context, info) {\n    return representations.map(reference => {\n      const {\n        __typename\n      } = reference;\n      const type = info.schema.getType(__typename);\n\n      if (!type || !graphql_1.isObjectType(type)) {\n        throw new Error(`The _entities resolver tried to load an entity for type \"${__typename}\", but no object type of that name was found in the schema`);\n      }\n\n      const resolveReference = type.resolveReference ? type.resolveReference : function defaultResolveReference() {\n        return reference;\n      };\n      const result = resolveReference(reference, context, info);\n\n      if (isPromise(result)) {\n        return result.then(x => addTypeNameToPossibleReturn(x, __typename));\n      }\n\n      return addTypeNameToPossibleReturn(result, __typename);\n    });\n  }\n\n};\nexports.serviceField = {\n  type: new graphql_1.GraphQLNonNull(exports.ServiceType)\n};\nexports.federationTypes = [exports.ServiceType, exports.AnyType, exports.EntityType];\n\nfunction isFederationType(type) {\n  return graphql_1.isNamedType(type) && exports.federationTypes.some(({\n    name\n  }) => name === type.name);\n}\n\nexports.isFederationType = isFederationType;","map":{"version":3,"sources":["../src/types.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isFederationType = exports.federationTypes = exports.serviceField = exports.entitiesField = exports.AnyType = exports.ServiceType = exports.EntityType = void 0;\nconst graphql_1 = require(\"graphql\");\nexports.EntityType = new graphql_1.GraphQLUnionType({\n    name: '_Entity',\n    types: [],\n});\nexports.ServiceType = new graphql_1.GraphQLObjectType({\n    name: '_Service',\n    fields: {\n        sdl: {\n            type: graphql_1.GraphQLString,\n            description: 'The sdl representing the federated service capabilities. Includes federation directives, removes federation types, and includes rest of full schema after schema directives have been applied',\n        },\n    },\n});\nexports.AnyType = new graphql_1.GraphQLScalarType({\n    name: '_Any',\n    serialize(value) {\n        return value;\n    },\n});\nfunction isPromise(value) {\n    return Boolean(value && 'then' in value && typeof value.then === 'function');\n}\nfunction addTypeNameToPossibleReturn(maybeObject, typename) {\n    if (maybeObject !== null && typeof maybeObject === 'object') {\n        Object.defineProperty(maybeObject, '__typename', {\n            value: typename,\n        });\n    }\n    return maybeObject;\n}\nexports.entitiesField = {\n    type: new graphql_1.GraphQLNonNull(new graphql_1.GraphQLList(exports.EntityType)),\n    args: {\n        representations: {\n            type: new graphql_1.GraphQLNonNull(new graphql_1.GraphQLList(new graphql_1.GraphQLNonNull(exports.AnyType))),\n        },\n    },\n    resolve(_source, { representations }, context, info) {\n        return representations.map((reference) => {\n            const { __typename } = reference;\n            const type = info.schema.getType(__typename);\n            if (!type || !graphql_1.isObjectType(type)) {\n                throw new Error(`The _entities resolver tried to load an entity for type \"${__typename}\", but no object type of that name was found in the schema`);\n            }\n            const resolveReference = type.resolveReference\n                ? type.resolveReference\n                : function defaultResolveReference() {\n                    return reference;\n                };\n            const result = resolveReference(reference, context, info);\n            if (isPromise(result)) {\n                return result.then((x) => addTypeNameToPossibleReturn(x, __typename));\n            }\n            return addTypeNameToPossibleReturn(result, __typename);\n        });\n    },\n};\nexports.serviceField = {\n    type: new graphql_1.GraphQLNonNull(exports.ServiceType),\n};\nexports.federationTypes = [\n    exports.ServiceType,\n    exports.AnyType,\n    exports.EntityType,\n];\nfunction isFederationType(type) {\n    return (graphql_1.isNamedType(type) && exports.federationTypes.some(({ name }) => name === type.name));\n}\nexports.isFederationType = isFederationType;\n//# sourceMappingURL=types.js.map"]},"metadata":{},"sourceType":"script"}