{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.externalUnused = void 0;\n\nconst graphql_1 = require(\"graphql\");\n\nconst utils_1 = require(\"../../utils\");\n\nconst externalUnused = ({\n  schema\n}) => {\n  const errors = [];\n  const types = schema.getTypeMap();\n\n  for (const [parentTypeName, parentType] of Object.entries(types)) {\n    if (!graphql_1.isObjectType(parentType)) continue;\n    const typeFederationMetadata = utils_1.getFederationMetadata(parentType);\n\n    if (typeFederationMetadata) {\n      const {\n        serviceName,\n        keys\n      } = typeFederationMetadata;\n      if (serviceName && keys && !keys[serviceName]) continue;\n    }\n\n    if (typeFederationMetadata === null || typeFederationMetadata === void 0 ? void 0 : typeFederationMetadata.externals) {\n      for (const [serviceName, externalFieldsForService] of Object.entries(typeFederationMetadata.externals)) {\n        for (const {\n          field: externalField\n        } of externalFieldsForService) {\n          const externalFieldName = externalField.name.value;\n          const hasMatchingKeyOnType = Boolean(utils_1.hasMatchingFieldInDirectives({\n            directives: utils_1.findDirectivesOnNode(parentType.astNode, 'key'),\n            fieldNameToMatch: externalFieldName,\n            namedType: parentType\n          }));\n          if (hasMatchingKeyOnType) continue;\n          const hasMatchingProvidesOnAnotherType = utils_1.findFieldsThatReturnType({\n            schema,\n            typeToFind: parentType\n          }).some(field => utils_1.findDirectivesOnNode(field.astNode, 'provides').some(directive => {\n            if (!directive.arguments) return false;\n            const selections = utils_1.isStringValueNode(directive.arguments[0].value) && utils_1.parseSelections(directive.arguments[0].value.value);\n            return selections && selections.some(selection => selection.kind === graphql_1.Kind.FIELD && selection.name.value === externalFieldName);\n          }));\n          if (hasMatchingProvidesOnAnotherType) continue;\n          const hasMatchingRequiresOnAnotherType = Object.values(schema.getTypeMap()).some(namedType => {\n            if (!graphql_1.isObjectType(namedType)) return false;\n            return Object.values(namedType.getFields()).some(field => utils_1.findDirectivesOnNode(field.astNode, 'requires').some(directive => {\n              if (!directive.arguments) return false;\n              const selections = utils_1.isStringValueNode(directive.arguments[0].value) && utils_1.parseSelections(directive.arguments[0].value.value);\n              if (!selections) return false;\n              return utils_1.selectionIncludesField({\n                selections,\n                selectionSetType: namedType,\n                typeToFind: parentType,\n                fieldToFind: externalFieldName\n              });\n            }));\n          });\n          if (hasMatchingRequiresOnAnotherType) continue;\n          const hasMatchingRequiresOnType = Object.values(parentType.getFields()).some(maybeRequiresField => {\n            var _a;\n\n            const fieldOwner = (_a = utils_1.getFederationMetadata(maybeRequiresField)) === null || _a === void 0 ? void 0 : _a.serviceName;\n            if (fieldOwner !== serviceName) return false;\n            const requiresDirectives = utils_1.findDirectivesOnNode(maybeRequiresField.astNode, 'requires');\n            return utils_1.hasMatchingFieldInDirectives({\n              directives: requiresDirectives,\n              fieldNameToMatch: externalFieldName,\n              namedType: parentType\n            });\n          });\n          if (hasMatchingRequiresOnType) continue;\n          const fieldsOnInterfacesImplementedByParentType = new Set();\n\n          for (const _interface of parentType.getInterfaces()) {\n            for (const fieldName in _interface.getFields()) {\n              fieldsOnInterfacesImplementedByParentType.add(fieldName);\n            }\n          }\n\n          if (fieldsOnInterfacesImplementedByParentType.has(externalFieldName)) {\n            continue;\n          }\n\n          errors.push(utils_1.errorWithCode('EXTERNAL_UNUSED', utils_1.logServiceAndType(serviceName, parentTypeName, externalFieldName) + `is marked as @external but is not used by a @requires, @key, or @provides directive.`, utils_1.findDirectivesOnNode(externalField, 'external')));\n        }\n      }\n    }\n  }\n\n  return errors;\n};\n\nexports.externalUnused = externalUnused;","map":{"version":3,"sources":["../../../../src/composition/validate/postComposition/externalUnused.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.externalUnused = void 0;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"../../utils\");\nconst externalUnused = ({ schema }) => {\n    const errors = [];\n    const types = schema.getTypeMap();\n    for (const [parentTypeName, parentType] of Object.entries(types)) {\n        if (!graphql_1.isObjectType(parentType))\n            continue;\n        const typeFederationMetadata = utils_1.getFederationMetadata(parentType);\n        if (typeFederationMetadata) {\n            const { serviceName, keys } = typeFederationMetadata;\n            if (serviceName && keys && !keys[serviceName])\n                continue;\n        }\n        if (typeFederationMetadata === null || typeFederationMetadata === void 0 ? void 0 : typeFederationMetadata.externals) {\n            for (const [serviceName, externalFieldsForService] of Object.entries(typeFederationMetadata.externals)) {\n                for (const { field: externalField } of externalFieldsForService) {\n                    const externalFieldName = externalField.name.value;\n                    const hasMatchingKeyOnType = Boolean(utils_1.hasMatchingFieldInDirectives({\n                        directives: utils_1.findDirectivesOnNode(parentType.astNode, 'key'),\n                        fieldNameToMatch: externalFieldName,\n                        namedType: parentType,\n                    }));\n                    if (hasMatchingKeyOnType)\n                        continue;\n                    const hasMatchingProvidesOnAnotherType = utils_1.findFieldsThatReturnType({\n                        schema,\n                        typeToFind: parentType,\n                    }).some(field => utils_1.findDirectivesOnNode(field.astNode, 'provides').some(directive => {\n                        if (!directive.arguments)\n                            return false;\n                        const selections = utils_1.isStringValueNode(directive.arguments[0].value) &&\n                            utils_1.parseSelections(directive.arguments[0].value.value);\n                        return (selections &&\n                            selections.some(selection => selection.kind === graphql_1.Kind.FIELD &&\n                                selection.name.value === externalFieldName));\n                    }));\n                    if (hasMatchingProvidesOnAnotherType)\n                        continue;\n                    const hasMatchingRequiresOnAnotherType = Object.values(schema.getTypeMap()).some(namedType => {\n                        if (!graphql_1.isObjectType(namedType))\n                            return false;\n                        return Object.values(namedType.getFields()).some(field => utils_1.findDirectivesOnNode(field.astNode, 'requires').some(directive => {\n                            if (!directive.arguments)\n                                return false;\n                            const selections = utils_1.isStringValueNode(directive.arguments[0].value) &&\n                                utils_1.parseSelections(directive.arguments[0].value.value);\n                            if (!selections)\n                                return false;\n                            return utils_1.selectionIncludesField({\n                                selections,\n                                selectionSetType: namedType,\n                                typeToFind: parentType,\n                                fieldToFind: externalFieldName,\n                            });\n                        }));\n                    });\n                    if (hasMatchingRequiresOnAnotherType)\n                        continue;\n                    const hasMatchingRequiresOnType = Object.values(parentType.getFields()).some(maybeRequiresField => {\n                        var _a;\n                        const fieldOwner = (_a = utils_1.getFederationMetadata(maybeRequiresField)) === null || _a === void 0 ? void 0 : _a.serviceName;\n                        if (fieldOwner !== serviceName)\n                            return false;\n                        const requiresDirectives = utils_1.findDirectivesOnNode(maybeRequiresField.astNode, 'requires');\n                        return utils_1.hasMatchingFieldInDirectives({\n                            directives: requiresDirectives,\n                            fieldNameToMatch: externalFieldName,\n                            namedType: parentType,\n                        });\n                    });\n                    if (hasMatchingRequiresOnType)\n                        continue;\n                    const fieldsOnInterfacesImplementedByParentType = new Set();\n                    for (const _interface of parentType.getInterfaces()) {\n                        for (const fieldName in _interface.getFields()) {\n                            fieldsOnInterfacesImplementedByParentType.add(fieldName);\n                        }\n                    }\n                    if (fieldsOnInterfacesImplementedByParentType.has(externalFieldName)) {\n                        continue;\n                    }\n                    errors.push(utils_1.errorWithCode('EXTERNAL_UNUSED', utils_1.logServiceAndType(serviceName, parentTypeName, externalFieldName) +\n                        `is marked as @external but is not used by a @requires, @key, or @provides directive.`, utils_1.findDirectivesOnNode(externalField, 'external')));\n                }\n            }\n        }\n    }\n    return errors;\n};\nexports.externalUnused = externalUnused;\n//# sourceMappingURL=externalUnused.js.map"]},"metadata":{},"sourceType":"script"}