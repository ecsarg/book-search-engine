{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.keysMatchBaseService = void 0;\n\nconst graphql_1 = require(\"graphql\");\n\nconst utils_1 = require(\"../../utils\");\n\nconst keysMatchBaseService = function ({\n  schema,\n  serviceList\n}) {\n  const errors = [];\n  const types = schema.getTypeMap();\n\n  for (const [parentTypeName, parentType] of Object.entries(types)) {\n    if (!graphql_1.isObjectType(parentType)) continue;\n    const typeFederationMetadata = utils_1.getFederationMetadata(parentType);\n\n    if (typeFederationMetadata) {\n      const {\n        serviceName,\n        keys\n      } = typeFederationMetadata;\n\n      if (serviceName && keys) {\n        if (!keys[serviceName]) {\n          errors.push(utils_1.errorWithCode('KEY_MISSING_ON_BASE', utils_1.logServiceAndType(serviceName, parentTypeName) + `appears to be an entity but no @key directives are specified on the originating type.`, utils_1.findTypeNodeInServiceList(parentTypeName, serviceName, serviceList)));\n          continue;\n        }\n\n        const availableKeys = (keys[serviceName] || []).map(utils_1.printFieldSet);\n        Object.entries(keys).filter(([service]) => service !== serviceName).forEach(([extendingService, keyFields = []]) => {\n          const extendingServiceTypeNode = utils_1.findTypeNodeInServiceList(parentTypeName, extendingService, serviceList);\n\n          if (keyFields.length > 1) {\n            errors.push(utils_1.errorWithCode('MULTIPLE_KEYS_ON_EXTENSION', utils_1.logServiceAndType(extendingService, parentTypeName) + `is extended from service ${serviceName} but specifies multiple @key directives. Extensions may only specify one @key.`, extendingServiceTypeNode));\n            return;\n          }\n\n          const extensionKey = utils_1.printFieldSet(keyFields[0]);\n          const selectionSetNode = !utils_1.isDirectiveDefinitionNode(extendingServiceTypeNode) ? utils_1.findSelectionSetOnNode(extendingServiceTypeNode, 'key', extensionKey) : undefined;\n\n          if (!availableKeys.includes(extensionKey)) {\n            errors.push(utils_1.errorWithCode('KEY_NOT_SPECIFIED', utils_1.logServiceAndType(extendingService, parentTypeName) + `extends from ${serviceName} but specifies an invalid @key directive. Valid @key directives are specified by the originating type. Available @key directives for this type are:\\n` + `\\t${availableKeys.map(fieldSet => `@key(fields: \"${fieldSet}\")`).join('\\n\\t')}`, selectionSetNode));\n            return;\n          }\n        });\n      }\n    }\n  }\n\n  return errors;\n};\n\nexports.keysMatchBaseService = keysMatchBaseService;","map":{"version":3,"sources":["../../../../src/composition/validate/postComposition/keysMatchBaseService.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,SAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AAIA,MAAA,OAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AAgBO,MAAM,oBAAoB,GAA6B,UAAU;EACtE,MADsE;EAEtE;AAFsE,CAAV,EAG7D;EACC,MAAM,MAAM,GAAmB,EAA/B;EACA,MAAM,KAAK,GAAG,MAAM,CAAC,UAAP,EAAd;;EACA,KAAK,MAAM,CAAC,cAAD,EAAiB,UAAjB,CAAX,IAA2C,MAAM,CAAC,OAAP,CAAe,KAAf,CAA3C,EAAkE;IAEhE,IAAI,CAAC,SAAA,CAAA,YAAA,CAAa,UAAb,CAAL,EAA+B;IAE/B,MAAM,sBAAsB,GAAG,OAAA,CAAA,qBAAA,CAAsB,UAAtB,CAA/B;;IAEA,IAAI,sBAAJ,EAA4B;MAC1B,MAAM;QAAE,WAAF;QAAe;MAAf,IAAwB,sBAA9B;;MAEA,IAAI,WAAW,IAAI,IAAnB,EAAyB;QACvB,IAAI,CAAC,IAAI,CAAC,WAAD,CAAT,EAAwB;UACtB,MAAM,CAAC,IAAP,CACE,OAAA,CAAA,aAAA,CACE,qBADF,EAEE,OAAA,CAAA,iBAAA,CAAkB,WAAlB,EAA+B,cAA/B,IACE,uFAHJ,EAIE,OAAA,CAAA,yBAAA,CAA0B,cAA1B,EAA0C,WAA1C,EAAuD,WAAvD,CAJF,CADF;UAQA;QACD;;QAED,MAAM,aAAa,GAAG,CAAC,IAAI,CAAC,WAAD,CAAJ,IAAqB,EAAtB,EAA0B,GAA1B,CAA8B,OAAA,CAAA,aAA9B,CAAtB;QACA,MAAM,CAAC,OAAP,CAAe,IAAf,EAEG,MAFH,CAEU,CAAC,CAAC,OAAD,CAAD,KAAe,OAAO,KAAK,WAFrC,EAGG,OAHH,CAGW,CAAC,CAAC,gBAAD,EAAmB,SAAS,GAAG,EAA/B,CAAD,KAAuC;UAE9C,MAAM,wBAAwB,GAAG,OAAA,CAAA,yBAAA,CAA0B,cAA1B,EAA0C,gBAA1C,EAA4D,WAA5D,CAAjC;;UACA,IAAI,SAAS,CAAC,MAAV,GAAmB,CAAvB,EAA0B;YACxB,MAAM,CAAC,IAAP,CACE,OAAA,CAAA,aAAA,CACE,4BADF,EAEE,OAAA,CAAA,iBAAA,CAAkB,gBAAlB,EAAoC,cAApC,IACE,4BAA4B,WAAW,gFAH3C,EAIE,wBAJF,CADF;YAQA;UACD;;UAMD,MAAM,YAAY,GAAG,OAAA,CAAA,aAAA,CAAc,SAAS,CAAC,CAAD,CAAvB,CAArB;UACA,MAAM,gBAAgB,GAAG,CAAC,OAAA,CAAA,yBAAA,CAA0B,wBAA1B,CAAD,GACvB,OAAA,CAAA,sBAAA,CAAuB,wBAAvB,EAAiD,KAAjD,EAAwD,YAAxD,CADuB,GACiD,SAD1E;;UAEA,IAAI,CAAC,aAAa,CAAC,QAAd,CAAuB,YAAvB,CAAL,EAA2C;YACzC,MAAM,CAAC,IAAP,CACE,OAAA,CAAA,aAAA,CACE,mBADF,EAEE,OAAA,CAAA,iBAAA,CAAkB,gBAAlB,EAAoC,cAApC,IACE,gBAAgB,WAAW,uJAD7B,GAEE,KAAK,aAAa,CACf,GADE,CACG,QAAD,IAAc,iBAAiB,QAAQ,IADzC,EAEF,IAFE,CAEG,MAFH,CAEU,EANnB,EAOE,gBAPF,CADF;YAWA;UACD;QACF,CAvCH;MAwCD;IACF;EACF;;EAED,OAAO,MAAP;AACD,CA1EM;;AAAM,OAAA,CAAA,oBAAA,GAAoB,oBAApB","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.keysMatchBaseService = void 0;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"../../utils\");\nconst keysMatchBaseService = function ({ schema, serviceList, }) {\n    const errors = [];\n    const types = schema.getTypeMap();\n    for (const [parentTypeName, parentType] of Object.entries(types)) {\n        if (!graphql_1.isObjectType(parentType))\n            continue;\n        const typeFederationMetadata = utils_1.getFederationMetadata(parentType);\n        if (typeFederationMetadata) {\n            const { serviceName, keys } = typeFederationMetadata;\n            if (serviceName && keys) {\n                if (!keys[serviceName]) {\n                    errors.push(utils_1.errorWithCode('KEY_MISSING_ON_BASE', utils_1.logServiceAndType(serviceName, parentTypeName) +\n                        `appears to be an entity but no @key directives are specified on the originating type.`, utils_1.findTypeNodeInServiceList(parentTypeName, serviceName, serviceList)));\n                    continue;\n                }\n                const availableKeys = (keys[serviceName] || []).map(utils_1.printFieldSet);\n                Object.entries(keys)\n                    .filter(([service]) => service !== serviceName)\n                    .forEach(([extendingService, keyFields = []]) => {\n                    const extendingServiceTypeNode = utils_1.findTypeNodeInServiceList(parentTypeName, extendingService, serviceList);\n                    if (keyFields.length > 1) {\n                        errors.push(utils_1.errorWithCode('MULTIPLE_KEYS_ON_EXTENSION', utils_1.logServiceAndType(extendingService, parentTypeName) +\n                            `is extended from service ${serviceName} but specifies multiple @key directives. Extensions may only specify one @key.`, extendingServiceTypeNode));\n                        return;\n                    }\n                    const extensionKey = utils_1.printFieldSet(keyFields[0]);\n                    const selectionSetNode = !utils_1.isDirectiveDefinitionNode(extendingServiceTypeNode) ?\n                        utils_1.findSelectionSetOnNode(extendingServiceTypeNode, 'key', extensionKey) : undefined;\n                    if (!availableKeys.includes(extensionKey)) {\n                        errors.push(utils_1.errorWithCode('KEY_NOT_SPECIFIED', utils_1.logServiceAndType(extendingService, parentTypeName) +\n                            `extends from ${serviceName} but specifies an invalid @key directive. Valid @key directives are specified by the originating type. Available @key directives for this type are:\\n` +\n                            `\\t${availableKeys\n                                .map((fieldSet) => `@key(fields: \"${fieldSet}\")`)\n                                .join('\\n\\t')}`, selectionSetNode));\n                        return;\n                    }\n                });\n            }\n        }\n    }\n    return errors;\n};\nexports.keysMatchBaseService = keysMatchBaseService;\n//# sourceMappingURL=keysMatchBaseService.js.map"]},"metadata":{},"sourceType":"script"}