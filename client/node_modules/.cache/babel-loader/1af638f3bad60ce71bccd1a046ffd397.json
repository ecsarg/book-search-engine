{"ast":null,"code":"var fs = require('fs');\n\nvar path = require('path');\n\nvar common = require('./common');\n\ncommon.register('cp', _cp, {\n  cmdOptions: {\n    'f': '!no_force',\n    'n': 'no_force',\n    'u': 'update',\n    'R': 'recursive',\n    'r': 'recursive',\n    'L': 'followsymlink',\n    'P': 'noFollowsymlink'\n  },\n  wrapOutput: false\n}); // Buffered file copy, synchronous\n// (Using readFileSync() + writeFileSync() could easily cause a memory overflow\n//  with large files)\n\nfunction copyFileSync(srcFile, destFile, options) {\n  if (!fs.existsSync(srcFile)) {\n    common.error('copyFileSync: no such file or directory: ' + srcFile);\n  }\n\n  var isWindows = process.platform === 'win32'; // Check the mtimes of the files if the '-u' flag is provided\n\n  try {\n    if (options.update && common.statFollowLinks(srcFile).mtime < fs.statSync(destFile).mtime) {\n      return;\n    }\n  } catch (e) {// If we're here, destFile probably doesn't exist, so just do a normal copy\n  }\n\n  if (common.statNoFollowLinks(srcFile).isSymbolicLink() && !options.followsymlink) {\n    try {\n      common.statNoFollowLinks(destFile);\n      common.unlinkSync(destFile); // re-link it\n    } catch (e) {// it doesn't exist, so no work needs to be done\n    }\n\n    var symlinkFull = fs.readlinkSync(srcFile);\n    fs.symlinkSync(symlinkFull, destFile, isWindows ? 'junction' : null);\n  } else {\n    var buf = common.buffer();\n    var bufLength = buf.length;\n    var bytesRead = bufLength;\n    var pos = 0;\n    var fdr = null;\n    var fdw = null;\n\n    try {\n      fdr = fs.openSync(srcFile, 'r');\n    } catch (e) {\n      /* istanbul ignore next */\n      common.error('copyFileSync: could not read src file (' + srcFile + ')');\n    }\n\n    try {\n      fdw = fs.openSync(destFile, 'w');\n    } catch (e) {\n      /* istanbul ignore next */\n      common.error('copyFileSync: could not write to dest file (code=' + e.code + '):' + destFile);\n    }\n\n    while (bytesRead === bufLength) {\n      bytesRead = fs.readSync(fdr, buf, 0, bufLength, pos);\n      fs.writeSync(fdw, buf, 0, bytesRead);\n      pos += bytesRead;\n    }\n\n    fs.closeSync(fdr);\n    fs.closeSync(fdw);\n    fs.chmodSync(destFile, common.statFollowLinks(srcFile).mode);\n  }\n} // Recursively copies 'sourceDir' into 'destDir'\n// Adapted from https://github.com/ryanmcgrath/wrench-js\n//\n// Copyright (c) 2010 Ryan McGrath\n// Copyright (c) 2012 Artur Adib\n//\n// Licensed under the MIT License\n// http://www.opensource.org/licenses/mit-license.php\n\n\nfunction cpdirSyncRecursive(sourceDir, destDir, currentDepth, opts) {\n  if (!opts) opts = {}; // Ensure there is not a run away recursive copy\n\n  if (currentDepth >= common.config.maxdepth) return;\n  currentDepth++;\n  var isWindows = process.platform === 'win32'; // Create the directory where all our junk is moving to; read the mode of the\n  // source directory and mirror it\n\n  try {\n    fs.mkdirSync(destDir);\n  } catch (e) {\n    // if the directory already exists, that's okay\n    if (e.code !== 'EEXIST') throw e;\n  }\n\n  var files = fs.readdirSync(sourceDir);\n\n  for (var i = 0; i < files.length; i++) {\n    var srcFile = sourceDir + '/' + files[i];\n    var destFile = destDir + '/' + files[i];\n    var srcFileStat = common.statNoFollowLinks(srcFile);\n    var symlinkFull;\n\n    if (opts.followsymlink) {\n      if (cpcheckcycle(sourceDir, srcFile)) {\n        // Cycle link found.\n        console.error('Cycle link found.');\n        symlinkFull = fs.readlinkSync(srcFile);\n        fs.symlinkSync(symlinkFull, destFile, isWindows ? 'junction' : null);\n        continue;\n      }\n    }\n\n    if (srcFileStat.isDirectory()) {\n      /* recursion this thing right on back. */\n      cpdirSyncRecursive(srcFile, destFile, currentDepth, opts);\n    } else if (srcFileStat.isSymbolicLink() && !opts.followsymlink) {\n      symlinkFull = fs.readlinkSync(srcFile);\n\n      try {\n        common.statNoFollowLinks(destFile);\n        common.unlinkSync(destFile); // re-link it\n      } catch (e) {// it doesn't exist, so no work needs to be done\n      }\n\n      fs.symlinkSync(symlinkFull, destFile, isWindows ? 'junction' : null);\n    } else if (srcFileStat.isSymbolicLink() && opts.followsymlink) {\n      srcFileStat = common.statFollowLinks(srcFile);\n\n      if (srcFileStat.isDirectory()) {\n        cpdirSyncRecursive(srcFile, destFile, currentDepth, opts);\n      } else {\n        copyFileSync(srcFile, destFile, opts);\n      }\n    } else {\n      /* At this point, we've hit a file actually worth copying... so copy it on over. */\n      if (fs.existsSync(destFile) && opts.no_force) {\n        common.log('skipping existing file: ' + files[i]);\n      } else {\n        copyFileSync(srcFile, destFile, opts);\n      }\n    }\n  } // for files\n  // finally change the mode for the newly created directory (otherwise, we\n  // couldn't add files to a read-only directory).\n\n\n  var checkDir = common.statFollowLinks(sourceDir);\n  fs.chmodSync(destDir, checkDir.mode);\n} // cpdirSyncRecursive\n// Checks if cureent file was created recently\n\n\nfunction checkRecentCreated(sources, index) {\n  var lookedSource = sources[index];\n  return sources.slice(0, index).some(function (src) {\n    return path.basename(src) === path.basename(lookedSource);\n  });\n}\n\nfunction cpcheckcycle(sourceDir, srcFile) {\n  var srcFileStat = common.statNoFollowLinks(srcFile);\n\n  if (srcFileStat.isSymbolicLink()) {\n    // Do cycle check. For example:\n    //   $ mkdir -p 1/2/3/4\n    //   $ cd  1/2/3/4\n    //   $ ln -s ../../3 link\n    //   $ cd ../../../..\n    //   $ cp -RL 1 copy\n    var cyclecheck = common.statFollowLinks(srcFile);\n\n    if (cyclecheck.isDirectory()) {\n      var sourcerealpath = fs.realpathSync(sourceDir);\n      var symlinkrealpath = fs.realpathSync(srcFile);\n      var re = new RegExp(symlinkrealpath);\n\n      if (re.test(sourcerealpath)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n} //@\n//@ ### cp([options,] source [, source ...], dest)\n//@ ### cp([options,] source_array, dest)\n//@\n//@ Available options:\n//@\n//@ + `-f`: force (default behavior)\n//@ + `-n`: no-clobber\n//@ + `-u`: only copy if `source` is newer than `dest`\n//@ + `-r`, `-R`: recursive\n//@ + `-L`: follow symlinks\n//@ + `-P`: don't follow symlinks\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ cp('file1', 'dir1');\n//@ cp('-R', 'path/to/dir/', '~/newCopy/');\n//@ cp('-Rf', '/tmp/*', '/usr/local/*', '/home/tmp');\n//@ cp('-Rf', ['/tmp/*', '/usr/local/*'], '/home/tmp'); // same as above\n//@ ```\n//@\n//@ Copies files.\n\n\nfunction _cp(options, sources, dest) {\n  // If we're missing -R, it actually implies -L (unless -P is explicit)\n  if (options.followsymlink) {\n    options.noFollowsymlink = false;\n  }\n\n  if (!options.recursive && !options.noFollowsymlink) {\n    options.followsymlink = true;\n  } // Get sources, dest\n\n\n  if (arguments.length < 3) {\n    common.error('missing <source> and/or <dest>');\n  } else {\n    sources = [].slice.call(arguments, 1, arguments.length - 1);\n    dest = arguments[arguments.length - 1];\n  }\n\n  var destExists = fs.existsSync(dest);\n  var destStat = destExists && common.statFollowLinks(dest); // Dest is not existing dir, but multiple sources given\n\n  if ((!destExists || !destStat.isDirectory()) && sources.length > 1) {\n    common.error('dest is not a directory (too many sources)');\n  } // Dest is an existing file, but -n is given\n\n\n  if (destExists && destStat.isFile() && options.no_force) {\n    return new common.ShellString('', '', 0);\n  }\n\n  sources.forEach(function (src, srcIndex) {\n    if (!fs.existsSync(src)) {\n      if (src === '') src = \"''\"; // if src was empty string, display empty string\n\n      common.error('no such file or directory: ' + src, {\n        continue: true\n      });\n      return; // skip file\n    }\n\n    var srcStat = common.statFollowLinks(src);\n\n    if (!options.noFollowsymlink && srcStat.isDirectory()) {\n      if (!options.recursive) {\n        // Non-Recursive\n        common.error(\"omitting directory '\" + src + \"'\", {\n          continue: true\n        });\n      } else {\n        // Recursive\n        // 'cp /a/source dest' should create 'source' in 'dest'\n        var newDest = destStat && destStat.isDirectory() ? path.join(dest, path.basename(src)) : dest;\n\n        try {\n          common.statFollowLinks(path.dirname(dest));\n          cpdirSyncRecursive(src, newDest, 0, {\n            no_force: options.no_force,\n            followsymlink: options.followsymlink\n          });\n        } catch (e) {\n          /* istanbul ignore next */\n          common.error(\"cannot create directory '\" + dest + \"': No such file or directory\");\n        }\n      }\n    } else {\n      // If here, src is a file\n      // When copying to '/path/dir':\n      //    thisDest = '/path/dir/file1'\n      var thisDest = dest;\n\n      if (destStat && destStat.isDirectory()) {\n        thisDest = path.normalize(dest + '/' + path.basename(src));\n      }\n\n      var thisDestExists = fs.existsSync(thisDest);\n\n      if (thisDestExists && checkRecentCreated(sources, srcIndex)) {\n        // cannot overwrite file created recently in current execution, but we want to continue copying other files\n        if (!options.no_force) {\n          common.error(\"will not overwrite just-created '\" + thisDest + \"' with '\" + src + \"'\", {\n            continue: true\n          });\n        }\n\n        return;\n      }\n\n      if (thisDestExists && options.no_force) {\n        return; // skip file\n      }\n\n      if (path.relative(src, thisDest) === '') {\n        // a file cannot be copied to itself, but we want to continue copying other files\n        common.error(\"'\" + thisDest + \"' and '\" + src + \"' are the same file\", {\n          continue: true\n        });\n        return;\n      }\n\n      copyFileSync(src, thisDest, options);\n    }\n  }); // forEach(src)\n\n  return new common.ShellString('', common.state.error, common.state.errorCode);\n}\n\nmodule.exports = _cp;","map":{"version":3,"names":["fs","require","path","common","register","_cp","cmdOptions","wrapOutput","copyFileSync","srcFile","destFile","options","existsSync","error","isWindows","process","platform","update","statFollowLinks","mtime","statSync","e","statNoFollowLinks","isSymbolicLink","followsymlink","unlinkSync","symlinkFull","readlinkSync","symlinkSync","buf","buffer","bufLength","length","bytesRead","pos","fdr","fdw","openSync","code","readSync","writeSync","closeSync","chmodSync","mode","cpdirSyncRecursive","sourceDir","destDir","currentDepth","opts","config","maxdepth","mkdirSync","files","readdirSync","i","srcFileStat","cpcheckcycle","console","isDirectory","no_force","log","checkDir","checkRecentCreated","sources","index","lookedSource","slice","some","src","basename","cyclecheck","sourcerealpath","realpathSync","symlinkrealpath","re","RegExp","test","dest","noFollowsymlink","recursive","arguments","call","destExists","destStat","isFile","ShellString","forEach","srcIndex","continue","srcStat","newDest","join","dirname","thisDest","normalize","thisDestExists","relative","state","errorCode","module","exports"],"sources":["/Users/Ellie/Desktop/projects/book-search-engine/client/node_modules/shelljs/src/cp.js"],"sourcesContent":["var fs = require('fs');\nvar path = require('path');\nvar common = require('./common');\n\ncommon.register('cp', _cp, {\n  cmdOptions: {\n    'f': '!no_force',\n    'n': 'no_force',\n    'u': 'update',\n    'R': 'recursive',\n    'r': 'recursive',\n    'L': 'followsymlink',\n    'P': 'noFollowsymlink',\n  },\n  wrapOutput: false,\n});\n\n// Buffered file copy, synchronous\n// (Using readFileSync() + writeFileSync() could easily cause a memory overflow\n//  with large files)\nfunction copyFileSync(srcFile, destFile, options) {\n  if (!fs.existsSync(srcFile)) {\n    common.error('copyFileSync: no such file or directory: ' + srcFile);\n  }\n\n  var isWindows = process.platform === 'win32';\n\n  // Check the mtimes of the files if the '-u' flag is provided\n  try {\n    if (options.update && common.statFollowLinks(srcFile).mtime < fs.statSync(destFile).mtime) {\n      return;\n    }\n  } catch (e) {\n    // If we're here, destFile probably doesn't exist, so just do a normal copy\n  }\n\n  if (common.statNoFollowLinks(srcFile).isSymbolicLink() && !options.followsymlink) {\n    try {\n      common.statNoFollowLinks(destFile);\n      common.unlinkSync(destFile); // re-link it\n    } catch (e) {\n      // it doesn't exist, so no work needs to be done\n    }\n\n    var symlinkFull = fs.readlinkSync(srcFile);\n    fs.symlinkSync(symlinkFull, destFile, isWindows ? 'junction' : null);\n  } else {\n    var buf = common.buffer();\n    var bufLength = buf.length;\n    var bytesRead = bufLength;\n    var pos = 0;\n    var fdr = null;\n    var fdw = null;\n\n    try {\n      fdr = fs.openSync(srcFile, 'r');\n    } catch (e) {\n      /* istanbul ignore next */\n      common.error('copyFileSync: could not read src file (' + srcFile + ')');\n    }\n\n    try {\n      fdw = fs.openSync(destFile, 'w');\n    } catch (e) {\n      /* istanbul ignore next */\n      common.error('copyFileSync: could not write to dest file (code=' + e.code + '):' + destFile);\n    }\n\n    while (bytesRead === bufLength) {\n      bytesRead = fs.readSync(fdr, buf, 0, bufLength, pos);\n      fs.writeSync(fdw, buf, 0, bytesRead);\n      pos += bytesRead;\n    }\n\n    fs.closeSync(fdr);\n    fs.closeSync(fdw);\n\n    fs.chmodSync(destFile, common.statFollowLinks(srcFile).mode);\n  }\n}\n\n// Recursively copies 'sourceDir' into 'destDir'\n// Adapted from https://github.com/ryanmcgrath/wrench-js\n//\n// Copyright (c) 2010 Ryan McGrath\n// Copyright (c) 2012 Artur Adib\n//\n// Licensed under the MIT License\n// http://www.opensource.org/licenses/mit-license.php\nfunction cpdirSyncRecursive(sourceDir, destDir, currentDepth, opts) {\n  if (!opts) opts = {};\n\n  // Ensure there is not a run away recursive copy\n  if (currentDepth >= common.config.maxdepth) return;\n  currentDepth++;\n\n  var isWindows = process.platform === 'win32';\n\n  // Create the directory where all our junk is moving to; read the mode of the\n  // source directory and mirror it\n  try {\n    fs.mkdirSync(destDir);\n  } catch (e) {\n    // if the directory already exists, that's okay\n    if (e.code !== 'EEXIST') throw e;\n  }\n\n  var files = fs.readdirSync(sourceDir);\n\n  for (var i = 0; i < files.length; i++) {\n    var srcFile = sourceDir + '/' + files[i];\n    var destFile = destDir + '/' + files[i];\n    var srcFileStat = common.statNoFollowLinks(srcFile);\n\n    var symlinkFull;\n    if (opts.followsymlink) {\n      if (cpcheckcycle(sourceDir, srcFile)) {\n        // Cycle link found.\n        console.error('Cycle link found.');\n        symlinkFull = fs.readlinkSync(srcFile);\n        fs.symlinkSync(symlinkFull, destFile, isWindows ? 'junction' : null);\n        continue;\n      }\n    }\n    if (srcFileStat.isDirectory()) {\n      /* recursion this thing right on back. */\n      cpdirSyncRecursive(srcFile, destFile, currentDepth, opts);\n    } else if (srcFileStat.isSymbolicLink() && !opts.followsymlink) {\n      symlinkFull = fs.readlinkSync(srcFile);\n      try {\n        common.statNoFollowLinks(destFile);\n        common.unlinkSync(destFile); // re-link it\n      } catch (e) {\n        // it doesn't exist, so no work needs to be done\n      }\n      fs.symlinkSync(symlinkFull, destFile, isWindows ? 'junction' : null);\n    } else if (srcFileStat.isSymbolicLink() && opts.followsymlink) {\n      srcFileStat = common.statFollowLinks(srcFile);\n      if (srcFileStat.isDirectory()) {\n        cpdirSyncRecursive(srcFile, destFile, currentDepth, opts);\n      } else {\n        copyFileSync(srcFile, destFile, opts);\n      }\n    } else {\n      /* At this point, we've hit a file actually worth copying... so copy it on over. */\n      if (fs.existsSync(destFile) && opts.no_force) {\n        common.log('skipping existing file: ' + files[i]);\n      } else {\n        copyFileSync(srcFile, destFile, opts);\n      }\n    }\n  } // for files\n\n  // finally change the mode for the newly created directory (otherwise, we\n  // couldn't add files to a read-only directory).\n  var checkDir = common.statFollowLinks(sourceDir);\n  fs.chmodSync(destDir, checkDir.mode);\n} // cpdirSyncRecursive\n\n// Checks if cureent file was created recently\nfunction checkRecentCreated(sources, index) {\n  var lookedSource = sources[index];\n  return sources.slice(0, index).some(function (src) {\n    return path.basename(src) === path.basename(lookedSource);\n  });\n}\n\nfunction cpcheckcycle(sourceDir, srcFile) {\n  var srcFileStat = common.statNoFollowLinks(srcFile);\n  if (srcFileStat.isSymbolicLink()) {\n    // Do cycle check. For example:\n    //   $ mkdir -p 1/2/3/4\n    //   $ cd  1/2/3/4\n    //   $ ln -s ../../3 link\n    //   $ cd ../../../..\n    //   $ cp -RL 1 copy\n    var cyclecheck = common.statFollowLinks(srcFile);\n    if (cyclecheck.isDirectory()) {\n      var sourcerealpath = fs.realpathSync(sourceDir);\n      var symlinkrealpath = fs.realpathSync(srcFile);\n      var re = new RegExp(symlinkrealpath);\n      if (re.test(sourcerealpath)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n//@\n//@ ### cp([options,] source [, source ...], dest)\n//@ ### cp([options,] source_array, dest)\n//@\n//@ Available options:\n//@\n//@ + `-f`: force (default behavior)\n//@ + `-n`: no-clobber\n//@ + `-u`: only copy if `source` is newer than `dest`\n//@ + `-r`, `-R`: recursive\n//@ + `-L`: follow symlinks\n//@ + `-P`: don't follow symlinks\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ cp('file1', 'dir1');\n//@ cp('-R', 'path/to/dir/', '~/newCopy/');\n//@ cp('-Rf', '/tmp/*', '/usr/local/*', '/home/tmp');\n//@ cp('-Rf', ['/tmp/*', '/usr/local/*'], '/home/tmp'); // same as above\n//@ ```\n//@\n//@ Copies files.\nfunction _cp(options, sources, dest) {\n  // If we're missing -R, it actually implies -L (unless -P is explicit)\n  if (options.followsymlink) {\n    options.noFollowsymlink = false;\n  }\n  if (!options.recursive && !options.noFollowsymlink) {\n    options.followsymlink = true;\n  }\n\n  // Get sources, dest\n  if (arguments.length < 3) {\n    common.error('missing <source> and/or <dest>');\n  } else {\n    sources = [].slice.call(arguments, 1, arguments.length - 1);\n    dest = arguments[arguments.length - 1];\n  }\n\n  var destExists = fs.existsSync(dest);\n  var destStat = destExists && common.statFollowLinks(dest);\n\n  // Dest is not existing dir, but multiple sources given\n  if ((!destExists || !destStat.isDirectory()) && sources.length > 1) {\n    common.error('dest is not a directory (too many sources)');\n  }\n\n  // Dest is an existing file, but -n is given\n  if (destExists && destStat.isFile() && options.no_force) {\n    return new common.ShellString('', '', 0);\n  }\n\n  sources.forEach(function (src, srcIndex) {\n    if (!fs.existsSync(src)) {\n      if (src === '') src = \"''\"; // if src was empty string, display empty string\n      common.error('no such file or directory: ' + src, { continue: true });\n      return; // skip file\n    }\n    var srcStat = common.statFollowLinks(src);\n    if (!options.noFollowsymlink && srcStat.isDirectory()) {\n      if (!options.recursive) {\n        // Non-Recursive\n        common.error(\"omitting directory '\" + src + \"'\", { continue: true });\n      } else {\n        // Recursive\n        // 'cp /a/source dest' should create 'source' in 'dest'\n        var newDest = (destStat && destStat.isDirectory()) ?\n            path.join(dest, path.basename(src)) :\n            dest;\n\n        try {\n          common.statFollowLinks(path.dirname(dest));\n          cpdirSyncRecursive(src, newDest, 0, { no_force: options.no_force, followsymlink: options.followsymlink });\n        } catch (e) {\n          /* istanbul ignore next */\n          common.error(\"cannot create directory '\" + dest + \"': No such file or directory\");\n        }\n      }\n    } else {\n      // If here, src is a file\n\n      // When copying to '/path/dir':\n      //    thisDest = '/path/dir/file1'\n      var thisDest = dest;\n      if (destStat && destStat.isDirectory()) {\n        thisDest = path.normalize(dest + '/' + path.basename(src));\n      }\n\n      var thisDestExists = fs.existsSync(thisDest);\n      if (thisDestExists && checkRecentCreated(sources, srcIndex)) {\n        // cannot overwrite file created recently in current execution, but we want to continue copying other files\n        if (!options.no_force) {\n          common.error(\"will not overwrite just-created '\" + thisDest + \"' with '\" + src + \"'\", { continue: true });\n        }\n        return;\n      }\n\n      if (thisDestExists && options.no_force) {\n        return; // skip file\n      }\n\n      if (path.relative(src, thisDest) === '') {\n        // a file cannot be copied to itself, but we want to continue copying other files\n        common.error(\"'\" + thisDest + \"' and '\" + src + \"' are the same file\", { continue: true });\n        return;\n      }\n\n      copyFileSync(src, thisDest, options);\n    }\n  }); // forEach(src)\n\n  return new common.ShellString('', common.state.error, common.state.errorCode);\n}\nmodule.exports = _cp;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}