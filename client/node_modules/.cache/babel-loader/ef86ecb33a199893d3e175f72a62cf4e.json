{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validate = void 0;\n\nconst errors_1 = require(\"./errors\");\n\nconst util_1 = require(\"../config/util\");\n\nasync function validate(parse) {\n  function validateArgs() {\n    const maxArgs = parse.input.args.length;\n\n    if (parse.input.strict && parse.output.argv.length > maxArgs) {\n      const extras = parse.output.argv.slice(maxArgs);\n      throw new errors_1.UnexpectedArgsError({\n        parse,\n        args: extras\n      });\n    }\n\n    const missingRequiredArgs = [];\n    let hasOptional = false;\n\n    for (const [index, arg] of parse.input.args.entries()) {\n      if (!arg.required) {\n        hasOptional = true;\n      } else if (hasOptional) {\n        // (required arg) check whether an optional has occurred before\n        // optionals should follow required, not before\n        throw new errors_1.InvalidArgsSpecError({\n          parse,\n          args: parse.input.args\n        });\n      }\n\n      if (arg.required && !parse.output.argv[index] && parse.output.argv[index] !== 0) {\n        missingRequiredArgs.push(arg);\n      }\n    }\n\n    if (missingRequiredArgs.length > 0) {\n      throw new errors_1.RequiredArgsError({\n        parse,\n        args: missingRequiredArgs\n      });\n    }\n  }\n\n  async function validateFlags() {\n    const promises = Object.entries(parse.input.flags).map(async ([name, flag]) => {\n      const results = [];\n\n      if (parse.output.flags[name] !== undefined) {\n        var _flag$dependsOn, _flag$exclusive, _flag$exactlyOne;\n\n        results.push(...(await validateRelationships(name, flag)), await validateDependsOn(name, (_flag$dependsOn = flag.dependsOn) !== null && _flag$dependsOn !== void 0 ? _flag$dependsOn : []), await validateExclusive(name, (_flag$exclusive = flag.exclusive) !== null && _flag$exclusive !== void 0 ? _flag$exclusive : []), await validateExactlyOne(name, (_flag$exactlyOne = flag.exactlyOne) !== null && _flag$exactlyOne !== void 0 ? _flag$exactlyOne : []));\n      } else if (flag.required) {\n        results.push({\n          status: 'failed',\n          name,\n          validationFn: 'required',\n          reason: `Missing required flag ${name}`\n        });\n      } else if (flag.exactlyOne && flag.exactlyOne.length > 0) {\n        results.push(validateAcrossFlags(flag));\n      }\n\n      return results;\n    });\n    const results = (await Promise.all(promises)).flat();\n    const failed = results.filter(r => r.status === 'failed');\n    if (failed.length > 0) throw new errors_1.FailedFlagValidationError({\n      parse,\n      failed\n    });\n  }\n\n  async function resolveFlags(flags) {\n    const promises = flags.map(async flag => {\n      if (typeof flag === 'string') {\n        return [flag, parse.output.flags[flag]];\n      }\n\n      const result = await flag.when(parse.output.flags);\n      return result ? [flag.name, parse.output.flags[flag.name]] : null;\n    });\n    const resolved = await Promise.all(promises);\n    return Object.fromEntries(resolved.filter(r => r !== null));\n  }\n\n  function getPresentFlags(flags) {\n    return Object.keys(flags).reduce((acc, key) => {\n      if (flags[key]) acc.push(key);\n      return acc;\n    }, []);\n  }\n\n  function validateAcrossFlags(flag) {\n    const base = {\n      name: flag.name,\n      validationFn: 'validateAcrossFlags'\n    };\n    const intersection = Object.entries(parse.input.flags).map(entry => entry[0]) // array of flag names\n    .filter(flagName => parse.output.flags[flagName] !== undefined) // with values\n    .filter(flagName => flag.exactlyOne && flag.exactlyOne.includes(flagName)); // and in the exactlyOne list\n\n    if (intersection.length === 0) {\n      var _flag$exactlyOne$map, _flag$exactlyOne2;\n\n      // the command's exactlyOne may or may not include itself, so we'll use Set to add + de-dupe\n      const deduped = (0, util_1.uniq)((_flag$exactlyOne$map = (_flag$exactlyOne2 = flag.exactlyOne) === null || _flag$exactlyOne2 === void 0 ? void 0 : _flag$exactlyOne2.map(flag => `--${flag}`)) !== null && _flag$exactlyOne$map !== void 0 ? _flag$exactlyOne$map : []).join(', ');\n      const reason = `Exactly one of the following must be provided: ${deduped}`;\n      return { ...base,\n        status: 'failed',\n        reason\n      };\n    }\n\n    return { ...base,\n      status: 'success'\n    };\n  }\n\n  async function validateExclusive(name, flags) {\n    const base = {\n      name,\n      validationFn: 'validateExclusive'\n    };\n    const resolved = await resolveFlags(flags);\n    const keys = getPresentFlags(resolved);\n\n    for (const flag of keys) {\n      var _parse$output$metadat, _parse$output$metadat2;\n\n      // do not enforce exclusivity for flags that were defaulted\n      if (parse.output.metadata.flags && ((_parse$output$metadat = parse.output.metadata.flags[flag]) === null || _parse$output$metadat === void 0 ? void 0 : _parse$output$metadat.setFromDefault)) continue;\n      if (parse.output.metadata.flags && ((_parse$output$metadat2 = parse.output.metadata.flags[name]) === null || _parse$output$metadat2 === void 0 ? void 0 : _parse$output$metadat2.setFromDefault)) continue;\n\n      if (parse.output.flags[flag]) {\n        return { ...base,\n          status: 'failed',\n          reason: `--${flag}=${parse.output.flags[flag]} cannot also be provided when using --${name}`\n        };\n      }\n    }\n\n    return { ...base,\n      status: 'success'\n    };\n  }\n\n  async function validateExactlyOne(name, flags) {\n    const base = {\n      name,\n      validationFn: 'validateExactlyOne'\n    };\n    const resolved = await resolveFlags(flags);\n    const keys = getPresentFlags(resolved);\n\n    for (const flag of keys) {\n      if (flag !== name && parse.output.flags[flag]) {\n        return { ...base,\n          status: 'failed',\n          reason: `--${flag} cannot also be provided when using --${name}`\n        };\n      }\n    }\n\n    return { ...base,\n      status: 'success'\n    };\n  }\n\n  async function validateDependsOn(name, flags) {\n    const base = {\n      name,\n      validationFn: 'validateDependsOn'\n    };\n    const resolved = await resolveFlags(flags);\n    const foundAll = Object.values(resolved).every(Boolean);\n\n    if (!foundAll) {\n      const formattedFlags = Object.keys(resolved).map(f => `--${f}`).join(', ');\n      return { ...base,\n        status: 'failed',\n        reason: `All of the following must be provided when using --${name}: ${formattedFlags}`\n      };\n    }\n\n    return { ...base,\n      status: 'success'\n    };\n  }\n\n  async function validateSome(name, flags) {\n    const base = {\n      name,\n      validationFn: 'validateSome'\n    };\n    const resolved = await resolveFlags(flags);\n    const foundAtLeastOne = Object.values(resolved).some(Boolean);\n\n    if (!foundAtLeastOne) {\n      const formattedFlags = Object.keys(resolved).map(f => `--${f}`).join(', ');\n      return { ...base,\n        status: 'failed',\n        reason: `One of the following must be provided when using --${name}: ${formattedFlags}`\n      };\n    }\n\n    return { ...base,\n      status: 'success'\n    };\n  }\n\n  async function validateRelationships(name, flag) {\n    if (!flag.relationships) return [];\n    const results = await Promise.all(flag.relationships.map(async relationship => {\n      var _relationship$flags;\n\n      const flags = (_relationship$flags = relationship.flags) !== null && _relationship$flags !== void 0 ? _relationship$flags : [];\n      const results = [];\n\n      switch (relationship.type) {\n        case 'all':\n          results.push(await validateDependsOn(name, flags));\n          break;\n\n        case 'some':\n          results.push(await validateSome(name, flags));\n          break;\n\n        case 'none':\n          results.push(await validateExclusive(name, flags));\n          break;\n\n        default:\n          break;\n      }\n\n      return results;\n    }));\n    return results.flat();\n  }\n\n  validateArgs();\n  await validateFlags();\n}\n\nexports.validate = validate;","map":{"version":3,"names":["Object","defineProperty","exports","value","validate","errors_1","require","util_1","parse","validateArgs","maxArgs","input","args","length","strict","output","argv","extras","slice","UnexpectedArgsError","missingRequiredArgs","hasOptional","index","arg","entries","required","InvalidArgsSpecError","push","RequiredArgsError","validateFlags","promises","flags","map","name","flag","results","undefined","validateRelationships","validateDependsOn","dependsOn","validateExclusive","exclusive","validateExactlyOne","exactlyOne","status","validationFn","reason","validateAcrossFlags","Promise","all","flat","failed","filter","r","FailedFlagValidationError","resolveFlags","result","when","resolved","fromEntries","getPresentFlags","keys","reduce","acc","key","base","intersection","entry","flagName","includes","deduped","uniq","join","metadata","setFromDefault","foundAll","values","every","Boolean","formattedFlags","f","validateSome","foundAtLeastOne","some","relationships","relationship","type"],"sources":["/Users/Ellie/Desktop/projects/book-search-engine/client/node_modules/@oclif/core/lib/parser/validate.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validate = void 0;\nconst errors_1 = require(\"./errors\");\nconst util_1 = require(\"../config/util\");\nasync function validate(parse) {\n    function validateArgs() {\n        const maxArgs = parse.input.args.length;\n        if (parse.input.strict && parse.output.argv.length > maxArgs) {\n            const extras = parse.output.argv.slice(maxArgs);\n            throw new errors_1.UnexpectedArgsError({ parse, args: extras });\n        }\n        const missingRequiredArgs = [];\n        let hasOptional = false;\n        for (const [index, arg] of parse.input.args.entries()) {\n            if (!arg.required) {\n                hasOptional = true;\n            }\n            else if (hasOptional) {\n                // (required arg) check whether an optional has occurred before\n                // optionals should follow required, not before\n                throw new errors_1.InvalidArgsSpecError({ parse, args: parse.input.args });\n            }\n            if (arg.required && !parse.output.argv[index] && parse.output.argv[index] !== 0) {\n                missingRequiredArgs.push(arg);\n            }\n        }\n        if (missingRequiredArgs.length > 0) {\n            throw new errors_1.RequiredArgsError({ parse, args: missingRequiredArgs });\n        }\n    }\n    async function validateFlags() {\n        const promises = Object.entries(parse.input.flags).map(async ([name, flag]) => {\n            const results = [];\n            if (parse.output.flags[name] !== undefined) {\n                results.push(...await validateRelationships(name, flag), await validateDependsOn(name, flag.dependsOn ?? []), await validateExclusive(name, flag.exclusive ?? []), await validateExactlyOne(name, flag.exactlyOne ?? []));\n            }\n            else if (flag.required) {\n                results.push({ status: 'failed', name, validationFn: 'required', reason: `Missing required flag ${name}` });\n            }\n            else if (flag.exactlyOne && flag.exactlyOne.length > 0) {\n                results.push(validateAcrossFlags(flag));\n            }\n            return results;\n        });\n        const results = (await Promise.all(promises)).flat();\n        const failed = results.filter(r => r.status === 'failed');\n        if (failed.length > 0)\n            throw new errors_1.FailedFlagValidationError({ parse, failed });\n    }\n    async function resolveFlags(flags) {\n        const promises = flags.map(async (flag) => {\n            if (typeof flag === 'string') {\n                return [flag, parse.output.flags[flag]];\n            }\n            const result = await flag.when(parse.output.flags);\n            return result ? [flag.name, parse.output.flags[flag.name]] : null;\n        });\n        const resolved = await Promise.all(promises);\n        return Object.fromEntries(resolved.filter(r => r !== null));\n    }\n    function getPresentFlags(flags) {\n        return Object.keys(flags).reduce((acc, key) => {\n            if (flags[key])\n                acc.push(key);\n            return acc;\n        }, []);\n    }\n    function validateAcrossFlags(flag) {\n        const base = { name: flag.name, validationFn: 'validateAcrossFlags' };\n        const intersection = Object.entries(parse.input.flags)\n            .map(entry => entry[0]) // array of flag names\n            .filter(flagName => parse.output.flags[flagName] !== undefined) // with values\n            .filter(flagName => flag.exactlyOne && flag.exactlyOne.includes(flagName)); // and in the exactlyOne list\n        if (intersection.length === 0) {\n            // the command's exactlyOne may or may not include itself, so we'll use Set to add + de-dupe\n            const deduped = (0, util_1.uniq)(flag.exactlyOne?.map(flag => `--${flag}`) ?? []).join(', ');\n            const reason = `Exactly one of the following must be provided: ${deduped}`;\n            return { ...base, status: 'failed', reason };\n        }\n        return { ...base, status: 'success' };\n    }\n    async function validateExclusive(name, flags) {\n        const base = { name, validationFn: 'validateExclusive' };\n        const resolved = await resolveFlags(flags);\n        const keys = getPresentFlags(resolved);\n        for (const flag of keys) {\n            // do not enforce exclusivity for flags that were defaulted\n            if (parse.output.metadata.flags && parse.output.metadata.flags[flag]?.setFromDefault)\n                continue;\n            if (parse.output.metadata.flags && parse.output.metadata.flags[name]?.setFromDefault)\n                continue;\n            if (parse.output.flags[flag]) {\n                return { ...base, status: 'failed', reason: `--${flag}=${parse.output.flags[flag]} cannot also be provided when using --${name}` };\n            }\n        }\n        return { ...base, status: 'success' };\n    }\n    async function validateExactlyOne(name, flags) {\n        const base = { name, validationFn: 'validateExactlyOne' };\n        const resolved = await resolveFlags(flags);\n        const keys = getPresentFlags(resolved);\n        for (const flag of keys) {\n            if (flag !== name && parse.output.flags[flag]) {\n                return { ...base, status: 'failed', reason: `--${flag} cannot also be provided when using --${name}` };\n            }\n        }\n        return { ...base, status: 'success' };\n    }\n    async function validateDependsOn(name, flags) {\n        const base = { name, validationFn: 'validateDependsOn' };\n        const resolved = await resolveFlags(flags);\n        const foundAll = Object.values(resolved).every(Boolean);\n        if (!foundAll) {\n            const formattedFlags = Object.keys(resolved).map(f => `--${f}`).join(', ');\n            return { ...base, status: 'failed', reason: `All of the following must be provided when using --${name}: ${formattedFlags}` };\n        }\n        return { ...base, status: 'success' };\n    }\n    async function validateSome(name, flags) {\n        const base = { name, validationFn: 'validateSome' };\n        const resolved = await resolveFlags(flags);\n        const foundAtLeastOne = Object.values(resolved).some(Boolean);\n        if (!foundAtLeastOne) {\n            const formattedFlags = Object.keys(resolved).map(f => `--${f}`).join(', ');\n            return { ...base, status: 'failed', reason: `One of the following must be provided when using --${name}: ${formattedFlags}` };\n        }\n        return { ...base, status: 'success' };\n    }\n    async function validateRelationships(name, flag) {\n        if (!flag.relationships)\n            return [];\n        const results = await Promise.all(flag.relationships.map(async (relationship) => {\n            const flags = relationship.flags ?? [];\n            const results = [];\n            switch (relationship.type) {\n                case 'all':\n                    results.push(await validateDependsOn(name, flags));\n                    break;\n                case 'some':\n                    results.push(await validateSome(name, flags));\n                    break;\n                case 'none':\n                    results.push(await validateExclusive(name, flags));\n                    break;\n                default:\n                    break;\n            }\n            return results;\n        }));\n        return results.flat();\n    }\n    validateArgs();\n    await validateFlags();\n}\nexports.validate = validate;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}