{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stripCommonPrimitives = exports.replaceExtendedDefinitionsWithExtensions = exports.defaultRootOperationTypes = exports.normalizeTypeDefs = void 0;\n\nconst graphql_1 = require(\"graphql\");\n\nconst utils_1 = require(\"./utils\");\n\nconst directives_1 = __importDefault(require(\"../directives\"));\n\nfunction normalizeTypeDefs(typeDefs) {\n  return stripCommonPrimitives(defaultRootOperationTypes(replaceExtendedDefinitionsWithExtensions(typeDefs)));\n}\n\nexports.normalizeTypeDefs = normalizeTypeDefs;\n\nfunction defaultRootOperationTypes(typeDefs) {\n  const defaultRootOperationNames = Object.values(utils_1.defaultRootOperationNameLookup);\n  let rootOperationTypeMap = Object.create(null);\n  let hasSchemaDefinitionOrExtension = false;\n  graphql_1.visit(typeDefs, {\n    OperationTypeDefinition(node) {\n      hasSchemaDefinitionOrExtension = true;\n      rootOperationTypeMap[node.type.name.value] = utils_1.defaultRootOperationNameLookup[node.operation];\n    }\n\n  });\n\n  if (!hasSchemaDefinitionOrExtension) {\n    rootOperationTypeMap = {\n      Query: 'Query',\n      Mutation: 'Mutation',\n      Subscription: 'Subscription'\n    };\n  }\n\n  let schemaWithoutConflictingDefaultDefinitions;\n\n  if (!hasSchemaDefinitionOrExtension) {\n    schemaWithoutConflictingDefaultDefinitions = typeDefs;\n  } else {\n    schemaWithoutConflictingDefaultDefinitions = graphql_1.visit(typeDefs, {\n      ObjectTypeDefinition(node) {\n        if (defaultRootOperationNames.includes(node.name.value) && !rootOperationTypeMap[node.name.value]) {\n          return null;\n        }\n\n        return;\n      },\n\n      ObjectTypeExtension(node) {\n        if (defaultRootOperationNames.includes(node.name.value) && !rootOperationTypeMap[node.name.value]) {\n          return null;\n        }\n\n        return;\n      },\n\n      FieldDefinition(node) {\n        if (node.type.kind === graphql_1.Kind.NAMED_TYPE && defaultRootOperationNames.includes(node.type.name.value)) {\n          return null;\n        }\n\n        if (node.type.kind === graphql_1.Kind.NON_NULL_TYPE && node.type.type.kind === graphql_1.Kind.NAMED_TYPE && defaultRootOperationNames.includes(node.type.type.name.value)) {\n          return null;\n        }\n\n        return;\n      }\n\n    });\n  }\n\n  const schemaWithDefaultRootTypes = graphql_1.visit(schemaWithoutConflictingDefaultDefinitions, {\n    SchemaDefinition() {\n      return null;\n    },\n\n    SchemaExtension() {\n      return null;\n    },\n\n    ObjectTypeDefinition(node) {\n      if (node.name.value in rootOperationTypeMap || defaultRootOperationNames.includes(node.name.value)) {\n        return { ...node,\n          name: { ...node.name,\n            value: rootOperationTypeMap[node.name.value] || node.name.value\n          },\n          kind: graphql_1.Kind.OBJECT_TYPE_EXTENSION\n        };\n      }\n\n      return;\n    },\n\n    ObjectTypeExtension(node) {\n      if (node.name.value in rootOperationTypeMap || defaultRootOperationNames.includes(node.name.value)) {\n        return { ...node,\n          name: { ...node.name,\n            value: rootOperationTypeMap[node.name.value] || node.name.value\n          }\n        };\n      }\n\n      return;\n    },\n\n    NamedType(node) {\n      if (node.name.value in rootOperationTypeMap) {\n        return { ...node,\n          name: { ...node.name,\n            value: rootOperationTypeMap[node.name.value]\n          }\n        };\n      }\n\n      return;\n    }\n\n  });\n  return schemaWithDefaultRootTypes;\n}\n\nexports.defaultRootOperationTypes = defaultRootOperationTypes;\n\nfunction replaceExtendedDefinitionsWithExtensions(typeDefs) {\n  const typeDefsWithExtendedTypesReplaced = graphql_1.visit(typeDefs, {\n    ObjectTypeDefinition: visitor,\n    InterfaceTypeDefinition: visitor\n  });\n\n  function visitor(node) {\n    const isExtensionDefinition = utils_1.findDirectivesOnNode(node, 'extends').length > 0;\n\n    if (!isExtensionDefinition) {\n      return node;\n    }\n\n    const filteredDirectives = node.directives && node.directives.filter(directive => directive.name.value !== 'extends');\n    return { ...node,\n      ...(filteredDirectives && {\n        directives: filteredDirectives\n      }),\n      kind: utils_1.defKindToExtKind[node.kind]\n    };\n  }\n\n  return typeDefsWithExtendedTypesReplaced;\n}\n\nexports.replaceExtendedDefinitionsWithExtensions = replaceExtendedDefinitionsWithExtensions;\n\nfunction stripCommonPrimitives(document) {\n  const typeDefinitionVisitor = node => {\n    var _a;\n\n    if (node.name.value === utils_1.defaultRootOperationNameLookup.query) {\n      const filteredFieldDefinitions = (_a = node.fields) === null || _a === void 0 ? void 0 : _a.filter(fieldDefinition => !utils_1.reservedRootFields.includes(fieldDefinition.name.value));\n\n      if (!filteredFieldDefinitions || filteredFieldDefinitions.length === 0) {\n        return null;\n      }\n\n      return { ...node,\n        fields: filteredFieldDefinitions\n      };\n    }\n\n    const isFederationType = node.name.value === '_Service';\n    return isFederationType ? null : node;\n  };\n\n  return graphql_1.visit(document, {\n    DirectiveDefinition(node) {\n      const isCommonDirective = [...directives_1.default, ...graphql_1.specifiedDirectives].some(directive => directive.name === node.name.value);\n      return isCommonDirective ? null : node;\n    },\n\n    ScalarTypeDefinition(node) {\n      const isFederationScalar = ['_Any', '_FieldSet'].includes(node.name.value);\n      return isFederationScalar ? null : node;\n    },\n\n    UnionTypeDefinition(node) {\n      const isFederationUnion = node.name.value === \"_Entity\";\n      return isFederationUnion ? null : node;\n    },\n\n    ObjectTypeDefinition: typeDefinitionVisitor,\n    ObjectTypeExtension: typeDefinitionVisitor\n  });\n}\n\nexports.stripCommonPrimitives = stripCommonPrimitives;","map":{"version":3,"sources":["../../src/composition/normalize.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.stripCommonPrimitives = exports.replaceExtendedDefinitionsWithExtensions = exports.defaultRootOperationTypes = exports.normalizeTypeDefs = void 0;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"./utils\");\nconst directives_1 = __importDefault(require(\"../directives\"));\nfunction normalizeTypeDefs(typeDefs) {\n    return stripCommonPrimitives(defaultRootOperationTypes(replaceExtendedDefinitionsWithExtensions(typeDefs)));\n}\nexports.normalizeTypeDefs = normalizeTypeDefs;\nfunction defaultRootOperationTypes(typeDefs) {\n    const defaultRootOperationNames = Object.values(utils_1.defaultRootOperationNameLookup);\n    let rootOperationTypeMap = Object.create(null);\n    let hasSchemaDefinitionOrExtension = false;\n    graphql_1.visit(typeDefs, {\n        OperationTypeDefinition(node) {\n            hasSchemaDefinitionOrExtension = true;\n            rootOperationTypeMap[node.type.name.value] =\n                utils_1.defaultRootOperationNameLookup[node.operation];\n        },\n    });\n    if (!hasSchemaDefinitionOrExtension) {\n        rootOperationTypeMap = {\n            Query: 'Query',\n            Mutation: 'Mutation',\n            Subscription: 'Subscription',\n        };\n    }\n    let schemaWithoutConflictingDefaultDefinitions;\n    if (!hasSchemaDefinitionOrExtension) {\n        schemaWithoutConflictingDefaultDefinitions = typeDefs;\n    }\n    else {\n        schemaWithoutConflictingDefaultDefinitions = graphql_1.visit(typeDefs, {\n            ObjectTypeDefinition(node) {\n                if (defaultRootOperationNames.includes(node.name.value) &&\n                    !rootOperationTypeMap[node.name.value]) {\n                    return null;\n                }\n                return;\n            },\n            ObjectTypeExtension(node) {\n                if (defaultRootOperationNames.includes(node.name.value) &&\n                    !rootOperationTypeMap[node.name.value]) {\n                    return null;\n                }\n                return;\n            },\n            FieldDefinition(node) {\n                if (node.type.kind === graphql_1.Kind.NAMED_TYPE &&\n                    defaultRootOperationNames.includes(node.type.name.value)) {\n                    return null;\n                }\n                if (node.type.kind === graphql_1.Kind.NON_NULL_TYPE &&\n                    node.type.type.kind === graphql_1.Kind.NAMED_TYPE &&\n                    defaultRootOperationNames.includes(node.type.type.name.value)) {\n                    return null;\n                }\n                return;\n            },\n        });\n    }\n    const schemaWithDefaultRootTypes = graphql_1.visit(schemaWithoutConflictingDefaultDefinitions, {\n        SchemaDefinition() {\n            return null;\n        },\n        SchemaExtension() {\n            return null;\n        },\n        ObjectTypeDefinition(node) {\n            if (node.name.value in rootOperationTypeMap ||\n                defaultRootOperationNames.includes(node.name.value)) {\n                return {\n                    ...node,\n                    name: {\n                        ...node.name,\n                        value: rootOperationTypeMap[node.name.value] || node.name.value,\n                    },\n                    kind: graphql_1.Kind.OBJECT_TYPE_EXTENSION,\n                };\n            }\n            return;\n        },\n        ObjectTypeExtension(node) {\n            if (node.name.value in rootOperationTypeMap ||\n                defaultRootOperationNames.includes(node.name.value)) {\n                return {\n                    ...node,\n                    name: {\n                        ...node.name,\n                        value: rootOperationTypeMap[node.name.value] || node.name.value,\n                    },\n                };\n            }\n            return;\n        },\n        NamedType(node) {\n            if (node.name.value in rootOperationTypeMap) {\n                return {\n                    ...node,\n                    name: {\n                        ...node.name,\n                        value: rootOperationTypeMap[node.name.value],\n                    },\n                };\n            }\n            return;\n        },\n    });\n    return schemaWithDefaultRootTypes;\n}\nexports.defaultRootOperationTypes = defaultRootOperationTypes;\nfunction replaceExtendedDefinitionsWithExtensions(typeDefs) {\n    const typeDefsWithExtendedTypesReplaced = graphql_1.visit(typeDefs, {\n        ObjectTypeDefinition: visitor,\n        InterfaceTypeDefinition: visitor,\n    });\n    function visitor(node) {\n        const isExtensionDefinition = utils_1.findDirectivesOnNode(node, 'extends').length > 0;\n        if (!isExtensionDefinition) {\n            return node;\n        }\n        const filteredDirectives = node.directives &&\n            node.directives.filter(directive => directive.name.value !== 'extends');\n        return {\n            ...node,\n            ...(filteredDirectives && { directives: filteredDirectives }),\n            kind: utils_1.defKindToExtKind[node.kind],\n        };\n    }\n    return typeDefsWithExtendedTypesReplaced;\n}\nexports.replaceExtendedDefinitionsWithExtensions = replaceExtendedDefinitionsWithExtensions;\nfunction stripCommonPrimitives(document) {\n    const typeDefinitionVisitor = (node) => {\n        var _a;\n        if (node.name.value === utils_1.defaultRootOperationNameLookup.query) {\n            const filteredFieldDefinitions = (_a = node.fields) === null || _a === void 0 ? void 0 : _a.filter((fieldDefinition) => !utils_1.reservedRootFields.includes(fieldDefinition.name.value));\n            if (!filteredFieldDefinitions || filteredFieldDefinitions.length === 0) {\n                return null;\n            }\n            return {\n                ...node,\n                fields: filteredFieldDefinitions,\n            };\n        }\n        const isFederationType = node.name.value === '_Service';\n        return isFederationType ? null : node;\n    };\n    return graphql_1.visit(document, {\n        DirectiveDefinition(node) {\n            const isCommonDirective = [\n                ...directives_1.default,\n                ...graphql_1.specifiedDirectives,\n            ].some((directive) => directive.name === node.name.value);\n            return isCommonDirective ? null : node;\n        },\n        ScalarTypeDefinition(node) {\n            const isFederationScalar = ['_Any', '_FieldSet'].includes(node.name.value);\n            return isFederationScalar ? null : node;\n        },\n        UnionTypeDefinition(node) {\n            const isFederationUnion = node.name.value === \"_Entity\";\n            return isFederationUnion ? null : node;\n        },\n        ObjectTypeDefinition: typeDefinitionVisitor,\n        ObjectTypeExtension: typeDefinitionVisitor,\n    });\n}\nexports.stripCommonPrimitives = stripCommonPrimitives;\n//# sourceMappingURL=normalize.js.map"]},"metadata":{},"sourceType":"script"}