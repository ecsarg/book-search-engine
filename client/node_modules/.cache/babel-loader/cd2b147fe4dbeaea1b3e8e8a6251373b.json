{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildServiceDefinition = void 0;\n\nconst graphql_1 = require(\"graphql\");\n\nconst graphql_2 = require(\"./utilities/graphql\");\n\nconst predicates_1 = require(\"./utilities/predicates\");\n\nfunction flattened(arr) {\n  return new Array().concat(...arr);\n}\n\nfunction buildServiceDefinition(modules) {\n  const errors = [];\n  const typeDefinitionsMap = Object.create(null);\n  const typeExtensionsMap = Object.create(null);\n  const directivesMap = Object.create(null);\n  const schemaDefinitions = [];\n  const schemaExtensions = [];\n\n  for (let module of modules) {\n    if ((0, graphql_2.isNode)(module) && (0, graphql_2.isDocumentNode)(module)) {\n      module = {\n        typeDefs: module\n      };\n    }\n\n    for (const definition of module.typeDefs.definitions) {\n      if ((0, graphql_1.isTypeDefinitionNode)(definition)) {\n        const typeName = definition.name.value;\n\n        if (typeDefinitionsMap[typeName]) {\n          typeDefinitionsMap[typeName].push(definition);\n        } else {\n          typeDefinitionsMap[typeName] = [definition];\n        }\n      } else if ((0, graphql_1.isTypeExtensionNode)(definition)) {\n        const typeName = definition.name.value;\n\n        if (typeExtensionsMap[typeName]) {\n          typeExtensionsMap[typeName].push(definition);\n        } else {\n          typeExtensionsMap[typeName] = [definition];\n        }\n      } else if (definition.kind === graphql_1.Kind.DIRECTIVE_DEFINITION) {\n        const directiveName = definition.name.value;\n\n        if (directivesMap[directiveName]) {\n          directivesMap[directiveName].push(definition);\n        } else {\n          directivesMap[directiveName] = [definition];\n        }\n      } else if (definition.kind === graphql_1.Kind.SCHEMA_DEFINITION) {\n        schemaDefinitions.push(definition);\n      } else if (definition.kind === graphql_1.Kind.SCHEMA_EXTENSION) {\n        schemaExtensions.push(definition);\n      }\n    }\n  }\n\n  for (const [typeName, typeDefinitions] of Object.entries(typeDefinitionsMap)) {\n    if (typeDefinitions.length > 1) {\n      errors.push(new graphql_1.GraphQLError(`Type \"${typeName}\" was defined more than once.`, typeDefinitions));\n    }\n  }\n\n  for (const [directiveName, directives] of Object.entries(directivesMap)) {\n    if (directives.length > 1) {\n      errors.push(new graphql_1.GraphQLError(`Directive \"${directiveName}\" was defined more than once.`, directives));\n    }\n  }\n\n  let operationTypeMap;\n\n  if (schemaDefinitions.length > 0 || schemaExtensions.length > 0) {\n    operationTypeMap = {};\n    const schemaDefinition = schemaDefinitions[schemaDefinitions.length - 1];\n    const operationTypes = flattened([schemaDefinition, ...schemaExtensions].map(node => node.operationTypes).filter(predicates_1.isNotNullOrUndefined));\n\n    for (const operationType of operationTypes) {\n      const typeName = operationType.type.name.value;\n      const operation = operationType.operation;\n\n      if (operationTypeMap[operation]) {\n        throw new graphql_1.GraphQLError(`Must provide only one ${operation} type in schema.`, [schemaDefinition]);\n      }\n\n      if (!(typeDefinitionsMap[typeName] || typeExtensionsMap[typeName])) {\n        throw new graphql_1.GraphQLError(`Specified ${operation} type \"${typeName}\" not found in document.`, [schemaDefinition]);\n      }\n\n      operationTypeMap[operation] = typeName;\n    }\n  } else {\n    operationTypeMap = {\n      query: \"Query\",\n      mutation: \"Mutation\",\n      subscription: \"Subscription\"\n    };\n  }\n\n  for (const [typeName, typeExtensions] of Object.entries(typeExtensionsMap)) {\n    if (!typeDefinitionsMap[typeName]) {\n      if (Object.values(operationTypeMap).includes(typeName)) {\n        typeDefinitionsMap[typeName] = [{\n          kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,\n          name: {\n            kind: graphql_1.Kind.NAME,\n            value: typeName\n          }\n        }];\n      } else {\n        errors.push(new graphql_1.GraphQLError(`Cannot extend type \"${typeName}\" because it does not exist in the existing schema.`, typeExtensions));\n      }\n    }\n  }\n\n  if (errors.length > 0) {\n    return {\n      errors\n    };\n  }\n\n  try {\n    const typeDefinitions = flattened(Object.values(typeDefinitionsMap));\n    const directives = flattened(Object.values(directivesMap));\n    let schema = (0, graphql_1.buildASTSchema)({\n      kind: graphql_1.Kind.DOCUMENT,\n      definitions: [...typeDefinitions, ...directives]\n    });\n    const typeExtensions = flattened(Object.values(typeExtensionsMap));\n\n    if (typeExtensions.length > 0) {\n      schema = (0, graphql_1.extendSchema)(schema, {\n        kind: graphql_1.Kind.DOCUMENT,\n        definitions: typeExtensions\n      });\n    }\n\n    for (const module of modules) {\n      if (\"kind\" in module || !module.resolvers) continue;\n      addResolversToSchema(schema, module.resolvers);\n    }\n\n    return {\n      schema\n    };\n  } catch (error) {\n    return {\n      errors: [error]\n    };\n  }\n}\n\nexports.buildServiceDefinition = buildServiceDefinition;\n\nfunction addResolversToSchema(schema, resolvers) {\n  for (const [typeName, fieldConfigs] of Object.entries(resolvers)) {\n    const type = schema.getType(typeName);\n    if (!(0, graphql_1.isObjectType)(type)) continue;\n    const fieldMap = type.getFields();\n\n    for (const [fieldName, fieldConfig] of Object.entries(fieldConfigs)) {\n      if (fieldName.startsWith(\"__\")) {\n        type[fieldName.substring(2)] = fieldConfig;\n        continue;\n      }\n\n      const field = fieldMap[fieldName];\n      if (!field) continue;\n\n      if (typeof fieldConfig === \"function\") {\n        field.resolve = fieldConfig;\n      } else {\n        if (fieldConfig.resolve) {\n          field.resolve = fieldConfig.resolve;\n        }\n\n        if (fieldConfig.subscribe) {\n          field.subscribe = fieldConfig.subscribe;\n        }\n      }\n    }\n  }\n}","map":{"version":3,"sources":["../src/buildServiceDefinition.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.buildServiceDefinition = void 0;\nconst graphql_1 = require(\"graphql\");\nconst graphql_2 = require(\"./utilities/graphql\");\nconst predicates_1 = require(\"./utilities/predicates\");\nfunction flattened(arr) {\n    return new Array().concat(...arr);\n}\nfunction buildServiceDefinition(modules) {\n    const errors = [];\n    const typeDefinitionsMap = Object.create(null);\n    const typeExtensionsMap = Object.create(null);\n    const directivesMap = Object.create(null);\n    const schemaDefinitions = [];\n    const schemaExtensions = [];\n    for (let module of modules) {\n        if ((0, graphql_2.isNode)(module) && (0, graphql_2.isDocumentNode)(module)) {\n            module = { typeDefs: module };\n        }\n        for (const definition of module.typeDefs.definitions) {\n            if ((0, graphql_1.isTypeDefinitionNode)(definition)) {\n                const typeName = definition.name.value;\n                if (typeDefinitionsMap[typeName]) {\n                    typeDefinitionsMap[typeName].push(definition);\n                }\n                else {\n                    typeDefinitionsMap[typeName] = [definition];\n                }\n            }\n            else if ((0, graphql_1.isTypeExtensionNode)(definition)) {\n                const typeName = definition.name.value;\n                if (typeExtensionsMap[typeName]) {\n                    typeExtensionsMap[typeName].push(definition);\n                }\n                else {\n                    typeExtensionsMap[typeName] = [definition];\n                }\n            }\n            else if (definition.kind === graphql_1.Kind.DIRECTIVE_DEFINITION) {\n                const directiveName = definition.name.value;\n                if (directivesMap[directiveName]) {\n                    directivesMap[directiveName].push(definition);\n                }\n                else {\n                    directivesMap[directiveName] = [definition];\n                }\n            }\n            else if (definition.kind === graphql_1.Kind.SCHEMA_DEFINITION) {\n                schemaDefinitions.push(definition);\n            }\n            else if (definition.kind === graphql_1.Kind.SCHEMA_EXTENSION) {\n                schemaExtensions.push(definition);\n            }\n        }\n    }\n    for (const [typeName, typeDefinitions] of Object.entries(typeDefinitionsMap)) {\n        if (typeDefinitions.length > 1) {\n            errors.push(new graphql_1.GraphQLError(`Type \"${typeName}\" was defined more than once.`, typeDefinitions));\n        }\n    }\n    for (const [directiveName, directives] of Object.entries(directivesMap)) {\n        if (directives.length > 1) {\n            errors.push(new graphql_1.GraphQLError(`Directive \"${directiveName}\" was defined more than once.`, directives));\n        }\n    }\n    let operationTypeMap;\n    if (schemaDefinitions.length > 0 || schemaExtensions.length > 0) {\n        operationTypeMap = {};\n        const schemaDefinition = schemaDefinitions[schemaDefinitions.length - 1];\n        const operationTypes = flattened([schemaDefinition, ...schemaExtensions]\n            .map((node) => node.operationTypes)\n            .filter(predicates_1.isNotNullOrUndefined));\n        for (const operationType of operationTypes) {\n            const typeName = operationType.type.name.value;\n            const operation = operationType.operation;\n            if (operationTypeMap[operation]) {\n                throw new graphql_1.GraphQLError(`Must provide only one ${operation} type in schema.`, [schemaDefinition]);\n            }\n            if (!(typeDefinitionsMap[typeName] || typeExtensionsMap[typeName])) {\n                throw new graphql_1.GraphQLError(`Specified ${operation} type \"${typeName}\" not found in document.`, [schemaDefinition]);\n            }\n            operationTypeMap[operation] = typeName;\n        }\n    }\n    else {\n        operationTypeMap = {\n            query: \"Query\",\n            mutation: \"Mutation\",\n            subscription: \"Subscription\",\n        };\n    }\n    for (const [typeName, typeExtensions] of Object.entries(typeExtensionsMap)) {\n        if (!typeDefinitionsMap[typeName]) {\n            if (Object.values(operationTypeMap).includes(typeName)) {\n                typeDefinitionsMap[typeName] = [\n                    {\n                        kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,\n                        name: {\n                            kind: graphql_1.Kind.NAME,\n                            value: typeName,\n                        },\n                    },\n                ];\n            }\n            else {\n                errors.push(new graphql_1.GraphQLError(`Cannot extend type \"${typeName}\" because it does not exist in the existing schema.`, typeExtensions));\n            }\n        }\n    }\n    if (errors.length > 0) {\n        return { errors };\n    }\n    try {\n        const typeDefinitions = flattened(Object.values(typeDefinitionsMap));\n        const directives = flattened(Object.values(directivesMap));\n        let schema = (0, graphql_1.buildASTSchema)({\n            kind: graphql_1.Kind.DOCUMENT,\n            definitions: [...typeDefinitions, ...directives],\n        });\n        const typeExtensions = flattened(Object.values(typeExtensionsMap));\n        if (typeExtensions.length > 0) {\n            schema = (0, graphql_1.extendSchema)(schema, {\n                kind: graphql_1.Kind.DOCUMENT,\n                definitions: typeExtensions,\n            });\n        }\n        for (const module of modules) {\n            if (\"kind\" in module || !module.resolvers)\n                continue;\n            addResolversToSchema(schema, module.resolvers);\n        }\n        return { schema };\n    }\n    catch (error) {\n        return { errors: [error] };\n    }\n}\nexports.buildServiceDefinition = buildServiceDefinition;\nfunction addResolversToSchema(schema, resolvers) {\n    for (const [typeName, fieldConfigs] of Object.entries(resolvers)) {\n        const type = schema.getType(typeName);\n        if (!(0, graphql_1.isObjectType)(type))\n            continue;\n        const fieldMap = type.getFields();\n        for (const [fieldName, fieldConfig] of Object.entries(fieldConfigs)) {\n            if (fieldName.startsWith(\"__\")) {\n                type[fieldName.substring(2)] = fieldConfig;\n                continue;\n            }\n            const field = fieldMap[fieldName];\n            if (!field)\n                continue;\n            if (typeof fieldConfig === \"function\") {\n                field.resolve = fieldConfig;\n            }\n            else {\n                if (fieldConfig.resolve) {\n                    field.resolve = fieldConfig.resolve;\n                }\n                if (fieldConfig.subscribe) {\n                    field.subscribe = fieldConfig.subscribe;\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=buildServiceDefinition.js.map"]},"metadata":{},"sourceType":"script"}