{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _serializeError = require(\"serialize-error\");\n\nvar _boolean = require(\"boolean\");\n\nvar _Logger = _interopRequireDefault(require(\"../Logger\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst log = _Logger.default.child({\n  namespace: 'Agent'\n});\n\nlet requestId = 0;\n\nclass Agent {\n  constructor(isProxyConfigured, mustUrlUseProxy, getUrlProxy, fallbackAgent, socketConnectionTimeout) {\n    this.fallbackAgent = fallbackAgent;\n    this.isProxyConfigured = isProxyConfigured;\n    this.mustUrlUseProxy = mustUrlUseProxy;\n    this.getUrlProxy = getUrlProxy;\n    this.socketConnectionTimeout = socketConnectionTimeout;\n  }\n\n  addRequest(request, configuration) {\n    let requestUrl; // It is possible that addRequest was constructed for a proxied request already, e.g.\n    // \"request\" package does this when it detects that a proxy should be used\n    // https://github.com/request/request/blob/212570b6971a732b8dd9f3c73354bcdda158a737/request.js#L402\n    // https://gist.github.com/gajus/e2074cd3b747864ffeaabbd530d30218\n\n    if (request.path.startsWith('http://') || request.path.startsWith('https://')) {\n      requestUrl = request.path;\n    } else {\n      requestUrl = this.protocol + '//' + (configuration.hostname || configuration.host) + (configuration.port === 80 || configuration.port === 443 ? '' : ':' + configuration.port) + request.path;\n    }\n\n    if (!this.isProxyConfigured()) {\n      log.trace({\n        destination: requestUrl\n      }, 'not proxying request; GLOBAL_AGENT.HTTP_PROXY is not configured'); // $FlowFixMe It appears that Flow is missing the method description.\n\n      this.fallbackAgent.addRequest(request, configuration);\n      return;\n    }\n\n    if (!this.mustUrlUseProxy(requestUrl)) {\n      log.trace({\n        destination: requestUrl\n      }, 'not proxying request; url matches GLOBAL_AGENT.NO_PROXY'); // $FlowFixMe It appears that Flow is missing the method description.\n\n      this.fallbackAgent.addRequest(request, configuration);\n      return;\n    }\n\n    const currentRequestId = requestId++;\n    const proxy = this.getUrlProxy(requestUrl);\n\n    if (this.protocol === 'http:') {\n      request.path = requestUrl;\n\n      if (proxy.authorization) {\n        request.setHeader('proxy-authorization', 'Basic ' + Buffer.from(proxy.authorization).toString('base64'));\n      }\n    }\n\n    log.trace({\n      destination: requestUrl,\n      proxy: 'http://' + proxy.hostname + ':' + proxy.port,\n      requestId: currentRequestId\n    }, 'proxying request');\n    request.on('error', error => {\n      log.error({\n        error: (0, _serializeError.serializeError)(error)\n      }, 'request error');\n    });\n    request.once('response', response => {\n      log.trace({\n        headers: response.headers,\n        requestId: currentRequestId,\n        statusCode: response.statusCode\n      }, 'proxying response');\n    });\n    request.shouldKeepAlive = false;\n    const connectionConfiguration = {\n      host: configuration.hostname || configuration.host,\n      port: configuration.port || 80,\n      proxy,\n      tls: {}\n    }; // add optional tls options for https requests.\n    // @see https://nodejs.org/docs/latest-v12.x/api/https.html#https_https_request_url_options_callback :\n    // > The following additional options from tls.connect()\n    // >   - https://nodejs.org/docs/latest-v12.x/api/tls.html#tls_tls_connect_options_callback -\n    // > are also accepted:\n    // >   ca, cert, ciphers, clientCertEngine, crl, dhparam, ecdhCurve, honorCipherOrder,\n    // >   key, passphrase, pfx, rejectUnauthorized, secureOptions, secureProtocol, servername, sessionIdContext.\n\n    if (this.protocol === 'https:') {\n      connectionConfiguration.tls = {\n        ca: configuration.ca,\n        cert: configuration.cert,\n        ciphers: configuration.ciphers,\n        clientCertEngine: configuration.clientCertEngine,\n        crl: configuration.crl,\n        dhparam: configuration.dhparam,\n        ecdhCurve: configuration.ecdhCurve,\n        honorCipherOrder: configuration.honorCipherOrder,\n        key: configuration.key,\n        passphrase: configuration.passphrase,\n        pfx: configuration.pfx,\n        rejectUnauthorized: configuration.rejectUnauthorized,\n        secureOptions: configuration.secureOptions,\n        secureProtocol: configuration.secureProtocol,\n        servername: configuration.servername || connectionConfiguration.host,\n        sessionIdContext: configuration.sessionIdContext\n      }; // This is not ideal because there is no way to override this setting using `tls` configuration if `NODE_TLS_REJECT_UNAUTHORIZED=0`.\n      // However, popular HTTP clients (such as https://github.com/sindresorhus/got) come with pre-configured value for `rejectUnauthorized`,\n      // which makes it impossible to override that value globally and respect `rejectUnauthorized` for specific requests only.\n      //\n      // eslint-disable-next-line no-process-env\n\n      if (typeof process.env.NODE_TLS_REJECT_UNAUTHORIZED === 'string' && (0, _boolean.boolean)(process.env.NODE_TLS_REJECT_UNAUTHORIZED) === false) {\n        connectionConfiguration.tls.rejectUnauthorized = false;\n      }\n    } // $FlowFixMe It appears that Flow is missing the method description.\n\n\n    this.createConnection(connectionConfiguration, (error, socket) => {\n      log.trace({\n        target: connectionConfiguration\n      }, 'connecting'); // @see https://github.com/nodejs/node/issues/5757#issuecomment-305969057\n\n      if (socket) {\n        socket.setTimeout(this.socketConnectionTimeout, () => {\n          socket.destroy();\n        });\n        socket.once('connect', () => {\n          log.trace({\n            target: connectionConfiguration\n          }, 'connected');\n          socket.setTimeout(0);\n        });\n        socket.once('secureConnect', () => {\n          log.trace({\n            target: connectionConfiguration\n          }, 'connected (secure)');\n          socket.setTimeout(0);\n        });\n      }\n\n      if (error) {\n        request.emit('error', error);\n      } else {\n        log.debug('created socket');\n        socket.on('error', socketError => {\n          log.error({\n            error: (0, _serializeError.serializeError)(socketError)\n          }, 'socket error');\n        });\n        request.onSocket(socket);\n      }\n    });\n  }\n\n}\n\nvar _default = Agent;\nexports.default = _default;","map":{"version":3,"sources":["../../src/classes/Agent.js"],"names":["log","namespace","requestId","constructor","addRequest","request","requestUrl","configuration","destination","currentRequestId","proxy","Buffer","error","response","headers","statusCode","connectionConfiguration","host","port","tls","ca","cert","ciphers","clientCertEngine","crl","dhparam","ecdhCurve","honorCipherOrder","key","passphrase","pfx","rejectUnauthorized","secureOptions","secureProtocol","servername","sessionIdContext","process","target","socket","socketError","Agent"],"mappings":"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","sourcesContent":["// @flow\n\nimport {\n  serializeError,\n} from 'serialize-error';\nimport {\n  boolean,\n} from 'boolean';\nimport Logger from '../Logger';\nimport type {\n  AgentType,\n  GetUrlProxyMethodType,\n  IsProxyConfiguredMethodType,\n  MustUrlUseProxyMethodType,\n  ProtocolType,\n} from '../types';\n\nconst log = Logger.child({\n  namespace: 'Agent',\n});\n\nlet requestId = 0;\n\nclass Agent {\n  defaultPort: number;\n\n  protocol: ProtocolType;\n\n  fallbackAgent: AgentType;\n\n  isProxyConfigured: IsProxyConfiguredMethodType;\n\n  mustUrlUseProxy: MustUrlUseProxyMethodType;\n\n  getUrlProxy: GetUrlProxyMethodType;\n\n  socketConnectionTimeout: number;\n\n  constructor (\n    isProxyConfigured: IsProxyConfiguredMethodType,\n    mustUrlUseProxy: MustUrlUseProxyMethodType,\n    getUrlProxy: GetUrlProxyMethodType,\n    fallbackAgent: AgentType,\n    socketConnectionTimeout: number,\n  ) {\n    this.fallbackAgent = fallbackAgent;\n    this.isProxyConfigured = isProxyConfigured;\n    this.mustUrlUseProxy = mustUrlUseProxy;\n    this.getUrlProxy = getUrlProxy;\n    this.socketConnectionTimeout = socketConnectionTimeout;\n  }\n\n  addRequest (request: *, configuration: *) {\n    let requestUrl;\n\n    // It is possible that addRequest was constructed for a proxied request already, e.g.\n    // \"request\" package does this when it detects that a proxy should be used\n    // https://github.com/request/request/blob/212570b6971a732b8dd9f3c73354bcdda158a737/request.js#L402\n    // https://gist.github.com/gajus/e2074cd3b747864ffeaabbd530d30218\n    if (request.path.startsWith('http://') || request.path.startsWith('https://')) {\n      requestUrl = request.path;\n    } else {\n      requestUrl = this.protocol + '//' + (configuration.hostname || configuration.host) + (configuration.port === 80 || configuration.port === 443 ? '' : ':' + configuration.port) + request.path;\n    }\n\n    if (!this.isProxyConfigured()) {\n      log.trace({\n        destination: requestUrl,\n      }, 'not proxying request; GLOBAL_AGENT.HTTP_PROXY is not configured');\n\n      // $FlowFixMe It appears that Flow is missing the method description.\n      this.fallbackAgent.addRequest(request, configuration);\n\n      return;\n    }\n\n    if (!this.mustUrlUseProxy(requestUrl)) {\n      log.trace({\n        destination: requestUrl,\n      }, 'not proxying request; url matches GLOBAL_AGENT.NO_PROXY');\n\n      // $FlowFixMe It appears that Flow is missing the method description.\n      this.fallbackAgent.addRequest(request, configuration);\n\n      return;\n    }\n\n    const currentRequestId = requestId++;\n\n    const proxy = this.getUrlProxy(requestUrl);\n\n    if (this.protocol === 'http:') {\n      request.path = requestUrl;\n\n      if (proxy.authorization) {\n        request.setHeader('proxy-authorization', 'Basic ' + Buffer.from(proxy.authorization).toString('base64'));\n      }\n    }\n\n    log.trace({\n      destination: requestUrl,\n      proxy: 'http://' + proxy.hostname + ':' + proxy.port,\n      requestId: currentRequestId,\n    }, 'proxying request');\n\n    request.on('error', (error) => {\n      log.error({\n        error: serializeError(error),\n      }, 'request error');\n    });\n\n    request.once('response', (response) => {\n      log.trace({\n        headers: response.headers,\n        requestId: currentRequestId,\n        statusCode: response.statusCode,\n      }, 'proxying response');\n    });\n\n    request.shouldKeepAlive = false;\n\n    const connectionConfiguration = {\n      host: configuration.hostname || configuration.host,\n      port: configuration.port || 80,\n      proxy,\n      tls: {},\n    };\n\n    // add optional tls options for https requests.\n    // @see https://nodejs.org/docs/latest-v12.x/api/https.html#https_https_request_url_options_callback :\n    // > The following additional options from tls.connect()\n    // >   - https://nodejs.org/docs/latest-v12.x/api/tls.html#tls_tls_connect_options_callback -\n    // > are also accepted:\n    // >   ca, cert, ciphers, clientCertEngine, crl, dhparam, ecdhCurve, honorCipherOrder,\n    // >   key, passphrase, pfx, rejectUnauthorized, secureOptions, secureProtocol, servername, sessionIdContext.\n    if (this.protocol === 'https:') {\n      connectionConfiguration.tls = {\n        ca: configuration.ca,\n        cert: configuration.cert,\n        ciphers: configuration.ciphers,\n        clientCertEngine: configuration.clientCertEngine,\n        crl: configuration.crl,\n        dhparam: configuration.dhparam,\n        ecdhCurve: configuration.ecdhCurve,\n        honorCipherOrder: configuration.honorCipherOrder,\n        key: configuration.key,\n        passphrase: configuration.passphrase,\n        pfx: configuration.pfx,\n        rejectUnauthorized: configuration.rejectUnauthorized,\n        secureOptions: configuration.secureOptions,\n        secureProtocol: configuration.secureProtocol,\n        servername: configuration.servername || connectionConfiguration.host,\n        sessionIdContext: configuration.sessionIdContext,\n      };\n\n      // This is not ideal because there is no way to override this setting using `tls` configuration if `NODE_TLS_REJECT_UNAUTHORIZED=0`.\n      // However, popular HTTP clients (such as https://github.com/sindresorhus/got) come with pre-configured value for `rejectUnauthorized`,\n      // which makes it impossible to override that value globally and respect `rejectUnauthorized` for specific requests only.\n      //\n      // eslint-disable-next-line no-process-env\n      if (typeof process.env.NODE_TLS_REJECT_UNAUTHORIZED === 'string' && boolean(process.env.NODE_TLS_REJECT_UNAUTHORIZED) === false) {\n        connectionConfiguration.tls.rejectUnauthorized = false;\n      }\n    }\n\n    // $FlowFixMe It appears that Flow is missing the method description.\n    this.createConnection(connectionConfiguration, (error, socket) => {\n      log.trace({\n        target: connectionConfiguration,\n      }, 'connecting');\n\n      // @see https://github.com/nodejs/node/issues/5757#issuecomment-305969057\n      if (socket) {\n        socket.setTimeout(this.socketConnectionTimeout, () => {\n          socket.destroy();\n        });\n\n        socket.once('connect', () => {\n          log.trace({\n            target: connectionConfiguration,\n          }, 'connected');\n\n          socket.setTimeout(0);\n        });\n\n        socket.once('secureConnect', () => {\n          log.trace({\n            target: connectionConfiguration,\n          }, 'connected (secure)');\n\n          socket.setTimeout(0);\n        });\n      }\n\n      if (error) {\n        request.emit('error', error);\n      } else {\n        log.debug('created socket');\n\n        socket.on('error', (socketError) => {\n          log.error({\n            error: serializeError(socketError),\n          }, 'socket error');\n        });\n\n        request.onSocket(socket);\n      }\n    });\n  }\n}\n\nexport default Agent;\n"]},"metadata":{},"sourceType":"script"}