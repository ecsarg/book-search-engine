{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar CharacterStream = function () {\n  function CharacterStream(sourceText) {\n    var _this = this;\n\n    _classCallCheck(this, CharacterStream);\n\n    this.getStartOfToken = function () {\n      return _this._start;\n    };\n\n    this.getCurrentPosition = function () {\n      return _this._pos;\n    };\n\n    this.eol = function () {\n      return _this._sourceText.length === _this._pos;\n    };\n\n    this.sol = function () {\n      return _this._pos === 0;\n    };\n\n    this.peek = function () {\n      return _this._sourceText.charAt(_this._pos) ? _this._sourceText.charAt(_this._pos) : null;\n    };\n\n    this.next = function () {\n      var char = _this._sourceText.charAt(_this._pos);\n\n      _this._pos++;\n      return char;\n    };\n\n    this.eat = function (pattern) {\n      var isMatched = _this._testNextCharacter(pattern);\n\n      if (isMatched) {\n        _this._start = _this._pos;\n        _this._pos++;\n        return _this._sourceText.charAt(_this._pos - 1);\n      }\n\n      return undefined;\n    };\n\n    this.eatWhile = function (match) {\n      var isMatched = _this._testNextCharacter(match);\n\n      var didEat = false; // If a match, treat the total upcoming matches as one token\n\n      if (isMatched) {\n        didEat = isMatched;\n        _this._start = _this._pos;\n      }\n\n      while (isMatched) {\n        _this._pos++;\n        isMatched = _this._testNextCharacter(match);\n        didEat = true;\n      }\n\n      return didEat;\n    };\n\n    this.eatSpace = function () {\n      return _this.eatWhile(/[\\s\\u00a0]/);\n    };\n\n    this.skipToEnd = function () {\n      _this._pos = _this._sourceText.length;\n    };\n\n    this.skipTo = function (position) {\n      _this._pos = position;\n    };\n\n    this.match = function (pattern) {\n      var consume = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var caseFold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var token = null;\n      var match = null;\n\n      if (typeof pattern === 'string') {\n        var regex = new RegExp(pattern, caseFold ? 'i' : 'g');\n        match = regex.test(_this._sourceText.substr(_this._pos, pattern.length));\n        token = pattern;\n      } else if (pattern instanceof RegExp) {\n        match = _this._sourceText.slice(_this._pos).match(pattern);\n        token = match && match[0];\n      }\n\n      if (match != null) {\n        if (typeof pattern === 'string' || match instanceof Array && // String.match returns 'index' property, which flow fails to detect\n        // for some reason. The below is a workaround, but an easier solution\n        // is just checking if `match.index === 0`\n        _this._sourceText.startsWith(match[0], _this._pos)) {\n          if (consume) {\n            _this._start = _this._pos;\n\n            if (token && token.length) {\n              _this._pos += token.length;\n            }\n          }\n\n          return match;\n        }\n      } // No match available.\n\n\n      return false;\n    };\n\n    this.backUp = function (num) {\n      _this._pos -= num;\n    };\n\n    this.column = function () {\n      return _this._pos;\n    };\n\n    this.indentation = function () {\n      var match = _this._sourceText.match(/\\s*/);\n\n      var indent = 0;\n\n      if (match && match.length === 0) {\n        var whitespaces = match[0];\n        var pos = 0;\n\n        while (whitespaces.length > pos) {\n          if (whitespaces.charCodeAt(pos) === 9) {\n            indent += 2;\n          } else {\n            indent++;\n          }\n\n          pos++;\n        }\n      }\n\n      return indent;\n    };\n\n    this.current = function () {\n      return _this._sourceText.slice(_this._start, _this._pos);\n    };\n\n    this._start = 0;\n    this._pos = 0;\n    this._sourceText = sourceText;\n  }\n\n  CharacterStream.prototype._testNextCharacter = function _testNextCharacter(pattern) {\n    var character = this._sourceText.charAt(this._pos);\n\n    var isMatched = false;\n\n    if (typeof pattern === 'string') {\n      isMatched = character === pattern;\n    } else {\n      isMatched = pattern instanceof RegExp ? pattern.test(character) : pattern(character);\n    }\n\n    return isMatched;\n  };\n\n  return CharacterStream;\n}();\n/**\n *  Copyright (c) Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the license found in the\n *  LICENSE file in the root directory of this source tree.\n *\n *  \n */\n\n/**\n * CharacterStream implements a stream of character tokens given a source text.\n * The API design follows that of CodeMirror.StringStream.\n *\n * Required:\n *\n *      sourceText: (string), A raw GraphQL source text. Works best if a line\n *        is supplied.\n *\n */\n\n\nexports.default = CharacterStream;","map":{"version":3,"names":["Object","defineProperty","exports","value","_classCallCheck","instance","Constructor","TypeError","CharacterStream","sourceText","_this","getStartOfToken","_start","getCurrentPosition","_pos","eol","_sourceText","length","sol","peek","charAt","next","char","eat","pattern","isMatched","_testNextCharacter","undefined","eatWhile","match","didEat","eatSpace","skipToEnd","skipTo","position","consume","arguments","caseFold","token","regex","RegExp","test","substr","slice","Array","startsWith","backUp","num","column","indentation","indent","whitespaces","pos","charCodeAt","current","prototype","character","default"],"sources":["/Users/Ellie/Desktop/projects/book-search-engine/client/node_modules/@apollographql/graphql-language-service-parser/dist/CharacterStream.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar CharacterStream = function () {\n  function CharacterStream(sourceText) {\n    var _this = this;\n\n    _classCallCheck(this, CharacterStream);\n\n    this.getStartOfToken = function () {\n      return _this._start;\n    };\n\n    this.getCurrentPosition = function () {\n      return _this._pos;\n    };\n\n    this.eol = function () {\n      return _this._sourceText.length === _this._pos;\n    };\n\n    this.sol = function () {\n      return _this._pos === 0;\n    };\n\n    this.peek = function () {\n      return _this._sourceText.charAt(_this._pos) ? _this._sourceText.charAt(_this._pos) : null;\n    };\n\n    this.next = function () {\n      var char = _this._sourceText.charAt(_this._pos);\n      _this._pos++;\n      return char;\n    };\n\n    this.eat = function (pattern) {\n      var isMatched = _this._testNextCharacter(pattern);\n      if (isMatched) {\n        _this._start = _this._pos;\n        _this._pos++;\n        return _this._sourceText.charAt(_this._pos - 1);\n      }\n      return undefined;\n    };\n\n    this.eatWhile = function (match) {\n      var isMatched = _this._testNextCharacter(match);\n      var didEat = false;\n\n      // If a match, treat the total upcoming matches as one token\n      if (isMatched) {\n        didEat = isMatched;\n        _this._start = _this._pos;\n      }\n\n      while (isMatched) {\n        _this._pos++;\n        isMatched = _this._testNextCharacter(match);\n        didEat = true;\n      }\n\n      return didEat;\n    };\n\n    this.eatSpace = function () {\n      return _this.eatWhile(/[\\s\\u00a0]/);\n    };\n\n    this.skipToEnd = function () {\n      _this._pos = _this._sourceText.length;\n    };\n\n    this.skipTo = function (position) {\n      _this._pos = position;\n    };\n\n    this.match = function (pattern) {\n      var consume = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var caseFold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var token = null;\n      var match = null;\n\n      if (typeof pattern === 'string') {\n        var regex = new RegExp(pattern, caseFold ? 'i' : 'g');\n        match = regex.test(_this._sourceText.substr(_this._pos, pattern.length));\n        token = pattern;\n      } else if (pattern instanceof RegExp) {\n        match = _this._sourceText.slice(_this._pos).match(pattern);\n        token = match && match[0];\n      }\n\n      if (match != null) {\n        if (typeof pattern === 'string' || match instanceof Array &&\n        // String.match returns 'index' property, which flow fails to detect\n        // for some reason. The below is a workaround, but an easier solution\n        // is just checking if `match.index === 0`\n        _this._sourceText.startsWith(match[0], _this._pos)) {\n          if (consume) {\n            _this._start = _this._pos;\n            if (token && token.length) {\n              _this._pos += token.length;\n            }\n          }\n          return match;\n        }\n      }\n\n      // No match available.\n      return false;\n    };\n\n    this.backUp = function (num) {\n      _this._pos -= num;\n    };\n\n    this.column = function () {\n      return _this._pos;\n    };\n\n    this.indentation = function () {\n      var match = _this._sourceText.match(/\\s*/);\n      var indent = 0;\n      if (match && match.length === 0) {\n        var whitespaces = match[0];\n        var pos = 0;\n        while (whitespaces.length > pos) {\n          if (whitespaces.charCodeAt(pos) === 9) {\n            indent += 2;\n          } else {\n            indent++;\n          }\n          pos++;\n        }\n      }\n\n      return indent;\n    };\n\n    this.current = function () {\n      return _this._sourceText.slice(_this._start, _this._pos);\n    };\n\n    this._start = 0;\n    this._pos = 0;\n    this._sourceText = sourceText;\n  }\n\n  CharacterStream.prototype._testNextCharacter = function _testNextCharacter(pattern) {\n    var character = this._sourceText.charAt(this._pos);\n    var isMatched = false;\n    if (typeof pattern === 'string') {\n      isMatched = character === pattern;\n    } else {\n      isMatched = pattern instanceof RegExp ? pattern.test(character) : pattern(character);\n    }\n    return isMatched;\n  };\n\n  return CharacterStream;\n}(); /**\n      *  Copyright (c) Facebook, Inc.\n      *  All rights reserved.\n      *\n      *  This source code is licensed under the license found in the\n      *  LICENSE file in the root directory of this source tree.\n      *\n      *  \n      */\n\n/**\n * CharacterStream implements a stream of character tokens given a source text.\n * The API design follows that of CodeMirror.StringStream.\n *\n * Required:\n *\n *      sourceText: (string), A raw GraphQL source text. Works best if a line\n *        is supplied.\n *\n */\n\nexports.default = CharacterStream;"],"mappings":"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"},"metadata":{},"sourceType":"script"}