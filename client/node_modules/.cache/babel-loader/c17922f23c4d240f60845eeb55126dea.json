{"ast":null,"code":"\"use strict\"; // tslint:disable interface-over-type-literal\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Parser = void 0;\n\nconst tslib_1 = require(\"tslib\");\n\nconst deps_1 = tslib_1.__importDefault(require(\"./deps\")); // eslint-disable-next-line new-cap\n\n\nconst m = deps_1.default() // eslint-disable-next-line node/no-missing-require\n.add('errors', () => require('./errors')) // eslint-disable-next-line node/no-missing-require\n.add('util', () => require('./util'));\nlet debug;\n\ntry {\n  // eslint-disable-next-line no-negated-condition\n  if (process.env.CLI_FLAGS_DEBUG !== '1') debug = () => {};else // eslint-disable-next-line node/no-extraneous-require\n    debug = require('debug')('@oclif/parser');\n} catch (_a) {\n  debug = () => {};\n}\n\nclass Parser {\n  constructor(input) {\n    this.input = input;\n    this.raw = [];\n    const {\n      pickBy\n    } = m.util;\n    this.context = input.context || {};\n    this.argv = input.argv.slice(0);\n\n    this._setNames();\n\n    this.booleanFlags = pickBy(input.flags, f => f.type === 'boolean');\n    this.metaData = {};\n  }\n\n  parse() {\n    this._debugInput();\n\n    const findLongFlag = arg => {\n      const name = arg.slice(2);\n\n      if (this.input.flags[name]) {\n        return name;\n      }\n\n      if (arg.startsWith('--no-')) {\n        const flag = this.booleanFlags[arg.slice(5)];\n        if (flag && flag.allowNo) return flag.name;\n      }\n    };\n\n    const findShortFlag = arg => {\n      return Object.keys(this.input.flags).find(k => this.input.flags[k].char === arg[1]);\n    };\n\n    const parseFlag = arg => {\n      const long = arg.startsWith('--');\n      const name = long ? findLongFlag(arg) : findShortFlag(arg);\n\n      if (!name) {\n        const i = arg.indexOf('=');\n\n        if (i !== -1) {\n          const sliced = arg.slice(i + 1);\n          this.argv.unshift(sliced);\n          const equalsParsed = parseFlag(arg.slice(0, i));\n\n          if (!equalsParsed) {\n            this.argv.shift();\n          }\n\n          return equalsParsed;\n        }\n\n        return false;\n      }\n\n      const flag = this.input.flags[name];\n\n      if (flag.type === 'option') {\n        this.currentFlag = flag;\n        let input;\n\n        if (long || arg.length < 3) {\n          input = this.argv.shift();\n        } else {\n          input = arg.slice(arg[2] === '=' ? 3 : 2);\n        }\n\n        if (typeof input !== 'string') {\n          throw new m.errors.CLIError(`Flag --${name} expects a value`);\n        }\n\n        this.raw.push({\n          type: 'flag',\n          flag: flag.name,\n          input\n        });\n      } else {\n        this.raw.push({\n          type: 'flag',\n          flag: flag.name,\n          input: arg\n        }); // push the rest of the short characters back on the stack\n\n        if (!long && arg.length > 2) {\n          this.argv.unshift(`-${arg.slice(2)}`);\n        }\n      }\n\n      return true;\n    };\n\n    let parsingFlags = true;\n\n    while (this.argv.length) {\n      const input = this.argv.shift();\n\n      if (parsingFlags && input.startsWith('-') && input !== '-') {\n        // attempt to parse as arg\n        if (this.input['--'] !== false && input === '--') {\n          parsingFlags = false;\n          continue;\n        }\n\n        if (parseFlag(input)) {\n          continue;\n        } // not actually a flag if it reaches here so parse as an arg\n\n      }\n\n      if (parsingFlags && this.currentFlag && this.currentFlag.multiple) {\n        this.raw.push({\n          type: 'flag',\n          flag: this.currentFlag.name,\n          input\n        });\n        continue;\n      } // not a flag, parse as arg\n\n\n      const arg = this.input.args[this._argTokens.length];\n      if (arg) arg.input = input;\n      this.raw.push({\n        type: 'arg',\n        input\n      });\n    }\n\n    const argv = this._argv();\n\n    const args = this._args(argv);\n\n    const flags = this._flags();\n\n    this._debugOutput(argv, args, flags);\n\n    return {\n      args,\n      argv,\n      flags,\n      raw: this.raw,\n      metadata: this.metaData\n    };\n  }\n\n  _args(argv) {\n    const args = {};\n\n    for (let i = 0; i < this.input.args.length; i++) {\n      const arg = this.input.args[i];\n      args[arg.name] = argv[i];\n    }\n\n    return args;\n  }\n\n  _flags() {\n    const flags = {};\n    this.metaData.flags = {};\n\n    for (const token of this._flagTokens) {\n      const flag = this.input.flags[token.flag];\n      if (!flag) throw new m.errors.CLIError(`Unexpected flag ${token.flag}`);\n\n      if (flag.type === 'boolean') {\n        if (token.input === `--no-${flag.name}`) {\n          flags[token.flag] = false;\n        } else {\n          flags[token.flag] = true;\n        }\n\n        flags[token.flag] = flag.parse(flags[token.flag], this.context);\n      } else {\n        const input = token.input;\n\n        if (flag.options && !flag.options.includes(input)) {\n          throw new m.errors.FlagInvalidOptionError(flag, input);\n        }\n\n        const value = flag.parse ? flag.parse(input, this.context) : input;\n\n        if (flag.multiple) {\n          flags[token.flag] = flags[token.flag] || [];\n          flags[token.flag].push(value);\n        } else {\n          flags[token.flag] = value;\n        }\n      }\n    }\n\n    for (const k of Object.keys(this.input.flags)) {\n      const flag = this.input.flags[k];\n      if (flags[k]) continue;\n\n      if (flag.type === 'option' && flag.env) {\n        const input = process.env[flag.env];\n        if (input) flags[k] = flag.parse(input, this.context);\n      }\n\n      if (!(k in flags) && flag.default !== undefined) {\n        this.metaData.flags[k] = {\n          setFromDefault: true\n        };\n\n        if (typeof flag.default === 'function') {\n          flags[k] = flag.default(Object.assign({\n            options: flag,\n            flags\n          }, this.context));\n        } else {\n          flags[k] = flag.default;\n        }\n      }\n    }\n\n    return flags;\n  }\n\n  _argv() {\n    const args = [];\n    const tokens = this._argTokens;\n\n    for (let i = 0; i < Math.max(this.input.args.length, tokens.length); i++) {\n      const token = tokens[i];\n      const arg = this.input.args[i];\n\n      if (token) {\n        if (arg) {\n          if (arg.options && !arg.options.includes(token.input)) {\n            throw new m.errors.ArgInvalidOptionError(arg, token.input);\n          }\n\n          args[i] = arg.parse(token.input);\n        } else {\n          args[i] = token.input;\n        }\n      } else if ('default' in arg) {\n        if (typeof arg.default === 'function') {\n          args[i] = arg.default();\n        } else {\n          args[i] = arg.default;\n        }\n      }\n    }\n\n    return args;\n  }\n\n  _debugOutput(args, flags, argv) {\n    if (argv.length > 0) {\n      debug('argv: %o', argv);\n    }\n\n    if (Object.keys(args).length > 0) {\n      debug('args: %o', args);\n    }\n\n    if (Object.keys(flags).length > 0) {\n      debug('flags: %o', flags);\n    }\n  }\n\n  _debugInput() {\n    debug('input: %s', this.argv.join(' '));\n\n    if (this.input.args.length > 0) {\n      debug('available args: %s', this.input.args.map(a => a.name).join(' '));\n    }\n\n    if (Object.keys(this.input.flags).length === 0) return;\n    debug('available flags: %s', Object.keys(this.input.flags).map(f => `--${f}`).join(' '));\n  }\n\n  get _argTokens() {\n    return this.raw.filter(o => o.type === 'arg');\n  }\n\n  get _flagTokens() {\n    return this.raw.filter(o => o.type === 'flag');\n  }\n\n  _setNames() {\n    for (const k of Object.keys(this.input.flags)) {\n      this.input.flags[k].name = k;\n    }\n  }\n\n}\n\nexports.Parser = Parser;","map":{"version":3,"names":["Object","defineProperty","exports","value","Parser","tslib_1","require","deps_1","__importDefault","m","default","add","debug","process","env","CLI_FLAGS_DEBUG","_a","constructor","input","raw","pickBy","util","context","argv","slice","_setNames","booleanFlags","flags","f","type","metaData","parse","_debugInput","findLongFlag","arg","name","startsWith","flag","allowNo","findShortFlag","keys","find","k","char","parseFlag","long","i","indexOf","sliced","unshift","equalsParsed","shift","currentFlag","length","errors","CLIError","push","parsingFlags","multiple","args","_argTokens","_argv","_args","_flags","_debugOutput","metadata","token","_flagTokens","options","includes","FlagInvalidOptionError","undefined","setFromDefault","assign","tokens","Math","max","ArgInvalidOptionError","join","map","a","filter","o"],"sources":["/Users/Ellie/Desktop/projects/book-search-engine/client/node_modules/@oclif/parser/lib/parse.js"],"sourcesContent":["\"use strict\";\n// tslint:disable interface-over-type-literal\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Parser = void 0;\nconst tslib_1 = require(\"tslib\");\nconst deps_1 = tslib_1.__importDefault(require(\"./deps\"));\n// eslint-disable-next-line new-cap\nconst m = deps_1.default()\n    // eslint-disable-next-line node/no-missing-require\n    .add('errors', () => require('./errors'))\n    // eslint-disable-next-line node/no-missing-require\n    .add('util', () => require('./util'));\nlet debug;\ntry {\n    // eslint-disable-next-line no-negated-condition\n    if (process.env.CLI_FLAGS_DEBUG !== '1')\n        debug = () => { };\n    else\n        // eslint-disable-next-line node/no-extraneous-require\n        debug = require('debug')('@oclif/parser');\n}\ncatch (_a) {\n    debug = () => { };\n}\nclass Parser {\n    constructor(input) {\n        this.input = input;\n        this.raw = [];\n        const { pickBy } = m.util;\n        this.context = input.context || {};\n        this.argv = input.argv.slice(0);\n        this._setNames();\n        this.booleanFlags = pickBy(input.flags, f => f.type === 'boolean');\n        this.metaData = {};\n    }\n    parse() {\n        this._debugInput();\n        const findLongFlag = (arg) => {\n            const name = arg.slice(2);\n            if (this.input.flags[name]) {\n                return name;\n            }\n            if (arg.startsWith('--no-')) {\n                const flag = this.booleanFlags[arg.slice(5)];\n                if (flag && flag.allowNo)\n                    return flag.name;\n            }\n        };\n        const findShortFlag = (arg) => {\n            return Object.keys(this.input.flags).find(k => this.input.flags[k].char === arg[1]);\n        };\n        const parseFlag = (arg) => {\n            const long = arg.startsWith('--');\n            const name = long ? findLongFlag(arg) : findShortFlag(arg);\n            if (!name) {\n                const i = arg.indexOf('=');\n                if (i !== -1) {\n                    const sliced = arg.slice(i + 1);\n                    this.argv.unshift(sliced);\n                    const equalsParsed = parseFlag(arg.slice(0, i));\n                    if (!equalsParsed) {\n                        this.argv.shift();\n                    }\n                    return equalsParsed;\n                }\n                return false;\n            }\n            const flag = this.input.flags[name];\n            if (flag.type === 'option') {\n                this.currentFlag = flag;\n                let input;\n                if (long || arg.length < 3) {\n                    input = this.argv.shift();\n                }\n                else {\n                    input = arg.slice(arg[2] === '=' ? 3 : 2);\n                }\n                if (typeof input !== 'string') {\n                    throw new m.errors.CLIError(`Flag --${name} expects a value`);\n                }\n                this.raw.push({ type: 'flag', flag: flag.name, input });\n            }\n            else {\n                this.raw.push({ type: 'flag', flag: flag.name, input: arg });\n                // push the rest of the short characters back on the stack\n                if (!long && arg.length > 2) {\n                    this.argv.unshift(`-${arg.slice(2)}`);\n                }\n            }\n            return true;\n        };\n        let parsingFlags = true;\n        while (this.argv.length) {\n            const input = this.argv.shift();\n            if (parsingFlags && input.startsWith('-') && input !== '-') {\n                // attempt to parse as arg\n                if (this.input['--'] !== false && input === '--') {\n                    parsingFlags = false;\n                    continue;\n                }\n                if (parseFlag(input)) {\n                    continue;\n                }\n                // not actually a flag if it reaches here so parse as an arg\n            }\n            if (parsingFlags && this.currentFlag && this.currentFlag.multiple) {\n                this.raw.push({ type: 'flag', flag: this.currentFlag.name, input });\n                continue;\n            }\n            // not a flag, parse as arg\n            const arg = this.input.args[this._argTokens.length];\n            if (arg)\n                arg.input = input;\n            this.raw.push({ type: 'arg', input });\n        }\n        const argv = this._argv();\n        const args = this._args(argv);\n        const flags = this._flags();\n        this._debugOutput(argv, args, flags);\n        return {\n            args,\n            argv,\n            flags,\n            raw: this.raw,\n            metadata: this.metaData,\n        };\n    }\n    _args(argv) {\n        const args = {};\n        for (let i = 0; i < this.input.args.length; i++) {\n            const arg = this.input.args[i];\n            args[arg.name] = argv[i];\n        }\n        return args;\n    }\n    _flags() {\n        const flags = {};\n        this.metaData.flags = {};\n        for (const token of this._flagTokens) {\n            const flag = this.input.flags[token.flag];\n            if (!flag)\n                throw new m.errors.CLIError(`Unexpected flag ${token.flag}`);\n            if (flag.type === 'boolean') {\n                if (token.input === `--no-${flag.name}`) {\n                    flags[token.flag] = false;\n                }\n                else {\n                    flags[token.flag] = true;\n                }\n                flags[token.flag] = flag.parse(flags[token.flag], this.context);\n            }\n            else {\n                const input = token.input;\n                if (flag.options && !flag.options.includes(input)) {\n                    throw new m.errors.FlagInvalidOptionError(flag, input);\n                }\n                const value = flag.parse ? flag.parse(input, this.context) : input;\n                if (flag.multiple) {\n                    flags[token.flag] = flags[token.flag] || [];\n                    flags[token.flag].push(value);\n                }\n                else {\n                    flags[token.flag] = value;\n                }\n            }\n        }\n        for (const k of Object.keys(this.input.flags)) {\n            const flag = this.input.flags[k];\n            if (flags[k])\n                continue;\n            if (flag.type === 'option' && flag.env) {\n                const input = process.env[flag.env];\n                if (input)\n                    flags[k] = flag.parse(input, this.context);\n            }\n            if (!(k in flags) && flag.default !== undefined) {\n                this.metaData.flags[k] = { setFromDefault: true };\n                if (typeof flag.default === 'function') {\n                    flags[k] = flag.default(Object.assign({ options: flag, flags }, this.context));\n                }\n                else {\n                    flags[k] = flag.default;\n                }\n            }\n        }\n        return flags;\n    }\n    _argv() {\n        const args = [];\n        const tokens = this._argTokens;\n        for (let i = 0; i < Math.max(this.input.args.length, tokens.length); i++) {\n            const token = tokens[i];\n            const arg = this.input.args[i];\n            if (token) {\n                if (arg) {\n                    if (arg.options && !arg.options.includes(token.input)) {\n                        throw new m.errors.ArgInvalidOptionError(arg, token.input);\n                    }\n                    args[i] = arg.parse(token.input);\n                }\n                else {\n                    args[i] = token.input;\n                }\n            }\n            else if ('default' in arg) {\n                if (typeof arg.default === 'function') {\n                    args[i] = arg.default();\n                }\n                else {\n                    args[i] = arg.default;\n                }\n            }\n        }\n        return args;\n    }\n    _debugOutput(args, flags, argv) {\n        if (argv.length > 0) {\n            debug('argv: %o', argv);\n        }\n        if (Object.keys(args).length > 0) {\n            debug('args: %o', args);\n        }\n        if (Object.keys(flags).length > 0) {\n            debug('flags: %o', flags);\n        }\n    }\n    _debugInput() {\n        debug('input: %s', this.argv.join(' '));\n        if (this.input.args.length > 0) {\n            debug('available args: %s', this.input.args.map(a => a.name).join(' '));\n        }\n        if (Object.keys(this.input.flags).length === 0)\n            return;\n        debug('available flags: %s', Object.keys(this.input.flags)\n            .map(f => `--${f}`)\n            .join(' '));\n    }\n    get _argTokens() {\n        return this.raw.filter(o => o.type === 'arg');\n    }\n    get _flagTokens() {\n        return this.raw.filter(o => o.type === 'flag');\n    }\n    _setNames() {\n        for (const k of Object.keys(this.input.flags)) {\n            this.input.flags[k].name = k;\n        }\n    }\n}\nexports.Parser = Parser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}