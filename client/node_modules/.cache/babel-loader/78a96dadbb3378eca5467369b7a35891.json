{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validate = void 0;\n\nconst errors_1 = require(\"@oclif/errors\");\n\nconst errors_2 = require(\"./errors\");\n\nfunction validate(parse) {\n  function validateArgs() {\n    const maxArgs = parse.input.args.length;\n\n    if (parse.input.strict && parse.output.argv.length > maxArgs) {\n      const extras = parse.output.argv.slice(maxArgs);\n      throw new errors_2.UnexpectedArgsError({\n        parse,\n        args: extras\n      });\n    }\n\n    const missingRequiredArgs = [];\n    let hasOptional = false;\n    parse.input.args.forEach((arg, index) => {\n      if (!arg.required) {\n        hasOptional = true;\n      } else if (hasOptional) {\n        // (required arg) check whether an optional has occurred before\n        // optionals should follow required, not before\n        throw new errors_2.InvalidArgsSpecError({\n          parse,\n          args: parse.input.args\n        });\n      }\n\n      if (arg.required) {\n        if (!parse.output.argv[index] && parse.output.argv[index] !== 0) {\n          missingRequiredArgs.push(arg);\n        }\n      }\n    });\n\n    if (missingRequiredArgs.length > 0) {\n      throw new errors_2.RequiredArgsError({\n        parse,\n        args: missingRequiredArgs\n      });\n    }\n  }\n\n  function validateAcrossFlags(flag) {\n    var _a;\n\n    const intersection = Object.entries(parse.input.flags).map(entry => entry[0]) // array of flag names\n    .filter(flagName => parse.output.flags[flagName] !== undefined) // with values\n    .filter(flagName => flag.exactlyOne && flag.exactlyOne.includes(flagName)); // and in the exactlyOne list\n\n    if (intersection.length === 0) {\n      // the command's exactlyOne may or may not include itself, so we'll use Set to add + de-dupe\n      throw new errors_1.CLIError(`Exactly one of the following must be provided: ${[...new Set((_a = flag.exactlyOne) === null || _a === void 0 ? void 0 : _a.map(flag => `--${flag}`))].join(', ')}`);\n    }\n  }\n\n  function validateFlags() {\n    for (const [name, flag] of Object.entries(parse.input.flags)) {\n      if (parse.output.flags[name] !== undefined) {\n        for (const also of flag.dependsOn || []) {\n          if (!parse.output.flags[also]) {\n            throw new errors_1.CLIError(`--${also}= must also be provided when using --${name}=`);\n          }\n        }\n\n        for (const also of flag.exclusive || []) {\n          // do not enforce exclusivity for flags that were defaulted\n          if (parse.output.metadata.flags[also] && parse.output.metadata.flags[also].setFromDefault) continue;\n          if (parse.output.metadata.flags[name] && parse.output.metadata.flags[name].setFromDefault) continue;\n\n          if (parse.output.flags[also]) {\n            throw new errors_1.CLIError(`--${also}= cannot also be provided when using --${name}=`);\n          }\n        }\n\n        for (const also of flag.exactlyOne || []) {\n          if (also !== name && parse.output.flags[also]) {\n            throw new errors_1.CLIError(`--${also}= cannot also be provided when using --${name}=`);\n          }\n        }\n      } else if (flag.required) {\n        throw new errors_2.RequiredFlagError({\n          parse,\n          flag\n        });\n      } else if (flag.exactlyOne && flag.exactlyOne.length > 0) {\n        validateAcrossFlags(flag);\n      }\n    }\n  }\n\n  validateArgs();\n  validateFlags();\n}\n\nexports.validate = validate;","map":{"version":3,"names":["Object","defineProperty","exports","value","validate","errors_1","require","errors_2","parse","validateArgs","maxArgs","input","args","length","strict","output","argv","extras","slice","UnexpectedArgsError","missingRequiredArgs","hasOptional","forEach","arg","index","required","InvalidArgsSpecError","push","RequiredArgsError","validateAcrossFlags","flag","_a","intersection","entries","flags","map","entry","filter","flagName","undefined","exactlyOne","includes","CLIError","Set","join","validateFlags","name","also","dependsOn","exclusive","metadata","setFromDefault","RequiredFlagError"],"sources":["/Users/Ellie/Desktop/projects/book-search-engine/client/node_modules/@oclif/parser/lib/validate.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validate = void 0;\nconst errors_1 = require(\"@oclif/errors\");\nconst errors_2 = require(\"./errors\");\nfunction validate(parse) {\n    function validateArgs() {\n        const maxArgs = parse.input.args.length;\n        if (parse.input.strict && parse.output.argv.length > maxArgs) {\n            const extras = parse.output.argv.slice(maxArgs);\n            throw new errors_2.UnexpectedArgsError({ parse, args: extras });\n        }\n        const missingRequiredArgs = [];\n        let hasOptional = false;\n        parse.input.args.forEach((arg, index) => {\n            if (!arg.required) {\n                hasOptional = true;\n            }\n            else if (hasOptional) {\n                // (required arg) check whether an optional has occurred before\n                // optionals should follow required, not before\n                throw new errors_2.InvalidArgsSpecError({ parse, args: parse.input.args });\n            }\n            if (arg.required) {\n                if (!parse.output.argv[index] && parse.output.argv[index] !== 0) {\n                    missingRequiredArgs.push(arg);\n                }\n            }\n        });\n        if (missingRequiredArgs.length > 0) {\n            throw new errors_2.RequiredArgsError({ parse, args: missingRequiredArgs });\n        }\n    }\n    function validateAcrossFlags(flag) {\n        var _a;\n        const intersection = Object.entries(parse.input.flags)\n            .map(entry => entry[0]) // array of flag names\n            .filter(flagName => parse.output.flags[flagName] !== undefined) // with values\n            .filter(flagName => flag.exactlyOne && flag.exactlyOne.includes(flagName)); // and in the exactlyOne list\n        if (intersection.length === 0) {\n            // the command's exactlyOne may or may not include itself, so we'll use Set to add + de-dupe\n            throw new errors_1.CLIError(`Exactly one of the following must be provided: ${[\n                ...new Set((_a = flag.exactlyOne) === null || _a === void 0 ? void 0 : _a.map(flag => `--${flag}`)),\n            ].join(', ')}`);\n        }\n    }\n    function validateFlags() {\n        for (const [name, flag] of Object.entries(parse.input.flags)) {\n            if (parse.output.flags[name] !== undefined) {\n                for (const also of flag.dependsOn || []) {\n                    if (!parse.output.flags[also]) {\n                        throw new errors_1.CLIError(`--${also}= must also be provided when using --${name}=`);\n                    }\n                }\n                for (const also of flag.exclusive || []) {\n                    // do not enforce exclusivity for flags that were defaulted\n                    if (parse.output.metadata.flags[also] &&\n                        parse.output.metadata.flags[also].setFromDefault)\n                        continue;\n                    if (parse.output.metadata.flags[name] &&\n                        parse.output.metadata.flags[name].setFromDefault)\n                        continue;\n                    if (parse.output.flags[also]) {\n                        throw new errors_1.CLIError(`--${also}= cannot also be provided when using --${name}=`);\n                    }\n                }\n                for (const also of flag.exactlyOne || []) {\n                    if (also !== name && parse.output.flags[also]) {\n                        throw new errors_1.CLIError(`--${also}= cannot also be provided when using --${name}=`);\n                    }\n                }\n            }\n            else if (flag.required) {\n                throw new errors_2.RequiredFlagError({ parse, flag });\n            }\n            else if (flag.exactlyOne && flag.exactlyOne.length > 0) {\n                validateAcrossFlags(flag);\n            }\n        }\n    }\n    validateArgs();\n    validateFlags();\n}\nexports.validate = validate;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}