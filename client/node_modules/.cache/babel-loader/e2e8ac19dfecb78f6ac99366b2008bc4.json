{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UniqueFieldDefinitionNames = exports.existedFieldDefinitionNameMessage = exports.duplicateFieldDefinitionNameMessage = void 0;\n\nconst graphql_1 = require(\"graphql\");\n\nconst utils_1 = require(\"../../utils\");\n\nfunction duplicateFieldDefinitionNameMessage(typeName, fieldName) {\n  return `Field \"${typeName}.${fieldName}\" can only be defined once.`;\n}\n\nexports.duplicateFieldDefinitionNameMessage = duplicateFieldDefinitionNameMessage;\n\nfunction existedFieldDefinitionNameMessage(typeName, fieldName, serviceName) {\n  return `${utils_1.logServiceAndType(serviceName, typeName, fieldName)}Field \"${typeName}.${fieldName}\" already exists in the schema. It cannot also be defined in this type extension. If this is meant to be an external field, add the \\`@external\\` directive.`;\n}\n\nexports.existedFieldDefinitionNameMessage = existedFieldDefinitionNameMessage;\n\nfunction UniqueFieldDefinitionNames(context) {\n  const schema = context.getSchema();\n  const existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);\n  const knownFieldNames = Object.create(null);\n  const possibleValueTypes = Object.create(null);\n  return {\n    InputObjectTypeExtension: checkFieldUniqueness,\n    InterfaceTypeExtension: checkFieldUniqueness,\n    ObjectTypeExtension: checkFieldUniqueness,\n    InputObjectTypeDefinition: checkFieldUniquenessExcludingValueTypes,\n    InterfaceTypeDefinition: checkFieldUniquenessExcludingValueTypes,\n    ObjectTypeDefinition: checkFieldUniquenessExcludingValueTypes\n  };\n\n  function checkFieldUniqueness(node) {\n    var _a;\n\n    const typeName = node.name.value;\n\n    if (!knownFieldNames[typeName]) {\n      knownFieldNames[typeName] = Object.create(null);\n    }\n\n    if (!node.fields) {\n      return false;\n    }\n\n    const fieldNames = knownFieldNames[typeName];\n\n    for (const fieldDef of node.fields) {\n      const fieldName = fieldDef.name.value;\n\n      if (hasField(existingTypeMap[typeName], fieldName)) {\n        const type = existingTypeMap[typeName];\n        context.reportError(new graphql_1.GraphQLError(existedFieldDefinitionNameMessage(typeName, fieldName, (_a = node.serviceName) !== null && _a !== void 0 ? _a : ''), graphql_1.isObjectType(type) || graphql_1.isInterfaceType(type) || graphql_1.isInputObjectType(type) ? type.getFields()[fieldName].astNode : undefined));\n      } else if (fieldNames[fieldName]) {\n        context.reportError(new graphql_1.GraphQLError(duplicateFieldDefinitionNameMessage(typeName, fieldName), [fieldNames[fieldName], fieldDef.name]));\n      } else {\n        fieldNames[fieldName] = fieldDef.name;\n      }\n    }\n\n    return false;\n  }\n\n  function checkFieldUniquenessExcludingValueTypes(node) {\n    const typeName = node.name.value;\n    const valueTypeFromSchema = existingTypeMap[typeName] && existingTypeMap[typeName].astNode;\n    const duplicateTypeNode = valueTypeFromSchema || possibleValueTypes[node.name.value];\n\n    if (duplicateTypeNode) {\n      const {\n        fields,\n        inputValues\n      } = utils_1.diffTypeNodes(node, duplicateTypeNode);\n\n      if (Object.values(fields).every(diffEntry => diffEntry.length === 2)) {\n        return false;\n      }\n\n      const inputValuesTypes = Object.values(inputValues);\n\n      if (inputValuesTypes.length > 0 && inputValuesTypes.every(diffEntry => diffEntry.length === 2)) {\n        return false;\n      }\n    } else {\n      possibleValueTypes[node.name.value] = node;\n    }\n\n    if (!knownFieldNames[typeName]) {\n      knownFieldNames[typeName] = Object.create(null);\n    }\n\n    if (!node.fields) {\n      return false;\n    }\n\n    const fieldNames = knownFieldNames[typeName];\n\n    for (const fieldDef of node.fields) {\n      const fieldName = fieldDef.name.value;\n\n      if (hasField(existingTypeMap[typeName], fieldName)) {\n        context.reportError(new graphql_1.GraphQLError(existedFieldDefinitionNameMessage(typeName, fieldName, existingTypeMap[typeName].astNode.serviceName), fieldDef.name));\n      } else if (fieldNames[fieldName]) {\n        context.reportError(new graphql_1.GraphQLError(duplicateFieldDefinitionNameMessage(typeName, fieldName), [fieldNames[fieldName], fieldDef.name]));\n      } else {\n        fieldNames[fieldName] = fieldDef.name;\n      }\n    }\n\n    return false;\n  }\n}\n\nexports.UniqueFieldDefinitionNames = UniqueFieldDefinitionNames;\n\nfunction hasField(type, fieldName) {\n  if (graphql_1.isObjectType(type) || graphql_1.isInterfaceType(type) || graphql_1.isInputObjectType(type)) {\n    return Boolean(type.getFields()[fieldName]);\n  }\n\n  return false;\n}","map":{"version":3,"sources":["../../../../src/composition/validate/sdl/uniqueFieldDefinitionNames.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UniqueFieldDefinitionNames = exports.existedFieldDefinitionNameMessage = exports.duplicateFieldDefinitionNameMessage = void 0;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"../../utils\");\nfunction duplicateFieldDefinitionNameMessage(typeName, fieldName) {\n    return `Field \"${typeName}.${fieldName}\" can only be defined once.`;\n}\nexports.duplicateFieldDefinitionNameMessage = duplicateFieldDefinitionNameMessage;\nfunction existedFieldDefinitionNameMessage(typeName, fieldName, serviceName) {\n    return `${utils_1.logServiceAndType(serviceName, typeName, fieldName)}Field \"${typeName}.${fieldName}\" already exists in the schema. It cannot also be defined in this type extension. If this is meant to be an external field, add the \\`@external\\` directive.`;\n}\nexports.existedFieldDefinitionNameMessage = existedFieldDefinitionNameMessage;\nfunction UniqueFieldDefinitionNames(context) {\n    const schema = context.getSchema();\n    const existingTypeMap = schema\n        ? schema.getTypeMap()\n        : Object.create(null);\n    const knownFieldNames = Object.create(null);\n    const possibleValueTypes = Object.create(null);\n    return {\n        InputObjectTypeExtension: checkFieldUniqueness,\n        InterfaceTypeExtension: checkFieldUniqueness,\n        ObjectTypeExtension: checkFieldUniqueness,\n        InputObjectTypeDefinition: checkFieldUniquenessExcludingValueTypes,\n        InterfaceTypeDefinition: checkFieldUniquenessExcludingValueTypes,\n        ObjectTypeDefinition: checkFieldUniquenessExcludingValueTypes,\n    };\n    function checkFieldUniqueness(node) {\n        var _a;\n        const typeName = node.name.value;\n        if (!knownFieldNames[typeName]) {\n            knownFieldNames[typeName] = Object.create(null);\n        }\n        if (!node.fields) {\n            return false;\n        }\n        const fieldNames = knownFieldNames[typeName];\n        for (const fieldDef of node.fields) {\n            const fieldName = fieldDef.name.value;\n            if (hasField(existingTypeMap[typeName], fieldName)) {\n                const type = existingTypeMap[typeName];\n                context.reportError(new graphql_1.GraphQLError(existedFieldDefinitionNameMessage(typeName, fieldName, (_a = node.serviceName) !== null && _a !== void 0 ? _a : ''), graphql_1.isObjectType(type) || graphql_1.isInterfaceType(type) || graphql_1.isInputObjectType(type) ?\n                    type.getFields()[fieldName].astNode : undefined));\n            }\n            else if (fieldNames[fieldName]) {\n                context.reportError(new graphql_1.GraphQLError(duplicateFieldDefinitionNameMessage(typeName, fieldName), [fieldNames[fieldName], fieldDef.name]));\n            }\n            else {\n                fieldNames[fieldName] = fieldDef.name;\n            }\n        }\n        return false;\n    }\n    function checkFieldUniquenessExcludingValueTypes(node) {\n        const typeName = node.name.value;\n        const valueTypeFromSchema = existingTypeMap[typeName] &&\n            existingTypeMap[typeName].astNode;\n        const duplicateTypeNode = valueTypeFromSchema || possibleValueTypes[node.name.value];\n        if (duplicateTypeNode) {\n            const { fields, inputValues } = utils_1.diffTypeNodes(node, duplicateTypeNode);\n            if (Object.values(fields).every(diffEntry => diffEntry.length === 2)) {\n                return false;\n            }\n            const inputValuesTypes = Object.values(inputValues);\n            if (inputValuesTypes.length > 0 &&\n                inputValuesTypes.every((diffEntry) => diffEntry.length === 2)) {\n                return false;\n            }\n        }\n        else {\n            possibleValueTypes[node.name.value] = node;\n        }\n        if (!knownFieldNames[typeName]) {\n            knownFieldNames[typeName] = Object.create(null);\n        }\n        if (!node.fields) {\n            return false;\n        }\n        const fieldNames = knownFieldNames[typeName];\n        for (const fieldDef of node.fields) {\n            const fieldName = fieldDef.name.value;\n            if (hasField(existingTypeMap[typeName], fieldName)) {\n                context.reportError(new graphql_1.GraphQLError(existedFieldDefinitionNameMessage(typeName, fieldName, existingTypeMap[typeName].astNode.serviceName), fieldDef.name));\n            }\n            else if (fieldNames[fieldName]) {\n                context.reportError(new graphql_1.GraphQLError(duplicateFieldDefinitionNameMessage(typeName, fieldName), [fieldNames[fieldName], fieldDef.name]));\n            }\n            else {\n                fieldNames[fieldName] = fieldDef.name;\n            }\n        }\n        return false;\n    }\n}\nexports.UniqueFieldDefinitionNames = UniqueFieldDefinitionNames;\nfunction hasField(type, fieldName) {\n    if (graphql_1.isObjectType(type) || graphql_1.isInterfaceType(type) || graphql_1.isInputObjectType(type)) {\n        return Boolean(type.getFields()[fieldName]);\n    }\n    return false;\n}\n//# sourceMappingURL=uniqueFieldDefinitionNames.js.map"]},"metadata":{},"sourceType":"script"}