{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MatchingEnums = void 0;\n\nconst graphql_1 = require(\"graphql\");\n\nconst utils_1 = require(\"../../utils\");\n\nconst isString = val => typeof val === 'string';\n\nfunction isEnumDefinition(node) {\n  return node.kind === graphql_1.Kind.ENUM_TYPE_DEFINITION;\n}\n\nfunction MatchingEnums(context) {\n  const {\n    definitions\n  } = context.getDocument();\n  let definitionsByName = definitions.reduce((typeToDefinitionsMap, node) => {\n    const name = node.name.value;\n\n    if (typeToDefinitionsMap[name]) {\n      typeToDefinitionsMap[name].push(node);\n    } else {\n      typeToDefinitionsMap[name] = [node];\n    }\n\n    return typeToDefinitionsMap;\n  }, {});\n\n  for (const [name, definitions] of Object.entries(definitionsByName)) {\n    if (definitions.every(isEnumDefinition)) {\n      let simpleEnumDefs = [];\n\n      for (const {\n        values,\n        serviceName\n      } of definitions) {\n        if (serviceName && values) simpleEnumDefs.push({\n          serviceName,\n          values: values.map(enumValue => enumValue.name.value)\n        });\n      }\n\n      for (const definition of simpleEnumDefs) {\n        definition.values = definition.values.sort();\n      }\n\n      let matchingEnumGroups = {};\n\n      for (const definition of simpleEnumDefs) {\n        const key = definition.values.join();\n\n        if (matchingEnumGroups[key]) {\n          matchingEnumGroups[key].push(definition.serviceName);\n        } else {\n          matchingEnumGroups[key] = [definition.serviceName];\n        }\n      }\n\n      if (Object.keys(matchingEnumGroups).length > 1) {\n        context.reportError(utils_1.errorWithCode('ENUM_MISMATCH', `The \\`${name}\\` enum does not have identical values in all services. Groups of services with identical values are: ${Object.values(matchingEnumGroups).map(serviceNames => `[${serviceNames.join(', ')}]`).join(', ')}`, definitions));\n      }\n    } else if (definitions.some(isEnumDefinition)) {\n      const servicesWithEnum = definitions.filter(isEnumDefinition).map(definition => definition.serviceName).filter(isString);\n      const servicesWithoutEnum = definitions.filter(d => !isEnumDefinition(d)).map(d => d.serviceName).filter(isString);\n      context.reportError(utils_1.errorWithCode('ENUM_MISMATCH_TYPE', utils_1.logServiceAndType(servicesWithEnum[0], name) + `${name} is an enum in [${servicesWithEnum.join(', ')}], but not in [${servicesWithoutEnum.join(', ')}]`, definitions));\n    }\n  }\n\n  return {};\n}\n\nexports.MatchingEnums = MatchingEnums;","map":{"version":3,"sources":["../../../../src/composition/validate/sdl/matchingEnums.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MatchingEnums = void 0;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"../../utils\");\nconst isString = (val) => typeof val === 'string';\nfunction isEnumDefinition(node) {\n    return node.kind === graphql_1.Kind.ENUM_TYPE_DEFINITION;\n}\nfunction MatchingEnums(context) {\n    const { definitions } = context.getDocument();\n    let definitionsByName = definitions.reduce((typeToDefinitionsMap, node) => {\n        const name = node.name.value;\n        if (typeToDefinitionsMap[name]) {\n            typeToDefinitionsMap[name].push(node);\n        }\n        else {\n            typeToDefinitionsMap[name] = [node];\n        }\n        return typeToDefinitionsMap;\n    }, {});\n    for (const [name, definitions] of Object.entries(definitionsByName)) {\n        if (definitions.every(isEnumDefinition)) {\n            let simpleEnumDefs = [];\n            for (const { values, serviceName, } of definitions) {\n                if (serviceName && values)\n                    simpleEnumDefs.push({\n                        serviceName,\n                        values: values.map((enumValue) => enumValue.name.value),\n                    });\n            }\n            for (const definition of simpleEnumDefs) {\n                definition.values = definition.values.sort();\n            }\n            let matchingEnumGroups = {};\n            for (const definition of simpleEnumDefs) {\n                const key = definition.values.join();\n                if (matchingEnumGroups[key]) {\n                    matchingEnumGroups[key].push(definition.serviceName);\n                }\n                else {\n                    matchingEnumGroups[key] = [definition.serviceName];\n                }\n            }\n            if (Object.keys(matchingEnumGroups).length > 1) {\n                context.reportError(utils_1.errorWithCode('ENUM_MISMATCH', `The \\`${name}\\` enum does not have identical values in all services. Groups of services with identical values are: ${Object.values(matchingEnumGroups)\n                    .map(serviceNames => `[${serviceNames.join(', ')}]`)\n                    .join(', ')}`, definitions));\n            }\n        }\n        else if (definitions.some(isEnumDefinition)) {\n            const servicesWithEnum = definitions\n                .filter(isEnumDefinition)\n                .map(definition => definition.serviceName)\n                .filter(isString);\n            const servicesWithoutEnum = definitions\n                .filter(d => !isEnumDefinition(d))\n                .map(d => d.serviceName)\n                .filter(isString);\n            context.reportError(utils_1.errorWithCode('ENUM_MISMATCH_TYPE', utils_1.logServiceAndType(servicesWithEnum[0], name) +\n                `${name} is an enum in [${servicesWithEnum.join(', ')}], but not in [${servicesWithoutEnum.join(', ')}]`, definitions));\n        }\n    }\n    return {};\n}\nexports.MatchingEnums = MatchingEnums;\n//# sourceMappingURL=matchingEnums.js.map"]},"metadata":{},"sourceType":"script"}