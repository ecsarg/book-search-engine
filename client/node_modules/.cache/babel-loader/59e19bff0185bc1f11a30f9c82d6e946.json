{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.composeServices = exports.addFederationMetadataToSchemaNodes = exports.buildSchemaFromDefinitionsAndExtensions = exports.buildMapsFromServiceList = void 0;\n\nconst graphql_1 = require(\"graphql\");\n\nconst apollo_graphql_1 = require(\"apollo-graphql\");\n\nconst directives_1 = __importStar(require(\"../directives\"));\n\nconst utils_1 = require(\"./utils\");\n\nconst validate_1 = require(\"graphql/validation/validate\");\n\nconst rules_1 = require(\"./rules\");\n\nconst printSupergraphSdl_1 = require(\"../service/printSupergraphSdl\");\n\nconst utilities_1 = require(\"../utilities\");\n\nconst EmptyQueryDefinition = {\n  kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,\n  name: {\n    kind: graphql_1.Kind.NAME,\n    value: utils_1.defaultRootOperationNameLookup.query\n  },\n  fields: [],\n  serviceName: null\n};\nconst EmptyMutationDefinition = {\n  kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,\n  name: {\n    kind: graphql_1.Kind.NAME,\n    value: utils_1.defaultRootOperationNameLookup.mutation\n  },\n  fields: [],\n  serviceName: null\n};\n\nfunction buildMapsFromServiceList(serviceList) {\n  var _a;\n\n  const typeDefinitionsMap = Object.create(null);\n  const typeExtensionsMap = Object.create(null);\n  const directiveDefinitionsMap = Object.create(null);\n  const typeToServiceMap = Object.create(null);\n  const externalFields = [];\n  const keyDirectivesMap = Object.create(null);\n  const valueTypes = new Set();\n  const typeNameToFieldDirectivesMap = new Map();\n  const otherKnownDirectiveUsages = new Set();\n\n  for (const {\n    typeDefs,\n    name: serviceName\n  } of serviceList) {\n    const {\n      typeDefsWithoutExternalFields,\n      strippedFields\n    } = utils_1.stripExternalFieldsFromTypeDefs(typeDefs, serviceName);\n    externalFields.push(...strippedFields);\n    const typeDefsWithoutTypeSystemDirectives = utils_1.stripTypeSystemDirectivesFromTypeDefs(typeDefsWithoutExternalFields);\n\n    for (const definition of typeDefsWithoutTypeSystemDirectives.definitions) {\n      if (definition.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION || definition.kind === graphql_1.Kind.OBJECT_TYPE_EXTENSION) {\n        const typeName = definition.name.value;\n\n        for (const keyDirective of utils_1.findDirectivesOnNode(definition, 'key')) {\n          if (keyDirective.arguments && utils_1.isStringValueNode(keyDirective.arguments[0].value)) {\n            keyDirectivesMap[typeName] = keyDirectivesMap[typeName] || {};\n            keyDirectivesMap[typeName][serviceName] = keyDirectivesMap[typeName][serviceName] || [];\n            keyDirectivesMap[typeName][serviceName].push(utils_1.parseSelections(keyDirective.arguments[0].value.value));\n          }\n        }\n\n        for (const field of (_a = definition.fields) !== null && _a !== void 0 ? _a : []) {\n          captureTagUsages(field, typeName, typeNameToFieldDirectivesMap, otherKnownDirectiveUsages);\n        }\n      }\n\n      if (graphql_1.isTypeDefinitionNode(definition)) {\n        const typeName = definition.name.value;\n\n        if (!typeToServiceMap[typeName]) {\n          typeToServiceMap[typeName] = {\n            extensionFieldsToOwningServiceMap: Object.create(null)\n          };\n        }\n\n        typeToServiceMap[typeName].owningService = serviceName;\n\n        if (typeDefinitionsMap[typeName]) {\n          const isValueType = utils_1.typeNodesAreEquivalent(typeDefinitionsMap[typeName][typeDefinitionsMap[typeName].length - 1], definition);\n\n          if (isValueType) {\n            valueTypes.add(typeName);\n          }\n\n          typeDefinitionsMap[typeName].push({ ...definition,\n            serviceName\n          });\n        } else {\n          typeDefinitionsMap[typeName] = [{ ...definition,\n            serviceName\n          }];\n        }\n      } else if (graphql_1.isTypeExtensionNode(definition)) {\n        const typeName = definition.name.value;\n\n        if (definition.kind === graphql_1.Kind.OBJECT_TYPE_EXTENSION || definition.kind === graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION) {\n          if (!definition.fields) break;\n          const fields = utils_1.mapFieldNamesToServiceName(definition.fields, serviceName);\n\n          if (typeToServiceMap[typeName]) {\n            typeToServiceMap[typeName].extensionFieldsToOwningServiceMap = { ...typeToServiceMap[typeName].extensionFieldsToOwningServiceMap,\n              ...fields\n            };\n          } else {\n            typeToServiceMap[typeName] = {\n              extensionFieldsToOwningServiceMap: fields\n            };\n          }\n        }\n\n        if (definition.kind === graphql_1.Kind.ENUM_TYPE_EXTENSION) {\n          if (!definition.values) break;\n          const values = utils_1.mapFieldNamesToServiceName(definition.values, serviceName);\n\n          if (typeToServiceMap[typeName]) {\n            typeToServiceMap[typeName].extensionFieldsToOwningServiceMap = { ...typeToServiceMap[typeName].extensionFieldsToOwningServiceMap,\n              ...values\n            };\n          } else {\n            typeToServiceMap[typeName] = {\n              extensionFieldsToOwningServiceMap: values\n            };\n          }\n        }\n\n        if (typeExtensionsMap[typeName]) {\n          typeExtensionsMap[typeName].push({ ...definition,\n            serviceName\n          });\n        } else {\n          typeExtensionsMap[typeName] = [{ ...definition,\n            serviceName\n          }];\n        }\n      } else if (utils_1.isDirectiveDefinitionNode(definition)) {\n        const directiveName = definition.name.value;\n        const executableLocations = definition.locations.filter(location => utils_1.executableDirectiveLocations.includes(location.value));\n        if (executableLocations.length === 0) continue;\n        const definitionWithExecutableLocations = { ...definition,\n          locations: executableLocations\n        };\n\n        if (directiveDefinitionsMap[directiveName]) {\n          directiveDefinitionsMap[directiveName][serviceName] = definitionWithExecutableLocations;\n        } else {\n          directiveDefinitionsMap[directiveName] = {\n            [serviceName]: definitionWithExecutableLocations\n          };\n        }\n      }\n    }\n  }\n\n  for (const {\n    parentTypeName,\n    field\n  } of externalFields) {\n    captureTagUsages(field, parentTypeName, typeNameToFieldDirectivesMap, otherKnownDirectiveUsages);\n  }\n\n  if (!typeDefinitionsMap.Query) typeDefinitionsMap.Query = [EmptyQueryDefinition];\n  if (typeExtensionsMap.Mutation && !typeDefinitionsMap.Mutation) typeDefinitionsMap.Mutation = [EmptyMutationDefinition];\n  return {\n    typeToServiceMap,\n    typeDefinitionsMap,\n    typeExtensionsMap,\n    directiveDefinitionsMap,\n    externalFields,\n    keyDirectivesMap,\n    valueTypes,\n    typeNameToFieldDirectivesMap,\n    otherKnownDirectiveUsages\n  };\n}\n\nexports.buildMapsFromServiceList = buildMapsFromServiceList;\n\nfunction captureTagUsages(field, typeName, typeNameToFieldDirectivesMap, otherKnownDirectiveUsages) {\n  const tagUsages = utils_1.findDirectivesOnNode(field, 'tag');\n\n  if (tagUsages.length > 0) {\n    otherKnownDirectiveUsages.add('tag');\n    const fieldToDirectivesMap = utilities_1.mapGetOrSet(typeNameToFieldDirectivesMap, typeName, new Map());\n    const directives = utilities_1.mapGetOrSet(fieldToDirectivesMap, field.name.value, []);\n    directives.push(...tagUsages);\n  }\n}\n\nfunction buildSchemaFromDefinitionsAndExtensions({\n  typeDefinitionsMap,\n  typeExtensionsMap,\n  directiveDefinitionsMap,\n  otherKnownDirectiveUsages\n}) {\n  let errors = undefined;\n  const otherKnownDirectiveDefinitionsToInclude = directives_1.otherKnownDirectiveDefinitions.filter(directive => otherKnownDirectiveUsages.has(directive.name));\n  let schema = new graphql_1.GraphQLSchema({\n    query: undefined,\n    directives: [...graphql_1.specifiedDirectives, ...directives_1.federationDirectives, ...otherKnownDirectiveDefinitionsToInclude]\n  });\n\n  function nodeHasInterfaces(node) {\n    return 'interfaces' in node;\n  }\n\n  const definitionsDocument = {\n    kind: graphql_1.Kind.DOCUMENT,\n    definitions: [...Object.values(typeDefinitionsMap).flatMap(typeDefinitions => {\n      if (!typeDefinitions.some(nodeHasInterfaces)) return typeDefinitions;\n      const uniqueInterfaces = typeDefinitions.reduce((map, objectTypeDef) => {\n        var _a;\n\n        (_a = objectTypeDef.interfaces) === null || _a === void 0 ? void 0 : _a.forEach(iface => map.set(iface.name.value, iface));\n        return map;\n      }, new Map());\n      if (uniqueInterfaces.size === 0) return typeDefinitions;\n      const [first, ...rest] = typeDefinitions;\n      return [...rest, { ...first,\n        interfaces: Array.from(uniqueInterfaces.values())\n      }];\n    }), ...Object.values(directiveDefinitionsMap).map(definitions => Object.values(definitions)[0])]\n  };\n  errors = validate_1.validateSDL(definitionsDocument, schema, rules_1.compositionRules);\n\n  try {\n    schema = graphql_1.extendSchema(schema, definitionsDocument, {\n      assumeValidSDL: true\n    });\n  } catch (e) {}\n\n  const extensionsDocument = {\n    kind: graphql_1.Kind.DOCUMENT,\n    definitions: Object.values(typeExtensionsMap).flat()\n  };\n  errors.push(...validate_1.validateSDL(extensionsDocument, schema, rules_1.compositionRules));\n\n  try {\n    schema = graphql_1.extendSchema(schema, extensionsDocument, {\n      assumeValidSDL: true\n    });\n  } catch {}\n\n  schema = new graphql_1.GraphQLSchema({ ...schema.toConfig(),\n    directives: [...schema.getDirectives().filter(x => !utils_1.isFederationDirective(x))]\n  });\n  return {\n    schema,\n    errors\n  };\n}\n\nexports.buildSchemaFromDefinitionsAndExtensions = buildSchemaFromDefinitionsAndExtensions;\n\nfunction addFederationMetadataToSchemaNodes({\n  schema,\n  typeToServiceMap,\n  externalFields,\n  keyDirectivesMap,\n  valueTypes,\n  directiveDefinitionsMap,\n  typeNameToFieldDirectivesMap\n}) {\n  var _a;\n\n  for (const [typeName, {\n    owningService,\n    extensionFieldsToOwningServiceMap\n  }] of Object.entries(typeToServiceMap)) {\n    const namedType = schema.getType(typeName);\n    if (!namedType) continue;\n    const isValueType = valueTypes.has(typeName);\n    const serviceName = isValueType ? null : owningService;\n    const federationMetadata = { ...utils_1.getFederationMetadata(namedType),\n      serviceName,\n      isValueType,\n      ...(keyDirectivesMap[typeName] && {\n        keys: keyDirectivesMap[typeName]\n      })\n    };\n    namedType.extensions = { ...namedType.extensions,\n      federation: federationMetadata\n    };\n\n    if (graphql_1.isObjectType(namedType)) {\n      for (const field of Object.values(namedType.getFields())) {\n        const [providesDirective] = utils_1.findDirectivesOnNode(field.astNode, 'provides');\n\n        if (providesDirective && providesDirective.arguments && utils_1.isStringValueNode(providesDirective.arguments[0].value)) {\n          const fieldFederationMetadata = { ...utils_1.getFederationMetadata(field),\n            serviceName,\n            provides: utils_1.parseSelections(providesDirective.arguments[0].value.value),\n            belongsToValueType: isValueType\n          };\n          field.extensions = { ...field.extensions,\n            federation: fieldFederationMetadata\n          };\n        }\n      }\n    }\n\n    for (const [fieldName, extendingServiceName] of Object.entries(extensionFieldsToOwningServiceMap)) {\n      if (graphql_1.isObjectType(namedType)) {\n        const field = namedType.getFields()[fieldName];\n        if (!field) continue;\n        const fieldFederationMetadata = { ...utils_1.getFederationMetadata(field),\n          serviceName: extendingServiceName\n        };\n        field.extensions = { ...field.extensions,\n          federation: fieldFederationMetadata\n        };\n        const [requiresDirective] = utils_1.findDirectivesOnNode(field.astNode, 'requires');\n\n        if (requiresDirective && requiresDirective.arguments && utils_1.isStringValueNode(requiresDirective.arguments[0].value)) {\n          const fieldFederationMetadata = { ...utils_1.getFederationMetadata(field),\n            requires: utils_1.parseSelections(requiresDirective.arguments[0].value.value)\n          };\n          field.extensions = { ...field.extensions,\n            federation: fieldFederationMetadata\n          };\n        }\n      }\n    }\n  }\n\n  for (const field of externalFields) {\n    const namedType = schema.getType(field.parentTypeName);\n    if (!namedType) continue;\n    const existingMetadata = utils_1.getFederationMetadata(namedType);\n    const typeFederationMetadata = { ...existingMetadata,\n      externals: { ...(existingMetadata === null || existingMetadata === void 0 ? void 0 : existingMetadata.externals),\n        [field.serviceName]: [...(((_a = existingMetadata === null || existingMetadata === void 0 ? void 0 : existingMetadata.externals) === null || _a === void 0 ? void 0 : _a[field.serviceName]) || []), field]\n      }\n    };\n    namedType.extensions = { ...namedType.extensions,\n      federation: typeFederationMetadata\n    };\n  }\n\n  for (const directiveName of Object.keys(directiveDefinitionsMap)) {\n    const directive = schema.getDirective(directiveName);\n    if (!directive) continue;\n    const directiveFederationMetadata = { ...utils_1.getFederationMetadata(directive),\n      directiveDefinitions: directiveDefinitionsMap[directiveName]\n    };\n    directive.extensions = { ...directive.extensions,\n      federation: directiveFederationMetadata\n    };\n  }\n\n  for (const [typeName, fieldsToDirectivesMap] of typeNameToFieldDirectivesMap.entries()) {\n    const type = schema.getType(typeName);\n    if (!type) continue;\n\n    for (const [fieldName, otherKnownDirectiveUsages] of fieldsToDirectivesMap.entries()) {\n      const field = type.getFields()[fieldName];\n      const seenNonRepeatableDirectives = {};\n      const filteredDirectives = otherKnownDirectiveUsages.filter(directive => {\n        const name = directive.name.value;\n        const matchingDirective = directives_1.default.find(d => d.name === name);\n        if (matchingDirective === null || matchingDirective === void 0 ? void 0 : matchingDirective.isRepeatable) return true;\n        if (seenNonRepeatableDirectives[name]) return false;\n        seenNonRepeatableDirectives[name] = true;\n        return true;\n      });\n      const existingMetadata = utils_1.getFederationMetadata(field);\n      const fieldFederationMetadata = { ...existingMetadata,\n        otherKnownDirectiveUsages: filteredDirectives\n      };\n      field.extensions = { ...field.extensions,\n        federation: fieldFederationMetadata\n      };\n    }\n  }\n}\n\nexports.addFederationMetadataToSchemaNodes = addFederationMetadataToSchemaNodes;\n\nfunction composeServices(services) {\n  const {\n    typeToServiceMap,\n    typeDefinitionsMap,\n    typeExtensionsMap,\n    directiveDefinitionsMap,\n    externalFields,\n    keyDirectivesMap,\n    valueTypes,\n    typeNameToFieldDirectivesMap,\n    otherKnownDirectiveUsages\n  } = buildMapsFromServiceList(services);\n  let {\n    schema,\n    errors\n  } = buildSchemaFromDefinitionsAndExtensions({\n    typeDefinitionsMap,\n    typeExtensionsMap,\n    directiveDefinitionsMap,\n    otherKnownDirectiveUsages\n  });\n  schema = new graphql_1.GraphQLSchema({ ...schema.toConfig(),\n    ...utilities_1.mapValues(utils_1.defaultRootOperationNameLookup, typeName => typeName ? schema.getType(typeName) : undefined),\n    extensions: {\n      serviceList: services\n    }\n  });\n  schema = apollo_graphql_1.transformSchema(schema, type => {\n    if (graphql_1.isObjectType(type)) {\n      const config = type.toConfig();\n      return new graphql_1.GraphQLObjectType({ ...config,\n        interfaces: Array.from(new Set(config.interfaces))\n      });\n    }\n\n    return undefined;\n  });\n  schema = graphql_1.lexicographicSortSchema(schema);\n  addFederationMetadataToSchemaNodes({\n    schema,\n    typeToServiceMap,\n    externalFields,\n    keyDirectivesMap,\n    valueTypes,\n    directiveDefinitionsMap,\n    typeNameToFieldDirectivesMap\n  });\n\n  if (errors.length > 0) {\n    return {\n      schema,\n      errors\n    };\n  } else {\n    return {\n      schema,\n      supergraphSdl: printSupergraphSdl_1.printSupergraphSdl(schema, services)\n    };\n  }\n}\n\nexports.composeServices = composeServices;","map":{"version":3,"sources":["../../src/composition/compose.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.composeServices = exports.addFederationMetadataToSchemaNodes = exports.buildSchemaFromDefinitionsAndExtensions = exports.buildMapsFromServiceList = void 0;\nconst graphql_1 = require(\"graphql\");\nconst apollo_graphql_1 = require(\"apollo-graphql\");\nconst directives_1 = __importStar(require(\"../directives\"));\nconst utils_1 = require(\"./utils\");\nconst validate_1 = require(\"graphql/validation/validate\");\nconst rules_1 = require(\"./rules\");\nconst printSupergraphSdl_1 = require(\"../service/printSupergraphSdl\");\nconst utilities_1 = require(\"../utilities\");\nconst EmptyQueryDefinition = {\n    kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,\n    name: { kind: graphql_1.Kind.NAME, value: utils_1.defaultRootOperationNameLookup.query },\n    fields: [],\n    serviceName: null,\n};\nconst EmptyMutationDefinition = {\n    kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,\n    name: { kind: graphql_1.Kind.NAME, value: utils_1.defaultRootOperationNameLookup.mutation },\n    fields: [],\n    serviceName: null,\n};\nfunction buildMapsFromServiceList(serviceList) {\n    var _a;\n    const typeDefinitionsMap = Object.create(null);\n    const typeExtensionsMap = Object.create(null);\n    const directiveDefinitionsMap = Object.create(null);\n    const typeToServiceMap = Object.create(null);\n    const externalFields = [];\n    const keyDirectivesMap = Object.create(null);\n    const valueTypes = new Set();\n    const typeNameToFieldDirectivesMap = new Map();\n    const otherKnownDirectiveUsages = new Set();\n    for (const { typeDefs, name: serviceName } of serviceList) {\n        const { typeDefsWithoutExternalFields, strippedFields, } = utils_1.stripExternalFieldsFromTypeDefs(typeDefs, serviceName);\n        externalFields.push(...strippedFields);\n        const typeDefsWithoutTypeSystemDirectives = utils_1.stripTypeSystemDirectivesFromTypeDefs(typeDefsWithoutExternalFields);\n        for (const definition of typeDefsWithoutTypeSystemDirectives.definitions) {\n            if (definition.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION ||\n                definition.kind === graphql_1.Kind.OBJECT_TYPE_EXTENSION) {\n                const typeName = definition.name.value;\n                for (const keyDirective of utils_1.findDirectivesOnNode(definition, 'key')) {\n                    if (keyDirective.arguments &&\n                        utils_1.isStringValueNode(keyDirective.arguments[0].value)) {\n                        keyDirectivesMap[typeName] = keyDirectivesMap[typeName] || {};\n                        keyDirectivesMap[typeName][serviceName] =\n                            keyDirectivesMap[typeName][serviceName] || [];\n                        keyDirectivesMap[typeName][serviceName].push(utils_1.parseSelections(keyDirective.arguments[0].value.value));\n                    }\n                }\n                for (const field of (_a = definition.fields) !== null && _a !== void 0 ? _a : []) {\n                    captureTagUsages(field, typeName, typeNameToFieldDirectivesMap, otherKnownDirectiveUsages);\n                }\n            }\n            if (graphql_1.isTypeDefinitionNode(definition)) {\n                const typeName = definition.name.value;\n                if (!typeToServiceMap[typeName]) {\n                    typeToServiceMap[typeName] = {\n                        extensionFieldsToOwningServiceMap: Object.create(null),\n                    };\n                }\n                typeToServiceMap[typeName].owningService = serviceName;\n                if (typeDefinitionsMap[typeName]) {\n                    const isValueType = utils_1.typeNodesAreEquivalent(typeDefinitionsMap[typeName][typeDefinitionsMap[typeName].length - 1], definition);\n                    if (isValueType) {\n                        valueTypes.add(typeName);\n                    }\n                    typeDefinitionsMap[typeName].push({ ...definition, serviceName });\n                }\n                else {\n                    typeDefinitionsMap[typeName] = [{ ...definition, serviceName }];\n                }\n            }\n            else if (graphql_1.isTypeExtensionNode(definition)) {\n                const typeName = definition.name.value;\n                if (definition.kind === graphql_1.Kind.OBJECT_TYPE_EXTENSION ||\n                    definition.kind === graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION) {\n                    if (!definition.fields)\n                        break;\n                    const fields = utils_1.mapFieldNamesToServiceName(definition.fields, serviceName);\n                    if (typeToServiceMap[typeName]) {\n                        typeToServiceMap[typeName].extensionFieldsToOwningServiceMap = {\n                            ...typeToServiceMap[typeName].extensionFieldsToOwningServiceMap,\n                            ...fields,\n                        };\n                    }\n                    else {\n                        typeToServiceMap[typeName] = {\n                            extensionFieldsToOwningServiceMap: fields,\n                        };\n                    }\n                }\n                if (definition.kind === graphql_1.Kind.ENUM_TYPE_EXTENSION) {\n                    if (!definition.values)\n                        break;\n                    const values = utils_1.mapFieldNamesToServiceName(definition.values, serviceName);\n                    if (typeToServiceMap[typeName]) {\n                        typeToServiceMap[typeName].extensionFieldsToOwningServiceMap = {\n                            ...typeToServiceMap[typeName].extensionFieldsToOwningServiceMap,\n                            ...values,\n                        };\n                    }\n                    else {\n                        typeToServiceMap[typeName] = {\n                            extensionFieldsToOwningServiceMap: values,\n                        };\n                    }\n                }\n                if (typeExtensionsMap[typeName]) {\n                    typeExtensionsMap[typeName].push({ ...definition, serviceName });\n                }\n                else {\n                    typeExtensionsMap[typeName] = [{ ...definition, serviceName }];\n                }\n            }\n            else if (utils_1.isDirectiveDefinitionNode(definition)) {\n                const directiveName = definition.name.value;\n                const executableLocations = definition.locations.filter(location => utils_1.executableDirectiveLocations.includes(location.value));\n                if (executableLocations.length === 0)\n                    continue;\n                const definitionWithExecutableLocations = {\n                    ...definition,\n                    locations: executableLocations,\n                };\n                if (directiveDefinitionsMap[directiveName]) {\n                    directiveDefinitionsMap[directiveName][serviceName] = definitionWithExecutableLocations;\n                }\n                else {\n                    directiveDefinitionsMap[directiveName] = {\n                        [serviceName]: definitionWithExecutableLocations,\n                    };\n                }\n            }\n        }\n    }\n    for (const { parentTypeName, field } of externalFields) {\n        captureTagUsages(field, parentTypeName, typeNameToFieldDirectivesMap, otherKnownDirectiveUsages);\n    }\n    if (!typeDefinitionsMap.Query)\n        typeDefinitionsMap.Query = [EmptyQueryDefinition];\n    if (typeExtensionsMap.Mutation && !typeDefinitionsMap.Mutation)\n        typeDefinitionsMap.Mutation = [EmptyMutationDefinition];\n    return {\n        typeToServiceMap,\n        typeDefinitionsMap,\n        typeExtensionsMap,\n        directiveDefinitionsMap,\n        externalFields,\n        keyDirectivesMap,\n        valueTypes,\n        typeNameToFieldDirectivesMap,\n        otherKnownDirectiveUsages,\n    };\n}\nexports.buildMapsFromServiceList = buildMapsFromServiceList;\nfunction captureTagUsages(field, typeName, typeNameToFieldDirectivesMap, otherKnownDirectiveUsages) {\n    const tagUsages = utils_1.findDirectivesOnNode(field, 'tag');\n    if (tagUsages.length > 0) {\n        otherKnownDirectiveUsages.add('tag');\n        const fieldToDirectivesMap = utilities_1.mapGetOrSet(typeNameToFieldDirectivesMap, typeName, new Map());\n        const directives = utilities_1.mapGetOrSet(fieldToDirectivesMap, field.name.value, []);\n        directives.push(...tagUsages);\n    }\n}\nfunction buildSchemaFromDefinitionsAndExtensions({ typeDefinitionsMap, typeExtensionsMap, directiveDefinitionsMap, otherKnownDirectiveUsages, }) {\n    let errors = undefined;\n    const otherKnownDirectiveDefinitionsToInclude = directives_1.otherKnownDirectiveDefinitions.filter((directive) => otherKnownDirectiveUsages.has(directive.name));\n    let schema = new graphql_1.GraphQLSchema({\n        query: undefined,\n        directives: [\n            ...graphql_1.specifiedDirectives,\n            ...directives_1.federationDirectives,\n            ...otherKnownDirectiveDefinitionsToInclude,\n        ],\n    });\n    function nodeHasInterfaces(node) {\n        return 'interfaces' in node;\n    }\n    const definitionsDocument = {\n        kind: graphql_1.Kind.DOCUMENT,\n        definitions: [\n            ...Object.values(typeDefinitionsMap).flatMap((typeDefinitions) => {\n                if (!typeDefinitions.some(nodeHasInterfaces))\n                    return typeDefinitions;\n                const uniqueInterfaces = typeDefinitions.reduce((map, objectTypeDef) => {\n                    var _a;\n                    (_a = objectTypeDef.interfaces) === null || _a === void 0 ? void 0 : _a.forEach((iface) => map.set(iface.name.value, iface));\n                    return map;\n                }, new Map());\n                if (uniqueInterfaces.size === 0)\n                    return typeDefinitions;\n                const [first, ...rest] = typeDefinitions;\n                return [\n                    ...rest,\n                    {\n                        ...first,\n                        interfaces: Array.from(uniqueInterfaces.values()),\n                    },\n                ];\n            }),\n            ...Object.values(directiveDefinitionsMap).map((definitions) => Object.values(definitions)[0]),\n        ],\n    };\n    errors = validate_1.validateSDL(definitionsDocument, schema, rules_1.compositionRules);\n    try {\n        schema = graphql_1.extendSchema(schema, definitionsDocument, {\n            assumeValidSDL: true,\n        });\n    }\n    catch (e) { }\n    const extensionsDocument = {\n        kind: graphql_1.Kind.DOCUMENT,\n        definitions: Object.values(typeExtensionsMap).flat(),\n    };\n    errors.push(...validate_1.validateSDL(extensionsDocument, schema, rules_1.compositionRules));\n    try {\n        schema = graphql_1.extendSchema(schema, extensionsDocument, {\n            assumeValidSDL: true,\n        });\n    }\n    catch { }\n    schema = new graphql_1.GraphQLSchema({\n        ...schema.toConfig(),\n        directives: [\n            ...schema.getDirectives().filter((x) => !utils_1.isFederationDirective(x)),\n        ],\n    });\n    return { schema, errors };\n}\nexports.buildSchemaFromDefinitionsAndExtensions = buildSchemaFromDefinitionsAndExtensions;\nfunction addFederationMetadataToSchemaNodes({ schema, typeToServiceMap, externalFields, keyDirectivesMap, valueTypes, directiveDefinitionsMap, typeNameToFieldDirectivesMap, }) {\n    var _a;\n    for (const [typeName, { owningService, extensionFieldsToOwningServiceMap },] of Object.entries(typeToServiceMap)) {\n        const namedType = schema.getType(typeName);\n        if (!namedType)\n            continue;\n        const isValueType = valueTypes.has(typeName);\n        const serviceName = isValueType ? null : owningService;\n        const federationMetadata = {\n            ...utils_1.getFederationMetadata(namedType),\n            serviceName,\n            isValueType,\n            ...(keyDirectivesMap[typeName] && {\n                keys: keyDirectivesMap[typeName],\n            }),\n        };\n        namedType.extensions = {\n            ...namedType.extensions,\n            federation: federationMetadata,\n        };\n        if (graphql_1.isObjectType(namedType)) {\n            for (const field of Object.values(namedType.getFields())) {\n                const [providesDirective] = utils_1.findDirectivesOnNode(field.astNode, 'provides');\n                if (providesDirective &&\n                    providesDirective.arguments &&\n                    utils_1.isStringValueNode(providesDirective.arguments[0].value)) {\n                    const fieldFederationMetadata = {\n                        ...utils_1.getFederationMetadata(field),\n                        serviceName,\n                        provides: utils_1.parseSelections(providesDirective.arguments[0].value.value),\n                        belongsToValueType: isValueType,\n                    };\n                    field.extensions = {\n                        ...field.extensions,\n                        federation: fieldFederationMetadata,\n                    };\n                }\n            }\n        }\n        for (const [fieldName, extendingServiceName] of Object.entries(extensionFieldsToOwningServiceMap)) {\n            if (graphql_1.isObjectType(namedType)) {\n                const field = namedType.getFields()[fieldName];\n                if (!field)\n                    continue;\n                const fieldFederationMetadata = {\n                    ...utils_1.getFederationMetadata(field),\n                    serviceName: extendingServiceName,\n                };\n                field.extensions = {\n                    ...field.extensions,\n                    federation: fieldFederationMetadata,\n                };\n                const [requiresDirective] = utils_1.findDirectivesOnNode(field.astNode, 'requires');\n                if (requiresDirective &&\n                    requiresDirective.arguments &&\n                    utils_1.isStringValueNode(requiresDirective.arguments[0].value)) {\n                    const fieldFederationMetadata = {\n                        ...utils_1.getFederationMetadata(field),\n                        requires: utils_1.parseSelections(requiresDirective.arguments[0].value.value),\n                    };\n                    field.extensions = {\n                        ...field.extensions,\n                        federation: fieldFederationMetadata,\n                    };\n                }\n            }\n        }\n    }\n    for (const field of externalFields) {\n        const namedType = schema.getType(field.parentTypeName);\n        if (!namedType)\n            continue;\n        const existingMetadata = utils_1.getFederationMetadata(namedType);\n        const typeFederationMetadata = {\n            ...existingMetadata,\n            externals: {\n                ...existingMetadata === null || existingMetadata === void 0 ? void 0 : existingMetadata.externals,\n                [field.serviceName]: [\n                    ...(((_a = existingMetadata === null || existingMetadata === void 0 ? void 0 : existingMetadata.externals) === null || _a === void 0 ? void 0 : _a[field.serviceName]) || []),\n                    field,\n                ],\n            },\n        };\n        namedType.extensions = {\n            ...namedType.extensions,\n            federation: typeFederationMetadata,\n        };\n    }\n    for (const directiveName of Object.keys(directiveDefinitionsMap)) {\n        const directive = schema.getDirective(directiveName);\n        if (!directive)\n            continue;\n        const directiveFederationMetadata = {\n            ...utils_1.getFederationMetadata(directive),\n            directiveDefinitions: directiveDefinitionsMap[directiveName],\n        };\n        directive.extensions = {\n            ...directive.extensions,\n            federation: directiveFederationMetadata,\n        };\n    }\n    for (const [typeName, fieldsToDirectivesMap] of typeNameToFieldDirectivesMap.entries()) {\n        const type = schema.getType(typeName);\n        if (!type)\n            continue;\n        for (const [fieldName, otherKnownDirectiveUsages,] of fieldsToDirectivesMap.entries()) {\n            const field = type.getFields()[fieldName];\n            const seenNonRepeatableDirectives = {};\n            const filteredDirectives = otherKnownDirectiveUsages.filter((directive) => {\n                const name = directive.name.value;\n                const matchingDirective = directives_1.default.find((d) => d.name === name);\n                if (matchingDirective === null || matchingDirective === void 0 ? void 0 : matchingDirective.isRepeatable)\n                    return true;\n                if (seenNonRepeatableDirectives[name])\n                    return false;\n                seenNonRepeatableDirectives[name] = true;\n                return true;\n            });\n            const existingMetadata = utils_1.getFederationMetadata(field);\n            const fieldFederationMetadata = {\n                ...existingMetadata,\n                otherKnownDirectiveUsages: filteredDirectives,\n            };\n            field.extensions = {\n                ...field.extensions,\n                federation: fieldFederationMetadata,\n            };\n        }\n    }\n}\nexports.addFederationMetadataToSchemaNodes = addFederationMetadataToSchemaNodes;\nfunction composeServices(services) {\n    const { typeToServiceMap, typeDefinitionsMap, typeExtensionsMap, directiveDefinitionsMap, externalFields, keyDirectivesMap, valueTypes, typeNameToFieldDirectivesMap, otherKnownDirectiveUsages, } = buildMapsFromServiceList(services);\n    let { schema, errors } = buildSchemaFromDefinitionsAndExtensions({\n        typeDefinitionsMap,\n        typeExtensionsMap,\n        directiveDefinitionsMap,\n        otherKnownDirectiveUsages,\n    });\n    schema = new graphql_1.GraphQLSchema({\n        ...schema.toConfig(),\n        ...utilities_1.mapValues(utils_1.defaultRootOperationNameLookup, typeName => typeName\n            ? schema.getType(typeName)\n            : undefined),\n        extensions: {\n            serviceList: services\n        }\n    });\n    schema = apollo_graphql_1.transformSchema(schema, type => {\n        if (graphql_1.isObjectType(type)) {\n            const config = type.toConfig();\n            return new graphql_1.GraphQLObjectType({\n                ...config,\n                interfaces: Array.from(new Set(config.interfaces)),\n            });\n        }\n        return undefined;\n    });\n    schema = graphql_1.lexicographicSortSchema(schema);\n    addFederationMetadataToSchemaNodes({\n        schema,\n        typeToServiceMap,\n        externalFields,\n        keyDirectivesMap,\n        valueTypes,\n        directiveDefinitionsMap,\n        typeNameToFieldDirectivesMap,\n    });\n    if (errors.length > 0) {\n        return { schema, errors };\n    }\n    else {\n        return {\n            schema,\n            supergraphSdl: printSupergraphSdl_1.printSupergraphSdl(schema, services),\n        };\n    }\n}\nexports.composeServices = composeServices;\n//# sourceMappingURL=compose.js.map"]},"metadata":{},"sourceType":"script"}