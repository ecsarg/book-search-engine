{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readFile = readFile;\nexports.readFileSync = readFileSync;\n\nvar _fs = _interopRequireDefault(require(\"fs\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nasync function fsReadFileAsync(pathname, encoding) {\n  return new Promise((resolve, reject) => {\n    _fs.default.readFile(pathname, encoding, (error, contents) => {\n      if (error) {\n        reject(error);\n        return;\n      }\n\n      resolve(contents);\n    });\n  });\n}\n\nasync function readFile(filepath, options = {}) {\n  const throwNotFound = options.throwNotFound === true;\n\n  try {\n    const content = await fsReadFileAsync(filepath, 'utf8');\n    return content;\n  } catch (error) {\n    if (throwNotFound === false && (error.code === 'ENOENT' || error.code === 'EISDIR')) {\n      return null;\n    }\n\n    throw error;\n  }\n}\n\nfunction readFileSync(filepath, options = {}) {\n  const throwNotFound = options.throwNotFound === true;\n\n  try {\n    const content = _fs.default.readFileSync(filepath, 'utf8');\n\n    return content;\n  } catch (error) {\n    if (throwNotFound === false && (error.code === 'ENOENT' || error.code === 'EISDIR')) {\n      return null;\n    }\n\n    throw error;\n  }\n}","map":{"version":3,"sources":["../src/readFile.ts"],"names":["fs","reject","resolve","options","throwNotFound","content","fsReadFileAsync","error"],"mappings":";;;;;;;;AAAA,IAAA,GAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,IAAA,CAAA,CAAA;;;;;;;;AAEA,eAAA,eAAA,CAAA,QAAA,EAAA,QAAA,EAGmB;EACjB,OAAO,IAAA,OAAA,CAAY,CAAA,OAAA,EAAA,MAAA,KAA2B;IAC5CA,GAAAA,CAAAA,OAAAA,CAAAA,QAAAA,CAAAA,QAAAA,EAAAA,QAAAA,EAAgC,CAAA,KAAA,EAAA,QAAA,KAA2B;MACzD,IAAA,KAAA,EAAW;QACTC,MAAM,CAANA,KAAM,CAANA;QACA;MACD;;MAEDC,OAAO,CAAPA,QAAO,CAAPA;IANFF,CAAAA;EADF,CAAO,CAAP;AAUD;;AAMD,eAAA,QAAA,CAAA,QAAA,EAEEG,OAAgB,GAFlB,EAAA,EAG0B;EACxB,MAAMC,aAAa,GAAGD,OAAO,CAAPA,aAAAA,KAAtB,IAAA;;EAEA,IAAI;IACF,MAAME,OAAO,GAAG,MAAMC,eAAe,CAAA,QAAA,EAArC,MAAqC,CAArC;IAEA,OAAA,OAAA;EAHF,CAAA,CAIE,OAAA,KAAA,EAAc;IACd,IACEF,aAAa,KAAbA,KAAAA,KACCG,KAAK,CAALA,IAAAA,KAAAA,QAAAA,IAA2BA,KAAK,CAALA,IAAAA,KAF9B,QACEH,CADF,EAGE;MACA,OAAA,IAAA;IACD;;IAED,MAAA,KAAA;EACD;AACF;;AAED,SAAA,YAAA,CAAA,QAAA,EAAwCD,OAAgB,GAAxD,EAAA,EAA8E;EAC5E,MAAMC,aAAa,GAAGD,OAAO,CAAPA,aAAAA,KAAtB,IAAA;;EAEA,IAAI;IACF,MAAME,OAAO,GAAGL,GAAAA,CAAAA,OAAAA,CAAAA,YAAAA,CAAAA,QAAAA,EAAhB,MAAgBA,CAAhB;;IAEA,OAAA,OAAA;EAHF,CAAA,CAIE,OAAA,KAAA,EAAc;IACd,IACEI,aAAa,KAAbA,KAAAA,KACCG,KAAK,CAALA,IAAAA,KAAAA,QAAAA,IAA2BA,KAAK,CAALA,IAAAA,KAF9B,QACEH,CADF,EAGE;MACA,OAAA,IAAA;IACD;;IAED,MAAA,KAAA;EACD;AACF","sourcesContent":["import fs from 'fs';\n\nasync function fsReadFileAsync(\n  pathname: string,\n  encoding: BufferEncoding,\n): Promise<string> {\n  return new Promise((resolve, reject): void => {\n    fs.readFile(pathname, encoding, (error, contents): void => {\n      if (error) {\n        reject(error);\n        return;\n      }\n\n      resolve(contents);\n    });\n  });\n}\n\ninterface Options {\n  throwNotFound?: boolean;\n}\n\nasync function readFile(\n  filepath: string,\n  options: Options = {},\n): Promise<string | null> {\n  const throwNotFound = options.throwNotFound === true;\n\n  try {\n    const content = await fsReadFileAsync(filepath, 'utf8');\n\n    return content;\n  } catch (error) {\n    if (\n      throwNotFound === false &&\n      (error.code === 'ENOENT' || error.code === 'EISDIR')\n    ) {\n      return null;\n    }\n\n    throw error;\n  }\n}\n\nfunction readFileSync(filepath: string, options: Options = {}): string | null {\n  const throwNotFound = options.throwNotFound === true;\n\n  try {\n    const content = fs.readFileSync(filepath, 'utf8');\n\n    return content;\n  } catch (error) {\n    if (\n      throwNotFound === false &&\n      (error.code === 'ENOENT' || error.code === 'EISDIR')\n    ) {\n      return null;\n    }\n\n    throw error;\n  }\n}\n\nexport { readFile, readFileSync };\n"]},"metadata":{},"sourceType":"script"}