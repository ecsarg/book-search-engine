{"ast":null,"code":"\"use strict\";\n\nvar _wrapRegExp = require(\"/Users/Ellie/Desktop/projects/book-search-engine/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapRegExp\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _url = require(\"url\");\n\nvar _matcher = _interopRequireDefault(require(\"matcher\"));\n\nvar _errors = require(\"../errors\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst isUrlMatchingNoProxy = (subjectUrl, noProxy) => {\n  const subjectUrlTokens = (0, _url.parse)(subjectUrl);\n  const rules = noProxy.split(/[\\s,]+/);\n\n  for (const rule of rules) {\n    const ruleMatch = rule.replace( /*#__PURE__*/_wrapRegExp(/^(\\.)/, {\n      leadingDot: 1\n    }), '*').match( /*#__PURE__*/_wrapRegExp(/^(.+?)(?::([0-9]+))?$/, {\n      hostname: 1,\n      port: 2\n    }));\n\n    if (!ruleMatch || !ruleMatch.groups) {\n      throw new _errors.UnexpectedStateError('Invalid NO_PROXY pattern.');\n    }\n\n    if (!ruleMatch.groups.hostname) {\n      throw new _errors.UnexpectedStateError('NO_PROXY entry pattern must include hostname. Use * to match any hostname.');\n    }\n\n    const hostnameIsMatch = _matcher.default.isMatch(subjectUrlTokens.hostname, ruleMatch.groups.hostname);\n\n    if (hostnameIsMatch && (!ruleMatch.groups || !ruleMatch.groups.port || subjectUrlTokens.port && subjectUrlTokens.port === ruleMatch.groups.port)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nvar _default = isUrlMatchingNoProxy;\nexports.default = _default;","map":{"version":3,"sources":["../../src/utilities/isUrlMatchingNoProxy.js"],"names":["subjectUrl","noProxy","subjectUrlTokens","rules","ruleMatch","rule","UnexpectedStateError","hostnameIsMatch","matcher"],"mappings":";;;;;;;;;AAEA,IAAA,IAAA,GAAA,OAAA,CAAA,KAAA,CAAA;;AAGA,IAAA,QAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,SAAA,CAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;;;;;;;8BAIgBA,U,EAAoBC,O,KAAoB;EACtD,MAAMC,gBAAgB,GAAG,CAAA,GAAA,IAAA,CAAA,KAAA,EAAzB,UAAyB,CAAzB;EAEA,MAAMC,KAAK,GAAGF,OAAO,CAAPA,KAAAA,CAAd,QAAcA,CAAd;;EAEA,KAAK,MAAL,IAAA,IAAA,KAAA,EAA0B;IACxB,MAAMG,SAAS,GAAGC,IAAI,CAAJA,OAAAA,2BAAAA,OAAAA;MAAAA;IAAAA,IAAAA,GAAAA,EAAAA,KAAAA,2BAAlB,uBAAkBA;MAAAA;MAAAA;IAAAA,GAAlB;;IAIA,IAAI,CAAA,SAAA,IAAc,CAACD,SAAS,CAA5B,MAAA,EAAqC;MACnC,MAAM,IAAIE,OAAAA,CAAJ,oBAAA,CAAN,2BAAM,CAAN;IACD;;IAED,IAAI,CAACF,SAAS,CAATA,MAAAA,CAAL,QAAA,EAAgC;MAC9B,MAAM,IAAIE,OAAAA,CAAJ,oBAAA,CAAN,4EAAM,CAAN;IACD;;IAED,MAAMC,eAAe,GAAGC,QAAAA,CAAAA,OAAAA,CAAAA,OAAAA,CAAgBN,gBAAgB,CAAhCM,QAAAA,EAA2CJ,SAAS,CAATA,MAAAA,CAAnE,QAAwBI,CAAxB;;IAEA,IAAID,eAAe,KAAK,CAACH,SAAS,CAAV,MAAA,IAAqB,CAACA,SAAS,CAATA,MAAAA,CAAtB,IAAA,IAA+CF,gBAAgB,CAAhBA,IAAAA,IAAyBA,gBAAgB,CAAhBA,IAAAA,KAA0BE,SAAS,CAATA,MAAAA,CAA1H,IAAmB,CAAnB,EAAkJ;MAChJ,OAAA,IAAA;IACD;EACF;;EAED,OAAA,KAAA","sourcesContent":["// @flow\n\nimport {\n  parse as parseUrl,\n} from 'url';\nimport matcher from 'matcher';\nimport {\n  UnexpectedStateError,\n} from '../errors';\n\nexport default (subjectUrl: string, noProxy: string) => {\n  const subjectUrlTokens = parseUrl(subjectUrl);\n\n  const rules = noProxy.split(/[\\s,]+/);\n\n  for (const rule of rules) {\n    const ruleMatch = rule\n      .replace(/^(?<leadingDot>\\.)/, '*')\n      .match(/^(?<hostname>.+?)(?::(?<port>\\d+))?$/);\n\n    if (!ruleMatch || !ruleMatch.groups) {\n      throw new UnexpectedStateError('Invalid NO_PROXY pattern.');\n    }\n\n    if (!ruleMatch.groups.hostname) {\n      throw new UnexpectedStateError('NO_PROXY entry pattern must include hostname. Use * to match any hostname.');\n    }\n\n    const hostnameIsMatch = matcher.isMatch(subjectUrlTokens.hostname, ruleMatch.groups.hostname);\n\n    if (hostnameIsMatch && (!ruleMatch.groups || !ruleMatch.groups.port || subjectUrlTokens.port && subjectUrlTokens.port === ruleMatch.groups.port)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n"]},"metadata":{},"sourceType":"script"}