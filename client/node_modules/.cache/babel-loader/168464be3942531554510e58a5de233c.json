{"ast":null,"code":"const minimatch = module.exports = (p, pattern, options = {}) => {\n  assertValidPattern(pattern); // shortcut: comments match nothing.\n\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false;\n  }\n\n  return new Minimatch(pattern, options).match(p);\n};\n\nmodule.exports = minimatch;\n\nconst path = require('./lib/path.js');\n\nminimatch.sep = path.sep;\nconst GLOBSTAR = Symbol('globstar **');\nminimatch.GLOBSTAR = GLOBSTAR;\n\nconst expand = require('brace-expansion');\n\nconst plTypes = {\n  '!': {\n    open: '(?:(?!(?:',\n    close: '))[^/]*?)'\n  },\n  '?': {\n    open: '(?:',\n    close: ')?'\n  },\n  '+': {\n    open: '(?:',\n    close: ')+'\n  },\n  '*': {\n    open: '(?:',\n    close: ')*'\n  },\n  '@': {\n    open: '(?:',\n    close: ')'\n  }\n}; // any single thing other than /\n// don't need to escape / when using new RegExp()\n\nconst qmark = '[^/]'; // * => any number of characters\n\nconst star = qmark + '*?'; // ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\n\nconst twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'; // not a ^ or / followed by a dot,\n// followed by anything, any number of times.\n\nconst twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'; // \"abc\" -> { a:true, b:true, c:true }\n\nconst charSet = s => s.split('').reduce((set, c) => {\n  set[c] = true;\n  return set;\n}, {}); // characters that need to be escaped in RegExp.\n\n\nconst reSpecials = charSet('().*{}+?[]^$\\\\!'); // characters that indicate we have to add the pattern start\n\nconst addPatternStartSet = charSet('[.('); // normalizes slashes.\n\nconst slashSplit = /\\/+/;\n\nminimatch.filter = (pattern, options = {}) => (p, i, list) => minimatch(p, pattern, options);\n\nconst ext = (a, b = {}) => {\n  const t = {};\n  Object.keys(a).forEach(k => t[k] = a[k]);\n  Object.keys(b).forEach(k => t[k] = b[k]);\n  return t;\n};\n\nminimatch.defaults = def => {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch;\n  }\n\n  const orig = minimatch;\n\n  const m = (p, pattern, options) => orig(p, pattern, ext(def, options));\n\n  m.Minimatch = class Minimatch extends orig.Minimatch {\n    constructor(pattern, options) {\n      super(pattern, ext(def, options));\n    }\n\n  };\n\n  m.Minimatch.defaults = options => orig.defaults(ext(def, options)).Minimatch;\n\n  m.filter = (pattern, options) => orig.filter(pattern, ext(def, options));\n\n  m.defaults = options => orig.defaults(ext(def, options));\n\n  m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options));\n\n  m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options));\n\n  m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options));\n\n  return m;\n}; // Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\n\n\nminimatch.braceExpand = (pattern, options) => braceExpand(pattern, options);\n\nconst braceExpand = (pattern, options = {}) => {\n  assertValidPattern(pattern); // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern];\n  }\n\n  return expand(pattern);\n};\n\nconst MAX_PATTERN_LENGTH = 1024 * 64;\n\nconst assertValidPattern = pattern => {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern');\n  }\n\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long');\n  }\n}; // parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\n\n\nconst SUBPARSE = Symbol('subparse');\n\nminimatch.makeRe = (pattern, options) => new Minimatch(pattern, options || {}).makeRe();\n\nminimatch.match = (list, pattern, options = {}) => {\n  const mm = new Minimatch(pattern, options);\n  list = list.filter(f => mm.match(f));\n\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern);\n  }\n\n  return list;\n}; // replace stuff like \\* with *\n\n\nconst globUnescape = s => s.replace(/\\\\(.)/g, '$1');\n\nconst regExpEscape = s => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n\nclass Minimatch {\n  constructor(pattern, options) {\n    assertValidPattern(pattern);\n    if (!options) options = {};\n    this.options = options;\n    this.set = [];\n    this.pattern = pattern;\n    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n\n    if (this.windowsPathsNoEscape) {\n      this.pattern = this.pattern.replace(/\\\\/g, '/');\n    }\n\n    this.regexp = null;\n    this.negate = false;\n    this.comment = false;\n    this.empty = false;\n    this.partial = !!options.partial; // make the set of regexps etc.\n\n    this.make();\n  }\n\n  debug() {}\n\n  make() {\n    const pattern = this.pattern;\n    const options = this.options; // empty patterns and comments match nothing.\n\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n      this.comment = true;\n      return;\n    }\n\n    if (!pattern) {\n      this.empty = true;\n      return;\n    } // step 1: figure out negation, etc.\n\n\n    this.parseNegate(); // step 2: expand braces\n\n    let set = this.globSet = this.braceExpand();\n    if (options.debug) this.debug = (...args) => console.error(...args);\n    this.debug(this.pattern, set); // step 3: now we have a set, so turn each one into a series of path-portion\n    // matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n\n    set = this.globParts = set.map(s => s.split(slashSplit));\n    this.debug(this.pattern, set); // glob --> regexps\n\n    set = set.map((s, si, set) => s.map(this.parse, this));\n    this.debug(this.pattern, set); // filter out everything that didn't compile properly.\n\n    set = set.filter(s => s.indexOf(false) === -1);\n    this.debug(this.pattern, set);\n    this.set = set;\n  }\n\n  parseNegate() {\n    if (this.options.nonegate) return;\n    const pattern = this.pattern;\n    let negate = false;\n    let negateOffset = 0;\n\n    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n      negate = !negate;\n      negateOffset++;\n    }\n\n    if (negateOffset) this.pattern = pattern.substr(negateOffset);\n    this.negate = negate;\n  } // set partial to true to test if, for example,\n  // \"/a/b\" matches the start of \"/*/b/*/d\"\n  // Partial means, if you run out of file before you run\n  // out of pattern, then that's fine, as long as all\n  // the parts match.\n\n\n  matchOne(file, pattern, partial) {\n    var options = this.options;\n    this.debug('matchOne', {\n      'this': this,\n      file: file,\n      pattern: pattern\n    });\n    this.debug('matchOne', file.length, pattern.length);\n\n    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n      this.debug('matchOne loop');\n      var p = pattern[pi];\n      var f = file[fi];\n      this.debug(pattern, p, f); // should be impossible.\n      // some invalid regexp stuff in the set.\n\n      /* istanbul ignore if */\n\n      if (p === false) return false;\n\n      if (p === GLOBSTAR) {\n        this.debug('GLOBSTAR', [pattern, p, f]); // \"**\"\n        // a/**/b/**/c would match the following:\n        // a/b/x/y/z/c\n        // a/x/y/z/b/c\n        // a/b/x/b/x/c\n        // a/b/c\n        // To do this, take the rest of the pattern after\n        // the **, and see if it would match the file remainder.\n        // If so, return success.\n        // If not, the ** \"swallows\" a segment, and try again.\n        // This is recursively awful.\n        //\n        // a/**/b/**/c matching a/b/x/y/z/c\n        // - a matches a\n        // - doublestar\n        //   - matchOne(b/x/y/z/c, b/**/c)\n        //     - b matches b\n        //     - doublestar\n        //       - matchOne(x/y/z/c, c) -> no\n        //       - matchOne(y/z/c, c) -> no\n        //       - matchOne(z/c, c) -> no\n        //       - matchOne(c, c) yes, hit\n\n        var fr = fi;\n        var pr = pi + 1;\n\n        if (pr === pl) {\n          this.debug('** at the end'); // a ** at the end will just swallow the rest.\n          // We have found a match.\n          // however, it will not swallow /.x, unless\n          // options.dot is set.\n          // . and .. are *never* matched by **, for explosively\n          // exponential reasons.\n\n          for (; fi < fl; fi++) {\n            if (file[fi] === '.' || file[fi] === '..' || !options.dot && file[fi].charAt(0) === '.') return false;\n          }\n\n          return true;\n        } // ok, let's see if we can swallow whatever we can.\n\n\n        while (fr < fl) {\n          var swallowee = file[fr];\n          this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee); // XXX remove this slice.  Just pass the start index.\n\n          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n            this.debug('globstar found match!', fr, fl, swallowee); // found a match.\n\n            return true;\n          } else {\n            // can't swallow \".\" or \"..\" ever.\n            // can only swallow \".foo\" when explicitly asked.\n            if (swallowee === '.' || swallowee === '..' || !options.dot && swallowee.charAt(0) === '.') {\n              this.debug('dot detected!', file, fr, pattern, pr);\n              break;\n            } // ** swallows a segment, and continue.\n\n\n            this.debug('globstar swallow a segment, and continue');\n            fr++;\n          }\n        } // no match was found.\n        // However, in partial mode, we can't say this is necessarily over.\n        // If there's more *pattern* left, then\n\n        /* istanbul ignore if */\n\n\n        if (partial) {\n          // ran out of file\n          this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n          if (fr === fl) return true;\n        }\n\n        return false;\n      } // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n\n\n      var hit;\n\n      if (typeof p === 'string') {\n        hit = f === p;\n        this.debug('string match', p, f, hit);\n      } else {\n        hit = f.match(p);\n        this.debug('pattern match', p, f, hit);\n      }\n\n      if (!hit) return false;\n    } // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n    // now either we fell off the end of the pattern, or we're done.\n\n\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true;\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial;\n    } else\n      /* istanbul ignore else */\n      if (pi === pl) {\n        // ran out of pattern, still have file left.\n        // this is only acceptable if we're on the very last\n        // empty segment of a file with a trailing slash.\n        // a/* should match a/b/\n        return fi === fl - 1 && file[fi] === '';\n      } // should be unreachable.\n\n    /* istanbul ignore next */\n\n\n    throw new Error('wtf?');\n  }\n\n  braceExpand() {\n    return braceExpand(this.pattern, this.options);\n  }\n\n  parse(pattern, isSub) {\n    assertValidPattern(pattern);\n    const options = this.options; // shortcuts\n\n    if (pattern === '**') {\n      if (!options.noglobstar) return GLOBSTAR;else pattern = '*';\n    }\n\n    if (pattern === '') return '';\n    let re = '';\n    let hasMagic = !!options.nocase;\n    let escaping = false; // ? => one single character\n\n    const patternListStack = [];\n    const negativeLists = [];\n    let stateChar;\n    let inClass = false;\n    let reClassStart = -1;\n    let classStart = -1;\n    let cs;\n    let pl;\n    let sp; // . and .. never match anything that doesn't start with .,\n    // even when options.dot is set.\n\n    const patternStart = pattern.charAt(0) === '.' ? '' // anything\n    // not (start or / followed by . or .. followed by / or end)\n    : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))' : '(?!\\\\.)';\n\n    const clearStateChar = () => {\n      if (stateChar) {\n        // we had some state-tracking character\n        // that wasn't consumed by this pass.\n        switch (stateChar) {\n          case '*':\n            re += star;\n            hasMagic = true;\n            break;\n\n          case '?':\n            re += qmark;\n            hasMagic = true;\n            break;\n\n          default:\n            re += '\\\\' + stateChar;\n            break;\n        }\n\n        this.debug('clearStateChar %j %j', stateChar, re);\n        stateChar = false;\n      }\n    };\n\n    for (let i = 0, c; i < pattern.length && (c = pattern.charAt(i)); i++) {\n      this.debug('%s\\t%s %s %j', pattern, i, re, c); // skip over any that are escaped.\n\n      if (escaping) {\n        /* istanbul ignore next - completely not allowed, even escaped. */\n        if (c === '/') {\n          return false;\n        }\n\n        if (reSpecials[c]) {\n          re += '\\\\';\n        }\n\n        re += c;\n        escaping = false;\n        continue;\n      }\n\n      switch (c) {\n        /* istanbul ignore next */\n        case '/':\n          {\n            // Should already be path-split by now.\n            return false;\n          }\n\n        case '\\\\':\n          clearStateChar();\n          escaping = true;\n          continue;\n        // the various stateChar values\n        // for the \"extglob\" stuff.\n\n        case '?':\n        case '*':\n        case '+':\n        case '@':\n        case '!':\n          this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c); // all of those are literals inside a class, except that\n          // the glob [!a] means [^a] in regexp\n\n          if (inClass) {\n            this.debug('  in class');\n            if (c === '!' && i === classStart + 1) c = '^';\n            re += c;\n            continue;\n          } // if we already have a stateChar, then it means\n          // that there was something like ** or +? in there.\n          // Handle the stateChar, then proceed with this one.\n\n\n          this.debug('call clearStateChar %j', stateChar);\n          clearStateChar();\n          stateChar = c; // if extglob is disabled, then +(asdf|foo) isn't a thing.\n          // just clear the statechar *now*, rather than even diving into\n          // the patternList stuff.\n\n          if (options.noext) clearStateChar();\n          continue;\n\n        case '(':\n          if (inClass) {\n            re += '(';\n            continue;\n          }\n\n          if (!stateChar) {\n            re += '\\\\(';\n            continue;\n          }\n\n          patternListStack.push({\n            type: stateChar,\n            start: i - 1,\n            reStart: re.length,\n            open: plTypes[stateChar].open,\n            close: plTypes[stateChar].close\n          }); // negation is (?:(?!js)[^/]*)\n\n          re += stateChar === '!' ? '(?:(?!(?:' : '(?:';\n          this.debug('plType %j %j', stateChar, re);\n          stateChar = false;\n          continue;\n\n        case ')':\n          if (inClass || !patternListStack.length) {\n            re += '\\\\)';\n            continue;\n          }\n\n          clearStateChar();\n          hasMagic = true;\n          pl = patternListStack.pop(); // negation is (?:(?!js)[^/]*)\n          // The others are (?:<pattern>)<type>\n\n          re += pl.close;\n\n          if (pl.type === '!') {\n            negativeLists.push(pl);\n          }\n\n          pl.reEnd = re.length;\n          continue;\n\n        case '|':\n          if (inClass || !patternListStack.length) {\n            re += '\\\\|';\n            continue;\n          }\n\n          clearStateChar();\n          re += '|';\n          continue;\n        // these are mostly the same in regexp and glob\n\n        case '[':\n          // swallow any state-tracking char before the [\n          clearStateChar();\n\n          if (inClass) {\n            re += '\\\\' + c;\n            continue;\n          }\n\n          inClass = true;\n          classStart = i;\n          reClassStart = re.length;\n          re += c;\n          continue;\n\n        case ']':\n          //  a right bracket shall lose its special\n          //  meaning and represent itself in\n          //  a bracket expression if it occurs\n          //  first in the list.  -- POSIX.2 2.8.3.2\n          if (i === classStart + 1 || !inClass) {\n            re += '\\\\' + c;\n            continue;\n          } // handle the case where we left a class open.\n          // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n\n\n          cs = pattern.substring(classStart + 1, i);\n\n          try {\n            RegExp('[' + cs + ']');\n          } catch (er) {\n            // not a valid class!\n            sp = this.parse(cs, SUBPARSE);\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]';\n            hasMagic = hasMagic || sp[1];\n            inClass = false;\n            continue;\n          } // finish up the class.\n\n\n          hasMagic = true;\n          inClass = false;\n          re += c;\n          continue;\n\n        default:\n          // swallow any state char that wasn't consumed\n          clearStateChar();\n\n          if (reSpecials[c] && !(c === '^' && inClass)) {\n            re += '\\\\';\n          }\n\n          re += c;\n          break;\n      } // switch\n\n    } // for\n    // handle the case where we left a class open.\n    // \"[abc\" is valid, equivalent to \"\\[abc\"\n\n\n    if (inClass) {\n      // split where the last [ was, and escape it\n      // this is a huge pita.  We now have to re-walk\n      // the contents of the would-be class to re-translate\n      // any characters that were passed through as-is\n      cs = pattern.substr(classStart + 1);\n      sp = this.parse(cs, SUBPARSE);\n      re = re.substr(0, reClassStart) + '\\\\[' + sp[0];\n      hasMagic = hasMagic || sp[1];\n    } // handle the case where we had a +( thing at the *end*\n    // of the pattern.\n    // each pattern list stack adds 3 chars, and we need to go through\n    // and escape any | chars that were passed through as-is for the regexp.\n    // Go through and escape them, taking care not to double-escape any\n    // | chars that were already escaped.\n\n\n    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n      let tail;\n      tail = re.slice(pl.reStart + pl.open.length);\n      this.debug('setting tail', re, pl); // maybe some even number of \\, then maybe 1 \\, followed by a |\n\n      tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, (_, $1, $2) => {\n        /* istanbul ignore else - should already be done */\n        if (!$2) {\n          // the | isn't already escaped, so escape it.\n          $2 = '\\\\';\n        } // need to escape all those slashes *again*, without escaping the\n        // one that we need for escaping the | character.  As it works out,\n        // escaping an even number of slashes can be done by simply repeating\n        // it exactly after itself.  That's why this trick works.\n        //\n        // I am sorry that you have to see this.\n\n\n        return $1 + $1 + $2 + '|';\n      });\n      this.debug('tail=%j\\n   %s', tail, tail, pl, re);\n      const t = pl.type === '*' ? star : pl.type === '?' ? qmark : '\\\\' + pl.type;\n      hasMagic = true;\n      re = re.slice(0, pl.reStart) + t + '\\\\(' + tail;\n    } // handle trailing things that only matter at the very end.\n\n\n    clearStateChar();\n\n    if (escaping) {\n      // trailing \\\\\n      re += '\\\\\\\\';\n    } // only need to apply the nodot start if the re starts with\n    // something that could conceivably capture a dot\n\n\n    const addPatternStart = addPatternStartSet[re.charAt(0)]; // Hack to work around lack of negative lookbehind in JS\n    // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n    // like 'a.xyz.yz' doesn't match.  So, the first negative\n    // lookahead, has to look ALL the way ahead, to the end of\n    // the pattern.\n\n    for (let n = negativeLists.length - 1; n > -1; n--) {\n      const nl = negativeLists[n];\n      const nlBefore = re.slice(0, nl.reStart);\n      const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);\n      let nlAfter = re.slice(nl.reEnd);\n      const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter; // Handle nested stuff like *(*.js|!(*.json)), where open parens\n      // mean that we should *not* include the ) in the bit that is considered\n      // \"after\" the negated section.\n\n      const openParensBefore = nlBefore.split('(').length - 1;\n      let cleanAfter = nlAfter;\n\n      for (let i = 0; i < openParensBefore; i++) {\n        cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '');\n      }\n\n      nlAfter = cleanAfter;\n      const dollar = nlAfter === '' && isSub !== SUBPARSE ? '$' : '';\n      re = nlBefore + nlFirst + nlAfter + dollar + nlLast;\n    } // if the re is not \"\" at this point, then we need to make sure\n    // it doesn't match against an empty path part.\n    // Otherwise a/* will match a/, which it should not.\n\n\n    if (re !== '' && hasMagic) {\n      re = '(?=.)' + re;\n    }\n\n    if (addPatternStart) {\n      re = patternStart + re;\n    } // parsing just a piece of a larger pattern.\n\n\n    if (isSub === SUBPARSE) {\n      return [re, hasMagic];\n    } // skip the regexp for non-magical patterns\n    // unescape anything in it, though, so that it'll be\n    // an exact match against a file etc.\n\n\n    if (!hasMagic) {\n      return globUnescape(pattern);\n    }\n\n    const flags = options.nocase ? 'i' : '';\n\n    try {\n      return Object.assign(new RegExp('^' + re + '$', flags), {\n        _glob: pattern,\n        _src: re\n      });\n    } catch (er)\n    /* istanbul ignore next - should be impossible */\n    {\n      // If it was an invalid regular expression, then it can't match\n      // anything.  This trick looks for a character after the end of\n      // the string, which is of course impossible, except in multi-line\n      // mode, but it's not a /m regex.\n      return new RegExp('$.');\n    }\n  }\n\n  makeRe() {\n    if (this.regexp || this.regexp === false) return this.regexp; // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n\n    const set = this.set;\n\n    if (!set.length) {\n      this.regexp = false;\n      return this.regexp;\n    }\n\n    const options = this.options;\n    const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;\n    const flags = options.nocase ? 'i' : ''; // coalesce globstars and regexpify non-globstar patterns\n    // if it's the only item, then we just do one twoStar\n    // if it's the first, and there are more, prepend (\\/|twoStar\\/)? to next\n    // if it's the last, append (\\/twoStar|) to previous\n    // if it's in the middle, append (\\/|\\/twoStar\\/) to previous\n    // then filter out GLOBSTAR symbols\n\n    let re = set.map(pattern => {\n      pattern = pattern.map(p => typeof p === 'string' ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src).reduce((set, p) => {\n        if (!(set[set.length - 1] === GLOBSTAR && p === GLOBSTAR)) {\n          set.push(p);\n        }\n\n        return set;\n      }, []);\n      pattern.forEach((p, i) => {\n        if (p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR) {\n          return;\n        }\n\n        if (i === 0) {\n          if (pattern.length > 1) {\n            pattern[i + 1] = '(?:\\\\\\/|' + twoStar + '\\\\\\/)?' + pattern[i + 1];\n          } else {\n            pattern[i] = twoStar;\n          }\n        } else if (i === pattern.length - 1) {\n          pattern[i - 1] += '(?:\\\\\\/|' + twoStar + ')?';\n        } else {\n          pattern[i - 1] += '(?:\\\\\\/|\\\\\\/' + twoStar + '\\\\\\/)' + pattern[i + 1];\n          pattern[i + 1] = GLOBSTAR;\n        }\n      });\n      return pattern.filter(p => p !== GLOBSTAR).join('/');\n    }).join('|'); // must match entire pattern\n    // ending in a * or ** will make it less strict.\n\n    re = '^(?:' + re + ')$'; // can match anything, as long as it's not this.\n\n    if (this.negate) re = '^(?!' + re + ').*$';\n\n    try {\n      this.regexp = new RegExp(re, flags);\n    } catch (ex)\n    /* istanbul ignore next - should be impossible */\n    {\n      this.regexp = false;\n    }\n\n    return this.regexp;\n  }\n\n  match(f, partial = this.partial) {\n    this.debug('match', f, this.pattern); // short-circuit in the case of busted things.\n    // comments, etc.\n\n    if (this.comment) return false;\n    if (this.empty) return f === '';\n    if (f === '/' && partial) return true;\n    const options = this.options; // windows: need to use /, not \\\n\n    if (path.sep !== '/') {\n      f = f.split(path.sep).join('/');\n    } // treat the test path as a set of pathparts.\n\n\n    f = f.split(slashSplit);\n    this.debug(this.pattern, 'split', f); // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n\n    const set = this.set;\n    this.debug(this.pattern, 'set', set); // Find the basename of the path by looking for the last non-empty segment\n\n    let filename;\n\n    for (let i = f.length - 1; i >= 0; i--) {\n      filename = f[i];\n      if (filename) break;\n    }\n\n    for (let i = 0; i < set.length; i++) {\n      const pattern = set[i];\n      let file = f;\n\n      if (options.matchBase && pattern.length === 1) {\n        file = [filename];\n      }\n\n      const hit = this.matchOne(file, pattern, partial);\n\n      if (hit) {\n        if (options.flipNegate) return true;\n        return !this.negate;\n      }\n    } // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n\n\n    if (options.flipNegate) return false;\n    return this.negate;\n  }\n\n  static defaults(def) {\n    return minimatch.defaults(def).Minimatch;\n  }\n\n}\n\nminimatch.Minimatch = Minimatch;","map":{"version":3,"names":["minimatch","module","exports","p","pattern","options","assertValidPattern","nocomment","charAt","Minimatch","match","path","require","sep","GLOBSTAR","Symbol","expand","plTypes","open","close","qmark","star","twoStarDot","twoStarNoDot","charSet","s","split","reduce","set","c","reSpecials","addPatternStartSet","slashSplit","filter","i","list","ext","a","b","t","Object","keys","forEach","k","defaults","def","length","orig","m","constructor","makeRe","braceExpand","nobrace","test","MAX_PATTERN_LENGTH","TypeError","SUBPARSE","mm","f","nonull","push","globUnescape","replace","regExpEscape","windowsPathsNoEscape","allowWindowsEscape","regexp","negate","comment","empty","partial","make","debug","parseNegate","globSet","args","console","error","globParts","map","si","parse","indexOf","nonegate","negateOffset","substr","matchOne","file","fi","pi","fl","pl","fr","pr","dot","swallowee","slice","hit","Error","isSub","noglobstar","re","hasMagic","nocase","escaping","patternListStack","negativeLists","stateChar","inClass","reClassStart","classStart","cs","sp","patternStart","clearStateChar","noext","type","start","reStart","pop","reEnd","substring","RegExp","er","tail","_","$1","$2","addPatternStart","n","nl","nlBefore","nlFirst","nlAfter","nlLast","openParensBefore","cleanAfter","dollar","flags","assign","_glob","_src","twoStar","join","ex","filename","matchBase","flipNegate"],"sources":["/Users/Ellie/Desktop/projects/book-search-engine/client/node_modules/apollo-language-server/node_modules/minimatch/minimatch.js"],"sourcesContent":["const minimatch = module.exports = (p, pattern, options = {}) => {\n  assertValidPattern(pattern)\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nmodule.exports = minimatch\n\nconst path = require('./lib/path.js')\nminimatch.sep = path.sep\n\nconst GLOBSTAR = Symbol('globstar **')\nminimatch.GLOBSTAR = GLOBSTAR\nconst expand = require('brace-expansion')\n\nconst plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// \"abc\" -> { a:true, b:true, c:true }\nconst charSet = s => s.split('').reduce((set, c) => {\n  set[c] = true\n  return set\n}, {})\n\n// characters that need to be escaped in RegExp.\nconst reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// characters that indicate we have to add the pattern start\nconst addPatternStartSet = charSet('[.(')\n\n// normalizes slashes.\nconst slashSplit = /\\/+/\n\nminimatch.filter = (pattern, options = {}) =>\n  (p, i, list) => minimatch(p, pattern, options)\n\nconst ext = (a, b = {}) => {\n  const t = {}\n  Object.keys(a).forEach(k => t[k] = a[k])\n  Object.keys(b).forEach(k => t[k] = b[k])\n  return t\n}\n\nminimatch.defaults = def => {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch\n  }\n\n  const orig = minimatch\n\n  const m = (p, pattern, options) => orig(p, pattern, ext(def, options))\n  m.Minimatch = class Minimatch extends orig.Minimatch {\n    constructor (pattern, options) {\n      super(pattern, ext(def, options))\n    }\n  }\n  m.Minimatch.defaults = options => orig.defaults(ext(def, options)).Minimatch\n  m.filter = (pattern, options) => orig.filter(pattern, ext(def, options))\n  m.defaults = options => orig.defaults(ext(def, options))\n  m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options))\n  m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options))\n  m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options))\n\n  return m\n}\n\n\n\n\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = (pattern, options) => braceExpand(pattern, options)\n\nconst braceExpand = (pattern, options = {}) => {\n  assertValidPattern(pattern)\n\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\nconst MAX_PATTERN_LENGTH = 1024 * 64\nconst assertValidPattern = pattern => {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern')\n  }\n\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long')\n  }\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nconst SUBPARSE = Symbol('subparse')\n\nminimatch.makeRe = (pattern, options) =>\n  new Minimatch(pattern, options || {}).makeRe()\n\nminimatch.match = (list, pattern, options = {}) => {\n  const mm = new Minimatch(pattern, options)\n  list = list.filter(f => mm.match(f))\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\n// replace stuff like \\* with *\nconst globUnescape = s => s.replace(/\\\\(.)/g, '$1')\nconst regExpEscape = s => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\nclass Minimatch {\n  constructor (pattern, options) {\n    assertValidPattern(pattern)\n\n    if (!options) options = {}\n\n    this.options = options\n    this.set = []\n    this.pattern = pattern\n    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape ||\n      options.allowWindowsEscape === false\n    if (this.windowsPathsNoEscape) {\n      this.pattern = this.pattern.replace(/\\\\/g, '/')\n    }\n    this.regexp = null\n    this.negate = false\n    this.comment = false\n    this.empty = false\n    this.partial = !!options.partial\n\n    // make the set of regexps etc.\n    this.make()\n  }\n\n  debug () {}\n\n  make () {\n    const pattern = this.pattern\n    const options = this.options\n\n    // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n      this.comment = true\n      return\n    }\n    if (!pattern) {\n      this.empty = true\n      return\n    }\n\n    // step 1: figure out negation, etc.\n    this.parseNegate()\n\n    // step 2: expand braces\n    let set = this.globSet = this.braceExpand()\n\n    if (options.debug) this.debug = (...args) => console.error(...args)\n\n    this.debug(this.pattern, set)\n\n    // step 3: now we have a set, so turn each one into a series of path-portion\n    // matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n    set = this.globParts = set.map(s => s.split(slashSplit))\n\n    this.debug(this.pattern, set)\n\n    // glob --> regexps\n    set = set.map((s, si, set) => s.map(this.parse, this))\n\n    this.debug(this.pattern, set)\n\n    // filter out everything that didn't compile properly.\n    set = set.filter(s => s.indexOf(false) === -1)\n\n    this.debug(this.pattern, set)\n\n    this.set = set\n  }\n\n  parseNegate () {\n    if (this.options.nonegate) return\n\n    const pattern = this.pattern\n    let negate = false\n    let negateOffset = 0\n\n    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n      negate = !negate\n      negateOffset++\n    }\n\n    if (negateOffset) this.pattern = pattern.substr(negateOffset)\n    this.negate = negate\n  }\n\n  // set partial to true to test if, for example,\n  // \"/a/b\" matches the start of \"/*/b/*/d\"\n  // Partial means, if you run out of file before you run\n  // out of pattern, then that's fine, as long as all\n  // the parts match.\n  matchOne (file, pattern, partial) {\n    var options = this.options\n\n    this.debug('matchOne',\n      { 'this': this, file: file, pattern: pattern })\n\n    this.debug('matchOne', file.length, pattern.length)\n\n    for (var fi = 0,\n        pi = 0,\n        fl = file.length,\n        pl = pattern.length\n        ; (fi < fl) && (pi < pl)\n        ; fi++, pi++) {\n      this.debug('matchOne loop')\n      var p = pattern[pi]\n      var f = file[fi]\n\n      this.debug(pattern, p, f)\n\n      // should be impossible.\n      // some invalid regexp stuff in the set.\n      /* istanbul ignore if */\n      if (p === false) return false\n\n      if (p === GLOBSTAR) {\n        this.debug('GLOBSTAR', [pattern, p, f])\n\n        // \"**\"\n        // a/**/b/**/c would match the following:\n        // a/b/x/y/z/c\n        // a/x/y/z/b/c\n        // a/b/x/b/x/c\n        // a/b/c\n        // To do this, take the rest of the pattern after\n        // the **, and see if it would match the file remainder.\n        // If so, return success.\n        // If not, the ** \"swallows\" a segment, and try again.\n        // This is recursively awful.\n        //\n        // a/**/b/**/c matching a/b/x/y/z/c\n        // - a matches a\n        // - doublestar\n        //   - matchOne(b/x/y/z/c, b/**/c)\n        //     - b matches b\n        //     - doublestar\n        //       - matchOne(x/y/z/c, c) -> no\n        //       - matchOne(y/z/c, c) -> no\n        //       - matchOne(z/c, c) -> no\n        //       - matchOne(c, c) yes, hit\n        var fr = fi\n        var pr = pi + 1\n        if (pr === pl) {\n          this.debug('** at the end')\n          // a ** at the end will just swallow the rest.\n          // We have found a match.\n          // however, it will not swallow /.x, unless\n          // options.dot is set.\n          // . and .. are *never* matched by **, for explosively\n          // exponential reasons.\n          for (; fi < fl; fi++) {\n            if (file[fi] === '.' || file[fi] === '..' ||\n              (!options.dot && file[fi].charAt(0) === '.')) return false\n          }\n          return true\n        }\n\n        // ok, let's see if we can swallow whatever we can.\n        while (fr < fl) {\n          var swallowee = file[fr]\n\n          this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n          // XXX remove this slice.  Just pass the start index.\n          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n            this.debug('globstar found match!', fr, fl, swallowee)\n            // found a match.\n            return true\n          } else {\n            // can't swallow \".\" or \"..\" ever.\n            // can only swallow \".foo\" when explicitly asked.\n            if (swallowee === '.' || swallowee === '..' ||\n              (!options.dot && swallowee.charAt(0) === '.')) {\n              this.debug('dot detected!', file, fr, pattern, pr)\n              break\n            }\n\n            // ** swallows a segment, and continue.\n            this.debug('globstar swallow a segment, and continue')\n            fr++\n          }\n        }\n\n        // no match was found.\n        // However, in partial mode, we can't say this is necessarily over.\n        // If there's more *pattern* left, then\n        /* istanbul ignore if */\n        if (partial) {\n          // ran out of file\n          this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n          if (fr === fl) return true\n        }\n        return false\n      }\n\n      // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n      var hit\n      if (typeof p === 'string') {\n        hit = f === p\n        this.debug('string match', p, f, hit)\n      } else {\n        hit = f.match(p)\n        this.debug('pattern match', p, f, hit)\n      }\n\n      if (!hit) return false\n    }\n\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial\n    } else /* istanbul ignore else */ if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      return (fi === fl - 1) && (file[fi] === '')\n    }\n\n    // should be unreachable.\n    /* istanbul ignore next */\n    throw new Error('wtf?')\n  }\n\n  braceExpand () {\n    return braceExpand(this.pattern, this.options)\n  }\n\n  parse (pattern, isSub) {\n    assertValidPattern(pattern)\n\n    const options = this.options\n\n    // shortcuts\n    if (pattern === '**') {\n      if (!options.noglobstar)\n        return GLOBSTAR\n      else\n        pattern = '*'\n    }\n    if (pattern === '') return ''\n\n    let re = ''\n    let hasMagic = !!options.nocase\n    let escaping = false\n    // ? => one single character\n    const patternListStack = []\n    const negativeLists = []\n    let stateChar\n    let inClass = false\n    let reClassStart = -1\n    let classStart = -1\n    let cs\n    let pl\n    let sp\n    // . and .. never match anything that doesn't start with .,\n    // even when options.dot is set.\n    const patternStart = pattern.charAt(0) === '.' ? '' // anything\n    // not (start or / followed by . or .. followed by / or end)\n    : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n    : '(?!\\\\.)'\n\n    const clearStateChar = () => {\n      if (stateChar) {\n        // we had some state-tracking character\n        // that wasn't consumed by this pass.\n        switch (stateChar) {\n          case '*':\n            re += star\n            hasMagic = true\n          break\n          case '?':\n            re += qmark\n            hasMagic = true\n          break\n          default:\n            re += '\\\\' + stateChar\n          break\n        }\n        this.debug('clearStateChar %j %j', stateChar, re)\n        stateChar = false\n      }\n    }\n\n    for (let i = 0, c; (i < pattern.length) && (c = pattern.charAt(i)); i++) {\n      this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n      // skip over any that are escaped.\n      if (escaping) {\n        /* istanbul ignore next - completely not allowed, even escaped. */\n        if (c === '/') {\n          return false\n        }\n\n        if (reSpecials[c]) {\n          re += '\\\\'\n        }\n        re += c\n        escaping = false\n        continue\n      }\n\n      switch (c) {\n        /* istanbul ignore next */\n        case '/': {\n          // Should already be path-split by now.\n          return false\n        }\n\n        case '\\\\':\n          clearStateChar()\n          escaping = true\n        continue\n\n        // the various stateChar values\n        // for the \"extglob\" stuff.\n        case '?':\n        case '*':\n        case '+':\n        case '@':\n        case '!':\n          this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n          // all of those are literals inside a class, except that\n          // the glob [!a] means [^a] in regexp\n          if (inClass) {\n            this.debug('  in class')\n            if (c === '!' && i === classStart + 1) c = '^'\n            re += c\n            continue\n          }\n\n          // if we already have a stateChar, then it means\n          // that there was something like ** or +? in there.\n          // Handle the stateChar, then proceed with this one.\n          this.debug('call clearStateChar %j', stateChar)\n          clearStateChar()\n          stateChar = c\n          // if extglob is disabled, then +(asdf|foo) isn't a thing.\n          // just clear the statechar *now*, rather than even diving into\n          // the patternList stuff.\n          if (options.noext) clearStateChar()\n        continue\n\n        case '(':\n          if (inClass) {\n            re += '('\n            continue\n          }\n\n          if (!stateChar) {\n            re += '\\\\('\n            continue\n          }\n\n          patternListStack.push({\n            type: stateChar,\n            start: i - 1,\n            reStart: re.length,\n            open: plTypes[stateChar].open,\n            close: plTypes[stateChar].close\n          })\n          // negation is (?:(?!js)[^/]*)\n          re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n          this.debug('plType %j %j', stateChar, re)\n          stateChar = false\n        continue\n\n        case ')':\n          if (inClass || !patternListStack.length) {\n            re += '\\\\)'\n            continue\n          }\n\n          clearStateChar()\n          hasMagic = true\n          pl = patternListStack.pop()\n          // negation is (?:(?!js)[^/]*)\n          // The others are (?:<pattern>)<type>\n          re += pl.close\n          if (pl.type === '!') {\n            negativeLists.push(pl)\n          }\n          pl.reEnd = re.length\n        continue\n\n        case '|':\n          if (inClass || !patternListStack.length) {\n            re += '\\\\|'\n            continue\n          }\n\n          clearStateChar()\n          re += '|'\n        continue\n\n        // these are mostly the same in regexp and glob\n        case '[':\n          // swallow any state-tracking char before the [\n          clearStateChar()\n\n          if (inClass) {\n            re += '\\\\' + c\n            continue\n          }\n\n          inClass = true\n          classStart = i\n          reClassStart = re.length\n          re += c\n        continue\n\n        case ']':\n          //  a right bracket shall lose its special\n          //  meaning and represent itself in\n          //  a bracket expression if it occurs\n          //  first in the list.  -- POSIX.2 2.8.3.2\n          if (i === classStart + 1 || !inClass) {\n            re += '\\\\' + c\n            continue\n          }\n\n          // handle the case where we left a class open.\n          // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          cs = pattern.substring(classStart + 1, i)\n          try {\n            RegExp('[' + cs + ']')\n          } catch (er) {\n            // not a valid class!\n            sp = this.parse(cs, SUBPARSE)\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n            hasMagic = hasMagic || sp[1]\n            inClass = false\n            continue\n          }\n\n          // finish up the class.\n          hasMagic = true\n          inClass = false\n          re += c\n        continue\n\n        default:\n          // swallow any state char that wasn't consumed\n          clearStateChar()\n\n          if (reSpecials[c] && !(c === '^' && inClass)) {\n            re += '\\\\'\n          }\n\n          re += c\n          break\n\n      } // switch\n    } // for\n\n    // handle the case where we left a class open.\n    // \"[abc\" is valid, equivalent to \"\\[abc\"\n    if (inClass) {\n      // split where the last [ was, and escape it\n      // this is a huge pita.  We now have to re-walk\n      // the contents of the would-be class to re-translate\n      // any characters that were passed through as-is\n      cs = pattern.substr(classStart + 1)\n      sp = this.parse(cs, SUBPARSE)\n      re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n      hasMagic = hasMagic || sp[1]\n    }\n\n    // handle the case where we had a +( thing at the *end*\n    // of the pattern.\n    // each pattern list stack adds 3 chars, and we need to go through\n    // and escape any | chars that were passed through as-is for the regexp.\n    // Go through and escape them, taking care not to double-escape any\n    // | chars that were already escaped.\n    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n      let tail\n      tail = re.slice(pl.reStart + pl.open.length)\n      this.debug('setting tail', re, pl)\n      // maybe some even number of \\, then maybe 1 \\, followed by a |\n      tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, (_, $1, $2) => {\n        /* istanbul ignore else - should already be done */\n        if (!$2) {\n          // the | isn't already escaped, so escape it.\n          $2 = '\\\\'\n        }\n\n        // need to escape all those slashes *again*, without escaping the\n        // one that we need for escaping the | character.  As it works out,\n        // escaping an even number of slashes can be done by simply repeating\n        // it exactly after itself.  That's why this trick works.\n        //\n        // I am sorry that you have to see this.\n        return $1 + $1 + $2 + '|'\n      })\n\n      this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n      const t = pl.type === '*' ? star\n        : pl.type === '?' ? qmark\n        : '\\\\' + pl.type\n\n      hasMagic = true\n      re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n    }\n\n    // handle trailing things that only matter at the very end.\n    clearStateChar()\n    if (escaping) {\n      // trailing \\\\\n      re += '\\\\\\\\'\n    }\n\n    // only need to apply the nodot start if the re starts with\n    // something that could conceivably capture a dot\n    const addPatternStart = addPatternStartSet[re.charAt(0)]\n\n    // Hack to work around lack of negative lookbehind in JS\n    // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n    // like 'a.xyz.yz' doesn't match.  So, the first negative\n    // lookahead, has to look ALL the way ahead, to the end of\n    // the pattern.\n    for (let n = negativeLists.length - 1; n > -1; n--) {\n      const nl = negativeLists[n]\n\n      const nlBefore = re.slice(0, nl.reStart)\n      const nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n      let nlAfter = re.slice(nl.reEnd)\n      const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter\n\n      // Handle nested stuff like *(*.js|!(*.json)), where open parens\n      // mean that we should *not* include the ) in the bit that is considered\n      // \"after\" the negated section.\n      const openParensBefore = nlBefore.split('(').length - 1\n      let cleanAfter = nlAfter\n      for (let i = 0; i < openParensBefore; i++) {\n        cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n      }\n      nlAfter = cleanAfter\n\n      const dollar = nlAfter === '' && isSub !== SUBPARSE ? '$' : ''\n      re = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    }\n\n    // if the re is not \"\" at this point, then we need to make sure\n    // it doesn't match against an empty path part.\n    // Otherwise a/* will match a/, which it should not.\n    if (re !== '' && hasMagic) {\n      re = '(?=.)' + re\n    }\n\n    if (addPatternStart) {\n      re = patternStart + re\n    }\n\n    // parsing just a piece of a larger pattern.\n    if (isSub === SUBPARSE) {\n      return [re, hasMagic]\n    }\n\n    // skip the regexp for non-magical patterns\n    // unescape anything in it, though, so that it'll be\n    // an exact match against a file etc.\n    if (!hasMagic) {\n      return globUnescape(pattern)\n    }\n\n    const flags = options.nocase ? 'i' : ''\n    try {\n      return Object.assign(new RegExp('^' + re + '$', flags), {\n        _glob: pattern,\n        _src: re,\n      })\n    } catch (er) /* istanbul ignore next - should be impossible */ {\n      // If it was an invalid regular expression, then it can't match\n      // anything.  This trick looks for a character after the end of\n      // the string, which is of course impossible, except in multi-line\n      // mode, but it's not a /m regex.\n      return new RegExp('$.')\n    }\n  }\n\n  makeRe () {\n    if (this.regexp || this.regexp === false) return this.regexp\n\n    // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n    const set = this.set\n\n    if (!set.length) {\n      this.regexp = false\n      return this.regexp\n    }\n    const options = this.options\n\n    const twoStar = options.noglobstar ? star\n      : options.dot ? twoStarDot\n      : twoStarNoDot\n    const flags = options.nocase ? 'i' : ''\n\n    // coalesce globstars and regexpify non-globstar patterns\n    // if it's the only item, then we just do one twoStar\n    // if it's the first, and there are more, prepend (\\/|twoStar\\/)? to next\n    // if it's the last, append (\\/twoStar|) to previous\n    // if it's in the middle, append (\\/|\\/twoStar\\/) to previous\n    // then filter out GLOBSTAR symbols\n    let re = set.map(pattern => {\n      pattern = pattern.map(p =>\n        typeof p === 'string' ? regExpEscape(p)\n        : p === GLOBSTAR ? GLOBSTAR\n        : p._src\n      ).reduce((set, p) => {\n        if (!(set[set.length - 1] === GLOBSTAR && p === GLOBSTAR)) {\n          set.push(p)\n        }\n        return set\n      }, [])\n      pattern.forEach((p, i) => {\n        if (p !== GLOBSTAR || pattern[i-1] === GLOBSTAR) {\n          return\n        }\n        if (i === 0) {\n          if (pattern.length > 1) {\n            pattern[i+1] = '(?:\\\\\\/|' + twoStar + '\\\\\\/)?' + pattern[i+1]\n          } else {\n            pattern[i] = twoStar\n          }\n        } else if (i === pattern.length - 1) {\n          pattern[i-1] += '(?:\\\\\\/|' + twoStar + ')?'\n        } else {\n          pattern[i-1] += '(?:\\\\\\/|\\\\\\/' + twoStar + '\\\\\\/)' + pattern[i+1]\n          pattern[i+1] = GLOBSTAR\n        }\n      })\n      return pattern.filter(p => p !== GLOBSTAR).join('/')\n    }).join('|')\n\n    // must match entire pattern\n    // ending in a * or ** will make it less strict.\n    re = '^(?:' + re + ')$'\n\n    // can match anything, as long as it's not this.\n    if (this.negate) re = '^(?!' + re + ').*$'\n\n    try {\n      this.regexp = new RegExp(re, flags)\n    } catch (ex) /* istanbul ignore next - should be impossible */ {\n      this.regexp = false\n    }\n    return this.regexp\n  }\n\n  match (f, partial = this.partial) {\n    this.debug('match', f, this.pattern)\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) return false\n    if (this.empty) return f === ''\n\n    if (f === '/' && partial) return true\n\n    const options = this.options\n\n    // windows: need to use /, not \\\n    if (path.sep !== '/') {\n      f = f.split(path.sep).join('/')\n    }\n\n    // treat the test path as a set of pathparts.\n    f = f.split(slashSplit)\n    this.debug(this.pattern, 'split', f)\n\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n\n    const set = this.set\n    this.debug(this.pattern, 'set', set)\n\n    // Find the basename of the path by looking for the last non-empty segment\n    let filename\n    for (let i = f.length - 1; i >= 0; i--) {\n      filename = f[i]\n      if (filename) break\n    }\n\n    for (let i = 0; i < set.length; i++) {\n      const pattern = set[i]\n      let file = f\n      if (options.matchBase && pattern.length === 1) {\n        file = [filename]\n      }\n      const hit = this.matchOne(file, pattern, partial)\n      if (hit) {\n        if (options.flipNegate) return true\n        return !this.negate\n      }\n    }\n\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) return false\n    return this.negate\n  }\n\n  static defaults (def) {\n    return minimatch.defaults(def).Minimatch\n  }\n}\n\nminimatch.Minimatch = Minimatch\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}