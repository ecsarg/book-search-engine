{"ast":null,"code":"\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LRUCache = exports.LinkedMap = exports.Touch = void 0;\nvar Touch;\n\n(function (Touch) {\n  Touch.None = 0;\n  Touch.First = 1;\n  Touch.AsOld = Touch.First;\n  Touch.Last = 2;\n  Touch.AsNew = Touch.Last;\n})(Touch = exports.Touch || (exports.Touch = {}));\n\nclass LinkedMap {\n  constructor() {\n    this[Symbol.toStringTag] = 'LinkedMap';\n    this._map = new Map();\n    this._head = undefined;\n    this._tail = undefined;\n    this._size = 0;\n    this._state = 0;\n  }\n\n  clear() {\n    this._map.clear();\n\n    this._head = undefined;\n    this._tail = undefined;\n    this._size = 0;\n    this._state++;\n  }\n\n  isEmpty() {\n    return !this._head && !this._tail;\n  }\n\n  get size() {\n    return this._size;\n  }\n\n  get first() {\n    var _a;\n\n    return (_a = this._head) === null || _a === void 0 ? void 0 : _a.value;\n  }\n\n  get last() {\n    var _a;\n\n    return (_a = this._tail) === null || _a === void 0 ? void 0 : _a.value;\n  }\n\n  has(key) {\n    return this._map.has(key);\n  }\n\n  get(key, touch = Touch.None) {\n    const item = this._map.get(key);\n\n    if (!item) {\n      return undefined;\n    }\n\n    if (touch !== Touch.None) {\n      this.touch(item, touch);\n    }\n\n    return item.value;\n  }\n\n  set(key, value, touch = Touch.None) {\n    let item = this._map.get(key);\n\n    if (item) {\n      item.value = value;\n\n      if (touch !== Touch.None) {\n        this.touch(item, touch);\n      }\n    } else {\n      item = {\n        key,\n        value,\n        next: undefined,\n        previous: undefined\n      };\n\n      switch (touch) {\n        case Touch.None:\n          this.addItemLast(item);\n          break;\n\n        case Touch.First:\n          this.addItemFirst(item);\n          break;\n\n        case Touch.Last:\n          this.addItemLast(item);\n          break;\n\n        default:\n          this.addItemLast(item);\n          break;\n      }\n\n      this._map.set(key, item);\n\n      this._size++;\n    }\n\n    return this;\n  }\n\n  delete(key) {\n    return !!this.remove(key);\n  }\n\n  remove(key) {\n    const item = this._map.get(key);\n\n    if (!item) {\n      return undefined;\n    }\n\n    this._map.delete(key);\n\n    this.removeItem(item);\n    this._size--;\n    return item.value;\n  }\n\n  shift() {\n    if (!this._head && !this._tail) {\n      return undefined;\n    }\n\n    if (!this._head || !this._tail) {\n      throw new Error('Invalid list');\n    }\n\n    const item = this._head;\n\n    this._map.delete(item.key);\n\n    this.removeItem(item);\n    this._size--;\n    return item.value;\n  }\n\n  forEach(callbackfn, thisArg) {\n    const state = this._state;\n    let current = this._head;\n\n    while (current) {\n      if (thisArg) {\n        callbackfn.bind(thisArg)(current.value, current.key, this);\n      } else {\n        callbackfn(current.value, current.key, this);\n      }\n\n      if (this._state !== state) {\n        throw new Error(`LinkedMap got modified during iteration.`);\n      }\n\n      current = current.next;\n    }\n  }\n\n  keys() {\n    const map = this;\n    const state = this._state;\n    let current = this._head;\n    const iterator = {\n      [Symbol.iterator]() {\n        return iterator;\n      },\n\n      next() {\n        if (map._state !== state) {\n          throw new Error(`LinkedMap got modified during iteration.`);\n        }\n\n        if (current) {\n          const result = {\n            value: current.key,\n            done: false\n          };\n          current = current.next;\n          return result;\n        } else {\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n      }\n\n    };\n    return iterator;\n  }\n\n  values() {\n    const map = this;\n    const state = this._state;\n    let current = this._head;\n    const iterator = {\n      [Symbol.iterator]() {\n        return iterator;\n      },\n\n      next() {\n        if (map._state !== state) {\n          throw new Error(`LinkedMap got modified during iteration.`);\n        }\n\n        if (current) {\n          const result = {\n            value: current.value,\n            done: false\n          };\n          current = current.next;\n          return result;\n        } else {\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n      }\n\n    };\n    return iterator;\n  }\n\n  entries() {\n    const map = this;\n    const state = this._state;\n    let current = this._head;\n    const iterator = {\n      [Symbol.iterator]() {\n        return iterator;\n      },\n\n      next() {\n        if (map._state !== state) {\n          throw new Error(`LinkedMap got modified during iteration.`);\n        }\n\n        if (current) {\n          const result = {\n            value: [current.key, current.value],\n            done: false\n          };\n          current = current.next;\n          return result;\n        } else {\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n      }\n\n    };\n    return iterator;\n  }\n\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n\n  trimOld(newSize) {\n    if (newSize >= this.size) {\n      return;\n    }\n\n    if (newSize === 0) {\n      this.clear();\n      return;\n    }\n\n    let current = this._head;\n    let currentSize = this.size;\n\n    while (current && currentSize > newSize) {\n      this._map.delete(current.key);\n\n      current = current.next;\n      currentSize--;\n    }\n\n    this._head = current;\n    this._size = currentSize;\n\n    if (current) {\n      current.previous = undefined;\n    }\n\n    this._state++;\n  }\n\n  addItemFirst(item) {\n    // First time Insert\n    if (!this._head && !this._tail) {\n      this._tail = item;\n    } else if (!this._head) {\n      throw new Error('Invalid list');\n    } else {\n      item.next = this._head;\n      this._head.previous = item;\n    }\n\n    this._head = item;\n    this._state++;\n  }\n\n  addItemLast(item) {\n    // First time Insert\n    if (!this._head && !this._tail) {\n      this._head = item;\n    } else if (!this._tail) {\n      throw new Error('Invalid list');\n    } else {\n      item.previous = this._tail;\n      this._tail.next = item;\n    }\n\n    this._tail = item;\n    this._state++;\n  }\n\n  removeItem(item) {\n    if (item === this._head && item === this._tail) {\n      this._head = undefined;\n      this._tail = undefined;\n    } else if (item === this._head) {\n      // This can only happend if size === 1 which is handle\n      // by the case above.\n      if (!item.next) {\n        throw new Error('Invalid list');\n      }\n\n      item.next.previous = undefined;\n      this._head = item.next;\n    } else if (item === this._tail) {\n      // This can only happend if size === 1 which is handle\n      // by the case above.\n      if (!item.previous) {\n        throw new Error('Invalid list');\n      }\n\n      item.previous.next = undefined;\n      this._tail = item.previous;\n    } else {\n      const next = item.next;\n      const previous = item.previous;\n\n      if (!next || !previous) {\n        throw new Error('Invalid list');\n      }\n\n      next.previous = previous;\n      previous.next = next;\n    }\n\n    item.next = undefined;\n    item.previous = undefined;\n    this._state++;\n  }\n\n  touch(item, touch) {\n    if (!this._head || !this._tail) {\n      throw new Error('Invalid list');\n    }\n\n    if (touch !== Touch.First && touch !== Touch.Last) {\n      return;\n    }\n\n    if (touch === Touch.First) {\n      if (item === this._head) {\n        return;\n      }\n\n      const next = item.next;\n      const previous = item.previous; // Unlink the item\n\n      if (item === this._tail) {\n        // previous must be defined since item was not head but is tail\n        // So there are more than on item in the map\n        previous.next = undefined;\n        this._tail = previous;\n      } else {\n        // Both next and previous are not undefined since item was neither head nor tail.\n        next.previous = previous;\n        previous.next = next;\n      } // Insert the node at head\n\n\n      item.previous = undefined;\n      item.next = this._head;\n      this._head.previous = item;\n      this._head = item;\n      this._state++;\n    } else if (touch === Touch.Last) {\n      if (item === this._tail) {\n        return;\n      }\n\n      const next = item.next;\n      const previous = item.previous; // Unlink the item.\n\n      if (item === this._head) {\n        // next must be defined since item was not tail but is head\n        // So there are more than on item in the map\n        next.previous = undefined;\n        this._head = next;\n      } else {\n        // Both next and previous are not undefined since item was neither head nor tail.\n        next.previous = previous;\n        previous.next = next;\n      }\n\n      item.next = undefined;\n      item.previous = this._tail;\n      this._tail.next = item;\n      this._tail = item;\n      this._state++;\n    }\n  }\n\n  toJSON() {\n    const data = [];\n    this.forEach((value, key) => {\n      data.push([key, value]);\n    });\n    return data;\n  }\n\n  fromJSON(data) {\n    this.clear();\n\n    for (const [key, value] of data) {\n      this.set(key, value);\n    }\n  }\n\n}\n\nexports.LinkedMap = LinkedMap;\n\nclass LRUCache extends LinkedMap {\n  constructor(limit, ratio = 1) {\n    super();\n    this._limit = limit;\n    this._ratio = Math.min(Math.max(0, ratio), 1);\n  }\n\n  get limit() {\n    return this._limit;\n  }\n\n  set limit(limit) {\n    this._limit = limit;\n    this.checkTrim();\n  }\n\n  get ratio() {\n    return this._ratio;\n  }\n\n  set ratio(ratio) {\n    this._ratio = Math.min(Math.max(0, ratio), 1);\n    this.checkTrim();\n  }\n\n  get(key, touch = Touch.AsNew) {\n    return super.get(key, touch);\n  }\n\n  peek(key) {\n    return super.get(key, Touch.None);\n  }\n\n  set(key, value) {\n    super.set(key, value, Touch.Last);\n    this.checkTrim();\n    return this;\n  }\n\n  checkTrim() {\n    if (this.size > this._limit) {\n      this.trimOld(Math.round(this._limit * this._ratio));\n    }\n  }\n\n}\n\nexports.LRUCache = LRUCache;","map":{"version":3,"names":["Object","defineProperty","exports","value","LRUCache","LinkedMap","Touch","None","First","AsOld","Last","AsNew","constructor","Symbol","toStringTag","_map","Map","_head","undefined","_tail","_size","_state","clear","isEmpty","size","first","_a","last","has","key","get","touch","item","set","next","previous","addItemLast","addItemFirst","delete","remove","removeItem","shift","Error","forEach","callbackfn","thisArg","state","current","bind","keys","map","iterator","result","done","values","entries","trimOld","newSize","currentSize","toJSON","data","push","fromJSON","limit","ratio","_limit","_ratio","Math","min","max","checkTrim","peek","round"],"sources":["/Users/Ellie/Desktop/projects/book-search-engine/client/node_modules/vscode-jsonrpc/lib/common/linkedMap.js"],"sourcesContent":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LRUCache = exports.LinkedMap = exports.Touch = void 0;\nvar Touch;\n(function (Touch) {\n    Touch.None = 0;\n    Touch.First = 1;\n    Touch.AsOld = Touch.First;\n    Touch.Last = 2;\n    Touch.AsNew = Touch.Last;\n})(Touch = exports.Touch || (exports.Touch = {}));\nclass LinkedMap {\n    constructor() {\n        this[Symbol.toStringTag] = 'LinkedMap';\n        this._map = new Map();\n        this._head = undefined;\n        this._tail = undefined;\n        this._size = 0;\n        this._state = 0;\n    }\n    clear() {\n        this._map.clear();\n        this._head = undefined;\n        this._tail = undefined;\n        this._size = 0;\n        this._state++;\n    }\n    isEmpty() {\n        return !this._head && !this._tail;\n    }\n    get size() {\n        return this._size;\n    }\n    get first() {\n        var _a;\n        return (_a = this._head) === null || _a === void 0 ? void 0 : _a.value;\n    }\n    get last() {\n        var _a;\n        return (_a = this._tail) === null || _a === void 0 ? void 0 : _a.value;\n    }\n    has(key) {\n        return this._map.has(key);\n    }\n    get(key, touch = Touch.None) {\n        const item = this._map.get(key);\n        if (!item) {\n            return undefined;\n        }\n        if (touch !== Touch.None) {\n            this.touch(item, touch);\n        }\n        return item.value;\n    }\n    set(key, value, touch = Touch.None) {\n        let item = this._map.get(key);\n        if (item) {\n            item.value = value;\n            if (touch !== Touch.None) {\n                this.touch(item, touch);\n            }\n        }\n        else {\n            item = { key, value, next: undefined, previous: undefined };\n            switch (touch) {\n                case Touch.None:\n                    this.addItemLast(item);\n                    break;\n                case Touch.First:\n                    this.addItemFirst(item);\n                    break;\n                case Touch.Last:\n                    this.addItemLast(item);\n                    break;\n                default:\n                    this.addItemLast(item);\n                    break;\n            }\n            this._map.set(key, item);\n            this._size++;\n        }\n        return this;\n    }\n    delete(key) {\n        return !!this.remove(key);\n    }\n    remove(key) {\n        const item = this._map.get(key);\n        if (!item) {\n            return undefined;\n        }\n        this._map.delete(key);\n        this.removeItem(item);\n        this._size--;\n        return item.value;\n    }\n    shift() {\n        if (!this._head && !this._tail) {\n            return undefined;\n        }\n        if (!this._head || !this._tail) {\n            throw new Error('Invalid list');\n        }\n        const item = this._head;\n        this._map.delete(item.key);\n        this.removeItem(item);\n        this._size--;\n        return item.value;\n    }\n    forEach(callbackfn, thisArg) {\n        const state = this._state;\n        let current = this._head;\n        while (current) {\n            if (thisArg) {\n                callbackfn.bind(thisArg)(current.value, current.key, this);\n            }\n            else {\n                callbackfn(current.value, current.key, this);\n            }\n            if (this._state !== state) {\n                throw new Error(`LinkedMap got modified during iteration.`);\n            }\n            current = current.next;\n        }\n    }\n    keys() {\n        const map = this;\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]() {\n                return iterator;\n            },\n            next() {\n                if (map._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: current.key, done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    values() {\n        const map = this;\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]() {\n                return iterator;\n            },\n            next() {\n                if (map._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: current.value, done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    entries() {\n        const map = this;\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]() {\n                return iterator;\n            },\n            next() {\n                if (map._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: [current.key, current.value], done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    trimOld(newSize) {\n        if (newSize >= this.size) {\n            return;\n        }\n        if (newSize === 0) {\n            this.clear();\n            return;\n        }\n        let current = this._head;\n        let currentSize = this.size;\n        while (current && currentSize > newSize) {\n            this._map.delete(current.key);\n            current = current.next;\n            currentSize--;\n        }\n        this._head = current;\n        this._size = currentSize;\n        if (current) {\n            current.previous = undefined;\n        }\n        this._state++;\n    }\n    addItemFirst(item) {\n        // First time Insert\n        if (!this._head && !this._tail) {\n            this._tail = item;\n        }\n        else if (!this._head) {\n            throw new Error('Invalid list');\n        }\n        else {\n            item.next = this._head;\n            this._head.previous = item;\n        }\n        this._head = item;\n        this._state++;\n    }\n    addItemLast(item) {\n        // First time Insert\n        if (!this._head && !this._tail) {\n            this._head = item;\n        }\n        else if (!this._tail) {\n            throw new Error('Invalid list');\n        }\n        else {\n            item.previous = this._tail;\n            this._tail.next = item;\n        }\n        this._tail = item;\n        this._state++;\n    }\n    removeItem(item) {\n        if (item === this._head && item === this._tail) {\n            this._head = undefined;\n            this._tail = undefined;\n        }\n        else if (item === this._head) {\n            // This can only happend if size === 1 which is handle\n            // by the case above.\n            if (!item.next) {\n                throw new Error('Invalid list');\n            }\n            item.next.previous = undefined;\n            this._head = item.next;\n        }\n        else if (item === this._tail) {\n            // This can only happend if size === 1 which is handle\n            // by the case above.\n            if (!item.previous) {\n                throw new Error('Invalid list');\n            }\n            item.previous.next = undefined;\n            this._tail = item.previous;\n        }\n        else {\n            const next = item.next;\n            const previous = item.previous;\n            if (!next || !previous) {\n                throw new Error('Invalid list');\n            }\n            next.previous = previous;\n            previous.next = next;\n        }\n        item.next = undefined;\n        item.previous = undefined;\n        this._state++;\n    }\n    touch(item, touch) {\n        if (!this._head || !this._tail) {\n            throw new Error('Invalid list');\n        }\n        if ((touch !== Touch.First && touch !== Touch.Last)) {\n            return;\n        }\n        if (touch === Touch.First) {\n            if (item === this._head) {\n                return;\n            }\n            const next = item.next;\n            const previous = item.previous;\n            // Unlink the item\n            if (item === this._tail) {\n                // previous must be defined since item was not head but is tail\n                // So there are more than on item in the map\n                previous.next = undefined;\n                this._tail = previous;\n            }\n            else {\n                // Both next and previous are not undefined since item was neither head nor tail.\n                next.previous = previous;\n                previous.next = next;\n            }\n            // Insert the node at head\n            item.previous = undefined;\n            item.next = this._head;\n            this._head.previous = item;\n            this._head = item;\n            this._state++;\n        }\n        else if (touch === Touch.Last) {\n            if (item === this._tail) {\n                return;\n            }\n            const next = item.next;\n            const previous = item.previous;\n            // Unlink the item.\n            if (item === this._head) {\n                // next must be defined since item was not tail but is head\n                // So there are more than on item in the map\n                next.previous = undefined;\n                this._head = next;\n            }\n            else {\n                // Both next and previous are not undefined since item was neither head nor tail.\n                next.previous = previous;\n                previous.next = next;\n            }\n            item.next = undefined;\n            item.previous = this._tail;\n            this._tail.next = item;\n            this._tail = item;\n            this._state++;\n        }\n    }\n    toJSON() {\n        const data = [];\n        this.forEach((value, key) => {\n            data.push([key, value]);\n        });\n        return data;\n    }\n    fromJSON(data) {\n        this.clear();\n        for (const [key, value] of data) {\n            this.set(key, value);\n        }\n    }\n}\nexports.LinkedMap = LinkedMap;\nclass LRUCache extends LinkedMap {\n    constructor(limit, ratio = 1) {\n        super();\n        this._limit = limit;\n        this._ratio = Math.min(Math.max(0, ratio), 1);\n    }\n    get limit() {\n        return this._limit;\n    }\n    set limit(limit) {\n        this._limit = limit;\n        this.checkTrim();\n    }\n    get ratio() {\n        return this._ratio;\n    }\n    set ratio(ratio) {\n        this._ratio = Math.min(Math.max(0, ratio), 1);\n        this.checkTrim();\n    }\n    get(key, touch = Touch.AsNew) {\n        return super.get(key, touch);\n    }\n    peek(key) {\n        return super.get(key, Touch.None);\n    }\n    set(key, value) {\n        super.set(key, value, Touch.Last);\n        this.checkTrim();\n        return this;\n    }\n    checkTrim() {\n        if (this.size > this._limit) {\n            this.trimOld(Math.round(this._limit * this._ratio));\n        }\n    }\n}\nexports.LRUCache = LRUCache;\n//# sourceMappingURL=linkedMap.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script"}