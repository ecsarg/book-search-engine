{"ast":null,"code":";\n\n(function () {\n  'use strict';\n  /* global define */\n\n  var esprima;\n  var exportFn;\n  var toString = Object.prototype.toString;\n\n  if (typeof module === 'object' && typeof module.exports === 'object' && typeof require === 'function') {\n    // server side\n    esprima = require('esprima');\n\n    exportFn = function (redeyed) {\n      module.exports = redeyed;\n    };\n\n    bootstrap(esprima, exportFn);\n  } else if (typeof define === 'function' && define.amd) {\n    // client side\n    // amd\n    define(['esprima'], function (esprima) {\n      return bootstrap(esprima);\n    });\n  } else if (typeof window === 'object') {\n    // no amd -> attach to window if it exists\n    // Note that this requires 'esprima' to be defined on the window, so that script has to be loaded first\n    window.redeyed = bootstrap(window.esprima);\n  }\n\n  function bootstrap(esprima, exportFn) {\n    function isFunction(obj) {\n      return toString.call(obj) === '[object Function]';\n    }\n\n    function isString(obj) {\n      return toString.call(obj) === '[object String]';\n    }\n\n    function isObject(obj) {\n      return toString.call(obj) === '[object Object]';\n    }\n\n    function surroundWith(before, after) {\n      return function (s) {\n        return before + s + after;\n      };\n    }\n\n    function isNonCircular(key) {\n      return key !== '_parent';\n    }\n\n    function objectizeString(value) {\n      var vals = value.split(':');\n\n      if (vals.length === 0 || vals.length > 2) {\n        throw new Error('illegal string config: ' + value + '\\nShould be of format \"before:after\"');\n      }\n\n      if (vals.length === 1 || vals[1].length === 0) {\n        return vals.indexOf(':') < 0 ? {\n          _before: vals[0]\n        } : {\n          _after: vals[0]\n        };\n      } else {\n        return {\n          _before: vals[0],\n          _after: vals[1]\n        };\n      }\n    }\n\n    function objectize(node) {\n      // Converts 'bef:aft' to { _before: bef, _after: aft }\n      // and resolves undefined before/after from parent or root\n      function resolve(value, key) {\n        // resolve before/after from root or parent if it isn't present on the current node\n        if (!value._parent) return undefined; // Immediate parent\n\n        if (value._parent._default && value._parent._default[key]) return value._parent._default[key]; // Root\n\n        var root = value._parent._parent;\n        if (!root) return undefined;\n        return root._default ? root._default[key] : undefined;\n      }\n\n      function process(key) {\n        var value = node[key];\n        if (!value) return;\n        if (isFunction(value)) return; // normalize all strings to objects\n\n        if (isString(value)) {\n          node[key] = value = objectizeString(value);\n        }\n\n        value._parent = node;\n\n        if (isObject(value)) {\n          if (!value._before && !value._after) return objectize(value); // resolve missing _before or _after from parent(s)\n          // in case we only have either one on this node\n\n          value._before = value._before || resolve(value, '_before');\n          value._after = value._after || resolve(value, '_after');\n          return;\n        }\n\n        throw new Error('nodes need to be either {String}, {Object} or {Function}.' + value + ' is neither.');\n      } // Process _default ones first so children can resolve missing before/after from them\n\n\n      if (node._default) process('_default');\n      Object.keys(node).filter(function (key) {\n        return isNonCircular(key) && node.hasOwnProperty(key) && key !== '_before' && key !== '_after' && key !== '_default';\n      }).forEach(process);\n    }\n\n    function functionize(node) {\n      Object.keys(node).filter(function (key) {\n        return isNonCircular(key) && node.hasOwnProperty(key);\n      }).forEach(function (key) {\n        var value = node[key];\n        if (isFunction(value)) return;\n\n        if (isObject(value)) {\n          if (!value._before && !value._after) return functionize(value); // at this point before/after were \"inherited\" from the parent or root\n          // (see objectize)\n\n          var before = value._before || '';\n          var after = value._after || '';\n          node[key] = surroundWith(before, after);\n          return node[key];\n        }\n      });\n    }\n\n    function normalize(root) {\n      objectize(root);\n      functionize(root);\n    }\n\n    function mergeTokensAndComments(tokens, comments) {\n      var all = {};\n\n      function addToAllByRangeStart(t) {\n        all[t.range[0]] = t;\n      }\n\n      tokens.forEach(addToAllByRangeStart);\n      comments.forEach(addToAllByRangeStart); // keys are sorted automatically\n\n      return Object.keys(all).map(function (k) {\n        return all[k];\n      });\n    }\n\n    function redeyed(code, config, opts) {\n      opts = opts || {};\n      var parser = opts.parser || esprima;\n      var jsx = !!opts.jsx; // tokenizer doesn't support JSX at this point (esprima@4.0.0)\n      // therefore we need to generate the AST via the parser not only to\n      // avoid the tokenizer from erroring but also to get JSXIdentifier tokens\n\n      var buildAst = jsx || !!opts.buildAst;\n      var hashbang = '';\n      var ast;\n      var tokens;\n      var comments;\n      var lastSplitEnd = 0;\n      var splits = [];\n      var transformedCode;\n      var all;\n      var info; // Replace hashbang line with empty whitespaces to preserve token locations\n\n      if (code[0] === '#' && code[1] === '!') {\n        hashbang = code.substr(0, code.indexOf('\\n') + 1);\n        code = Array.apply(0, Array(hashbang.length)).join(' ') + '\\n' + code.substr(hashbang.length);\n      }\n\n      if (buildAst) {\n        ast = parser.parse(code, {\n          tokens: true,\n          comment: true,\n          range: true,\n          loc: true,\n          tolerant: true,\n          jsx: true\n        });\n        tokens = ast.tokens;\n        comments = ast.comments;\n      } else {\n        tokens = [];\n        comments = [];\n        parser.tokenize(code, {\n          range: true,\n          loc: true,\n          comment: true\n        }, function (token) {\n          if (token.type === 'LineComment') {\n            token.type = 'Line';\n            comments.push(token);\n          } else if (token.type === 'BlockComment') {\n            token.type = 'Block';\n            comments.push(token);\n          } else {\n            // Optimistically upgrade 'static' to a keyword\n            if (token.type === 'Identifier' && token.value === 'static') token.type = 'Keyword';\n            tokens.push(token);\n          }\n        });\n      }\n\n      normalize(config);\n\n      function tokenIndex(tokens, tkn, start) {\n        var current;\n        var rangeStart = tkn.range[0];\n\n        for (current = start; current < tokens.length; current++) {\n          if (tokens[current].range[0] === rangeStart) return current;\n        }\n\n        throw new Error('Token %s not found at or after index: %d', tkn, start);\n      }\n\n      function process(surround) {\n        var result;\n        var currentIndex;\n        var nextIndex;\n        var skip = 0;\n        var splitEnd;\n        result = surround(code.slice(start, end), info);\n\n        if (isObject(result)) {\n          splits.push(result.replacement);\n          currentIndex = info.tokenIndex;\n          nextIndex = tokenIndex(info.tokens, result.skipPastToken, currentIndex);\n          skip = nextIndex - currentIndex;\n          splitEnd = skip > 0 ? tokens[nextIndex - 1].range[1] : end;\n        } else {\n          splits.push(result);\n          splitEnd = end;\n        }\n\n        return {\n          skip: skip,\n          splitEnd: splitEnd\n        };\n      }\n\n      function addSplit(start, end, surround, info) {\n        var result;\n        var skip = 0;\n        if (start >= end) return;\n\n        if (surround) {\n          result = process(surround);\n          skip = result.skip;\n          lastSplitEnd = result.splitEnd;\n        } else {\n          splits.push(code.slice(start, end));\n          lastSplitEnd = end;\n        }\n\n        return skip;\n      }\n\n      all = mergeTokensAndComments(tokens, comments);\n\n      for (var tokenIdx = 0; tokenIdx < all.length; tokenIdx++) {\n        var token = all[tokenIdx];\n        var surroundForType = config[token.type];\n        var surround;\n        var start;\n        var end; // At least the type (e.g., 'Keyword') needs to be specified for the token to be surrounded\n\n        if (surroundForType) {\n          // root defaults are only taken into account while resolving before/after otherwise\n          // a root default would apply to everything, even if no type default was specified\n          surround = surroundForType && surroundForType.hasOwnProperty(token.value) && surroundForType[token.value] && isFunction(surroundForType[token.value]) ? surroundForType[token.value] : surroundForType._default;\n          start = token.range[0];\n          end = token.range[1];\n          addSplit(lastSplitEnd, start);\n          info = {\n            tokenIndex: tokenIdx,\n            tokens: all,\n            ast: ast,\n            code: code\n          };\n          tokenIdx += addSplit(start, end, surround, info);\n        }\n      }\n\n      if (lastSplitEnd < code.length) {\n        addSplit(lastSplitEnd, code.length);\n      }\n\n      if (!opts.nojoin) {\n        transformedCode = splits.join('');\n\n        if (hashbang.length > 0) {\n          transformedCode = hashbang + transformedCode.substr(hashbang.length);\n        }\n      }\n\n      return {\n        ast: ast,\n        tokens: tokens,\n        comments: comments,\n        splits: splits,\n        code: transformedCode\n      };\n    }\n\n    return exportFn ? exportFn(redeyed) : redeyed;\n  }\n})();","map":{"version":3,"names":["esprima","exportFn","toString","Object","prototype","module","exports","require","redeyed","bootstrap","define","amd","window","isFunction","obj","call","isString","isObject","surroundWith","before","after","s","isNonCircular","key","objectizeString","value","vals","split","length","Error","indexOf","_before","_after","objectize","node","resolve","_parent","undefined","_default","root","process","keys","filter","hasOwnProperty","forEach","functionize","normalize","mergeTokensAndComments","tokens","comments","all","addToAllByRangeStart","t","range","map","k","code","config","opts","parser","jsx","buildAst","hashbang","ast","lastSplitEnd","splits","transformedCode","info","substr","Array","apply","join","parse","comment","loc","tolerant","tokenize","token","type","push","tokenIndex","tkn","start","current","rangeStart","surround","result","currentIndex","nextIndex","skip","splitEnd","slice","end","replacement","skipPastToken","addSplit","tokenIdx","surroundForType","nojoin"],"sources":["/Users/Ellie/Desktop/projects/book-search-engine/client/node_modules/redeyed/redeyed.js"],"sourcesContent":[";(function() {\n'use strict'\n/* global define */\n\nvar esprima\nvar exportFn\nvar toString = Object.prototype.toString\n\nif (typeof module === 'object' && typeof module.exports === 'object' && typeof require === 'function') {\n  // server side\n  esprima = require('esprima')\n  exportFn = function(redeyed) { module.exports = redeyed }\n  bootstrap(esprima, exportFn)\n} else if (typeof define === 'function' && define.amd) {\n  // client side\n  // amd\n  define(['esprima'], function(esprima) {\n      return bootstrap(esprima)\n  })\n} else if (typeof window === 'object') {\n  // no amd -> attach to window if it exists\n  // Note that this requires 'esprima' to be defined on the window, so that script has to be loaded first\n  window.redeyed = bootstrap(window.esprima)\n}\n\nfunction bootstrap(esprima, exportFn) {\n  function isFunction(obj) {\n    return toString.call(obj) === '[object Function]'\n  }\n\n  function isString(obj) {\n    return toString.call(obj) === '[object String]'\n  }\n\n  function isObject(obj) {\n    return toString.call(obj) === '[object Object]'\n  }\n\n  function surroundWith(before, after) {\n    return function(s) { return before + s + after }\n  }\n\n  function isNonCircular(key) {\n    return key !== '_parent'\n  }\n\n  function objectizeString(value) {\n    var vals = value.split(':')\n\n    if (vals.length === 0 || vals.length > 2)      {\n throw new Error(\n        'illegal string config: ' + value +\n        '\\nShould be of format \"before:after\"'\n      )\n}\n\n    if (vals.length === 1 || vals[1].length === 0) {\n      return vals.indexOf(':') < 0 ? { _before: vals[0] } : { _after: vals[0] }\n    } else {\n      return { _before: vals[0], _after: vals[1] }\n    }\n  }\n\n  function objectize(node) {\n    // Converts 'bef:aft' to { _before: bef, _after: aft }\n    // and resolves undefined before/after from parent or root\n\n    function resolve(value, key) {\n      // resolve before/after from root or parent if it isn't present on the current node\n      if (!value._parent) return undefined\n\n      // Immediate parent\n      if (value._parent._default && value._parent._default[key]) return value._parent._default[key]\n\n      // Root\n      var root = value._parent._parent\n      if (!root) return undefined\n\n      return root._default ? root._default[key] : undefined\n    }\n\n    function process(key) {\n      var value = node[key]\n\n      if (!value) return\n      if (isFunction(value)) return\n\n      // normalize all strings to objects\n      if (isString(value)) {\n        node[key] = value = objectizeString(value)\n      }\n\n      value._parent = node\n      if (isObject(value)) {\n        if (!value._before && !value._after) return objectize(value)\n\n        // resolve missing _before or _after from parent(s)\n        // in case we only have either one on this node\n        value._before =  value._before || resolve(value, '_before')\n        value._after  =  value._after  || resolve(value, '_after')\n\n        return\n      }\n\n      throw new Error('nodes need to be either {String}, {Object} or {Function}.' + value + ' is neither.')\n    }\n\n    // Process _default ones first so children can resolve missing before/after from them\n    if (node._default) process('_default')\n\n    Object.keys(node)\n      .filter(function(key) {\n        return isNonCircular(key)\n          && node.hasOwnProperty(key)\n          && key !== '_before'\n          && key !== '_after'\n          && key !== '_default'\n      })\n      .forEach(process)\n  }\n\n  function functionize(node) {\n    Object.keys(node)\n      .filter(function(key) {\n        return isNonCircular(key) && node.hasOwnProperty(key)\n      })\n      .forEach(function(key) {\n        var value = node[key]\n\n        if (isFunction(value)) return\n\n        if (isObject(value)) {\n          if (!value._before && !value._after) return functionize(value)\n\n          // at this point before/after were \"inherited\" from the parent or root\n          // (see objectize)\n          var before = value._before || ''\n          var after = value._after || ''\n\n          node[key] = surroundWith(before, after)\n          return node[key]\n        }\n      })\n  }\n\n  function normalize(root) {\n    objectize(root)\n    functionize(root)\n  }\n\n  function mergeTokensAndComments(tokens, comments) {\n    var all = {}\n\n    function addToAllByRangeStart(t) { all[ t.range[0] ] = t }\n\n    tokens.forEach(addToAllByRangeStart)\n    comments.forEach(addToAllByRangeStart)\n\n    // keys are sorted automatically\n    return Object.keys(all)\n      .map(function(k) { return all[k] })\n  }\n\n  function redeyed(code, config, opts) {\n    opts = opts || {}\n    var parser = opts.parser || esprima\n    var jsx = !!opts.jsx\n    // tokenizer doesn't support JSX at this point (esprima@4.0.0)\n    // therefore we need to generate the AST via the parser not only to\n    // avoid the tokenizer from erroring but also to get JSXIdentifier tokens\n    var buildAst = jsx || !!opts.buildAst\n\n    var hashbang =  ''\n    var ast\n    var tokens\n    var comments\n    var lastSplitEnd = 0\n    var splits = []\n    var transformedCode\n    var all\n    var info\n\n    // Replace hashbang line with empty whitespaces to preserve token locations\n    if (code[0] === '#' && code[1] === '!') {\n      hashbang = code.substr(0, code.indexOf('\\n') + 1)\n      code = Array.apply(0, Array(hashbang.length)).join(' ') + '\\n' + code.substr(hashbang.length)\n    }\n\n    if (buildAst) {\n      ast = parser.parse(code, { tokens: true, comment: true, range: true, loc: true, tolerant: true, jsx: true })\n      tokens = ast.tokens\n      comments = ast.comments\n    } else {\n      tokens = []\n      comments = []\n      parser.tokenize(code, { range: true, loc: true, comment: true }, function(token) {\n        if (token.type === 'LineComment') {\n          token.type = 'Line'\n          comments.push(token)\n        } else if (token.type === 'BlockComment') {\n          token.type = 'Block'\n          comments.push(token)\n        } else {\n          // Optimistically upgrade 'static' to a keyword\n          if (token.type === 'Identifier' && token.value === 'static') token.type = 'Keyword'\n          tokens.push(token)\n        }\n      })\n    }\n    normalize(config)\n\n    function tokenIndex(tokens, tkn, start) {\n      var current\n      var rangeStart = tkn.range[0]\n\n      for (current = start; current < tokens.length; current++) {\n        if (tokens[current].range[0] === rangeStart) return current\n      }\n\n      throw new Error('Token %s not found at or after index: %d', tkn, start)\n    }\n\n    function process(surround) {\n      var result\n      var currentIndex\n      var nextIndex\n      var skip = 0\n      var splitEnd\n\n      result = surround(code.slice(start, end), info)\n      if (isObject(result)) {\n        splits.push(result.replacement)\n\n        currentIndex =  info.tokenIndex\n        nextIndex    =  tokenIndex(info.tokens, result.skipPastToken, currentIndex)\n        skip         =  nextIndex - currentIndex\n        splitEnd     =  skip > 0 ? tokens[nextIndex - 1].range[1] : end\n      } else {\n        splits.push(result)\n        splitEnd = end\n      }\n\n      return { skip: skip, splitEnd: splitEnd }\n    }\n\n    function addSplit(start, end, surround, info) {\n      var result\n      var skip = 0\n\n      if (start >= end) return\n      if (surround) {\n        result       =  process(surround)\n        skip         =  result.skip\n        lastSplitEnd =  result.splitEnd\n      } else {\n        splits.push(code.slice(start, end))\n        lastSplitEnd = end\n      }\n\n      return skip\n    }\n\n    all = mergeTokensAndComments(tokens, comments)\n    for (var tokenIdx = 0; tokenIdx < all.length; tokenIdx++) {\n      var token = all[tokenIdx]\n      var surroundForType = config[token.type]\n      var surround\n      var start\n      var end\n\n      // At least the type (e.g., 'Keyword') needs to be specified for the token to be surrounded\n      if (surroundForType) {\n        // root defaults are only taken into account while resolving before/after otherwise\n        // a root default would apply to everything, even if no type default was specified\n        surround = surroundForType\n          && surroundForType.hasOwnProperty(token.value)\n          && surroundForType[token.value]\n          && isFunction(surroundForType[token.value])\n            ? surroundForType[token.value]\n            : surroundForType._default\n\n        start = token.range[0]\n        end = token.range[1]\n\n        addSplit(lastSplitEnd, start)\n        info = { tokenIndex: tokenIdx, tokens: all, ast: ast, code: code }\n        tokenIdx += addSplit(start, end, surround, info)\n      }\n    }\n\n    if (lastSplitEnd < code.length) {\n      addSplit(lastSplitEnd, code.length)\n    }\n\n  if (!opts.nojoin) {\n    transformedCode = splits.join('')\n    if (hashbang.length > 0) {\n      transformedCode = hashbang + transformedCode.substr(hashbang.length)\n    }\n  }\n\n    return {\n        ast      :  ast\n      , tokens   :  tokens\n      , comments :  comments\n      , splits   :  splits\n      , code     :  transformedCode\n    }\n  }\n\n  return exportFn ? exportFn(redeyed) : redeyed\n}\n})()\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}