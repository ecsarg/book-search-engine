{"ast":null,"code":"\"use strict\"; // tslint:disable interface-over-type-literal\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Parser = void 0;\n\nconst deps_1 = require(\"./deps\"); // eslint-disable-next-line new-cap\n\n\nconst m = (0, deps_1.default)() // eslint-disable-next-line node/no-missing-require\n.add('errors', () => require('./errors')) // eslint-disable-next-line node/no-missing-require\n.add('util', () => require('./util'));\nlet debug;\n\ntry {\n  // eslint-disable-next-line no-negated-condition\n  debug = process.env.CLI_FLAGS_DEBUG !== '1' ? () => {} : require('debug')('../parser');\n} catch {\n  debug = () => {};\n}\n\nconst readStdin = async () => {\n  const {\n    stdin\n  } = process;\n  let result;\n  if (stdin.isTTY || stdin.isTTY === undefined) return result;\n  result = '';\n  stdin.setEncoding('utf8');\n\n  for await (const chunk of stdin) {\n    result += chunk;\n  }\n\n  return result;\n};\n\nclass Parser {\n  constructor(input) {\n    this.input = input;\n    this.raw = [];\n    const {\n      pickBy\n    } = m.util;\n    this.context = input.context || {};\n    this.argv = [...input.argv];\n\n    this._setNames();\n\n    this.booleanFlags = pickBy(input.flags, f => f.type === 'boolean');\n    this.metaData = {};\n  }\n\n  async parse() {\n    this._debugInput();\n\n    const findLongFlag = arg => {\n      const name = arg.slice(2);\n\n      if (this.input.flags[name]) {\n        return name;\n      }\n\n      if (arg.startsWith('--no-')) {\n        const flag = this.booleanFlags[arg.slice(5)];\n        if (flag && flag.allowNo) return flag.name;\n      }\n    };\n\n    const findShortFlag = arg => {\n      return Object.keys(this.input.flags).find(k => this.input.flags[k].char === arg[1]);\n    };\n\n    const parseFlag = arg => {\n      const long = arg.startsWith('--');\n      const name = long ? findLongFlag(arg) : findShortFlag(arg);\n\n      if (!name) {\n        const i = arg.indexOf('=');\n\n        if (i !== -1) {\n          const sliced = arg.slice(i + 1);\n          this.argv.unshift(sliced);\n          const equalsParsed = parseFlag(arg.slice(0, i));\n\n          if (!equalsParsed) {\n            this.argv.shift();\n          }\n\n          return equalsParsed;\n        }\n\n        return false;\n      }\n\n      const flag = this.input.flags[name];\n\n      if (flag.type === 'option') {\n        this.currentFlag = flag;\n        const input = long || arg.length < 3 ? this.argv.shift() : arg.slice(arg[2] === '=' ? 3 : 2);\n\n        if (typeof input !== 'string') {\n          throw new m.errors.CLIError(`Flag --${name} expects a value`);\n        }\n\n        this.raw.push({\n          type: 'flag',\n          flag: flag.name,\n          input\n        });\n      } else {\n        this.raw.push({\n          type: 'flag',\n          flag: flag.name,\n          input: arg\n        }); // push the rest of the short characters back on the stack\n\n        if (!long && arg.length > 2) {\n          this.argv.unshift(`-${arg.slice(2)}`);\n        }\n      }\n\n      return true;\n    };\n\n    let parsingFlags = true;\n\n    while (this.argv.length > 0) {\n      const input = this.argv.shift();\n\n      if (parsingFlags && input.startsWith('-') && input !== '-') {\n        // attempt to parse as arg\n        if (this.input['--'] !== false && input === '--') {\n          parsingFlags = false;\n          continue;\n        }\n\n        if (parseFlag(input)) {\n          continue;\n        } // not actually a flag if it reaches here so parse as an arg\n\n      }\n\n      if (parsingFlags && this.currentFlag && this.currentFlag.multiple) {\n        this.raw.push({\n          type: 'flag',\n          flag: this.currentFlag.name,\n          input\n        });\n        continue;\n      } // not a flag, parse as arg\n\n\n      const arg = this.input.args[this._argTokens.length];\n      if (arg) arg.input = input;\n      this.raw.push({\n        type: 'arg',\n        input\n      });\n    }\n\n    const argv = await this._argv();\n\n    const args = this._args(argv);\n\n    const flags = await this._flags();\n\n    this._debugOutput(argv, args, flags);\n\n    return {\n      args,\n      argv,\n      flags,\n      raw: this.raw,\n      metadata: this.metaData\n    };\n  }\n\n  _args(argv) {\n    const args = {};\n\n    for (let i = 0; i < this.input.args.length; i++) {\n      const arg = this.input.args[i];\n      args[arg.name] = argv[i];\n    }\n\n    return args;\n  }\n\n  async _flags() {\n    const flags = {};\n    this.metaData.flags = {};\n\n    for (const token of this._flagTokens) {\n      const flag = this.input.flags[token.flag];\n      if (!flag) throw new m.errors.CLIError(`Unexpected flag ${token.flag}`);\n\n      if (flag.type === 'boolean') {\n        if (token.input === `--no-${flag.name}`) {\n          flags[token.flag] = false;\n        } else {\n          flags[token.flag] = true;\n        } // eslint-disable-next-line no-await-in-loop\n\n\n        flags[token.flag] = await flag.parse(flags[token.flag], this.context, flag);\n      } else {\n        const input = token.input;\n\n        this._validateOptions(flag, input); // eslint-disable-next-line no-await-in-loop\n\n\n        const value = flag.parse ? await flag.parse(input, this.context, flag) : input;\n\n        if (flag.multiple) {\n          flags[token.flag] = flags[token.flag] || [];\n          flags[token.flag].push(value);\n        } else {\n          flags[token.flag] = value;\n        }\n      }\n    }\n\n    for (const k of Object.keys(this.input.flags)) {\n      const flag = this.input.flags[k];\n      if (flags[k]) continue;\n\n      if (flag.env) {\n        const input = process.env[flag.env];\n\n        if (flag.type === 'option') {\n          if (input) {\n            this._validateOptions(flag, input); // eslint-disable-next-line no-await-in-loop\n\n\n            flags[k] = await flag.parse(input, this.context, flag);\n          }\n        } else if (flag.type === 'boolean') {\n          // eslint-disable-next-line no-negated-condition\n          flags[k] = input !== undefined ? ['true', 'TRUE', '1', 'yes', 'YES', 'y', 'Y'].includes(input) : false;\n        }\n      }\n\n      if (!(k in flags) && flag.default !== undefined) {\n        this.metaData.flags[k] = {\n          setFromDefault: true\n        }; // eslint-disable-next-line no-await-in-loop\n\n        const defaultValue = typeof flag.default === 'function' ? await flag.default({\n          options: flag,\n          flags,\n          ...this.context\n        }) : flag.default;\n        flags[k] = defaultValue;\n      }\n    }\n\n    return flags;\n  }\n\n  _validateOptions(flag, input) {\n    if (flag.options && !flag.options.includes(input)) throw new m.errors.FlagInvalidOptionError(flag, input);\n  }\n\n  async _argv() {\n    const args = [];\n    const tokens = this._argTokens;\n    let stdinRead = false;\n\n    for (let i = 0; i < Math.max(this.input.args.length, tokens.length); i++) {\n      const token = tokens[i];\n      const arg = this.input.args[i];\n\n      if (token) {\n        if (arg) {\n          if (arg.options && !arg.options.includes(token.input)) {\n            throw new m.errors.ArgInvalidOptionError(arg, token.input);\n          } // eslint-disable-next-line no-await-in-loop\n\n\n          args[i] = await arg.parse(token.input);\n        } else {\n          args[i] = token.input;\n        }\n      } else if (!arg.ignoreStdin && !stdinRead) {\n        // eslint-disable-next-line no-await-in-loop\n        let stdin = await readStdin();\n\n        if (stdin) {\n          stdin = stdin.trim();\n          args[i] = stdin;\n        }\n\n        stdinRead = true;\n      }\n\n      if (!args[i] && 'default' in arg) {\n        if (typeof arg.default === 'function') {\n          // eslint-disable-next-line no-await-in-loop\n          const f = await arg.default();\n          args[i] = f;\n        } else {\n          args[i] = arg.default;\n        }\n      }\n    }\n\n    return args;\n  }\n\n  _debugOutput(args, flags, argv) {\n    if (argv.length > 0) {\n      debug('argv: %o', argv);\n    }\n\n    if (Object.keys(args).length > 0) {\n      debug('args: %o', args);\n    }\n\n    if (Object.keys(flags).length > 0) {\n      debug('flags: %o', flags);\n    }\n  }\n\n  _debugInput() {\n    debug('input: %s', this.argv.join(' '));\n\n    if (this.input.args.length > 0) {\n      debug('available args: %s', this.input.args.map(a => a.name).join(' '));\n    }\n\n    if (Object.keys(this.input.flags).length === 0) return;\n    debug('available flags: %s', Object.keys(this.input.flags).map(f => `--${f}`).join(' '));\n  }\n\n  get _argTokens() {\n    return this.raw.filter(o => o.type === 'arg');\n  }\n\n  get _flagTokens() {\n    return this.raw.filter(o => o.type === 'flag');\n  }\n\n  _setNames() {\n    for (const k of Object.keys(this.input.flags)) {\n      this.input.flags[k].name = k;\n    }\n  }\n\n}\n\nexports.Parser = Parser;","map":{"version":3,"names":["Object","defineProperty","exports","value","Parser","deps_1","require","m","default","add","debug","process","env","CLI_FLAGS_DEBUG","readStdin","stdin","result","isTTY","undefined","setEncoding","chunk","constructor","input","raw","pickBy","util","context","argv","_setNames","booleanFlags","flags","f","type","metaData","parse","_debugInput","findLongFlag","arg","name","slice","startsWith","flag","allowNo","findShortFlag","keys","find","k","char","parseFlag","long","i","indexOf","sliced","unshift","equalsParsed","shift","currentFlag","length","errors","CLIError","push","parsingFlags","multiple","args","_argTokens","_argv","_args","_flags","_debugOutput","metadata","token","_flagTokens","_validateOptions","includes","setFromDefault","defaultValue","options","FlagInvalidOptionError","tokens","stdinRead","Math","max","ArgInvalidOptionError","ignoreStdin","trim","join","map","a","filter","o"],"sources":["/Users/Ellie/Desktop/projects/book-search-engine/client/node_modules/@oclif/core/lib/parser/parse.js"],"sourcesContent":["\"use strict\";\n// tslint:disable interface-over-type-literal\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Parser = void 0;\nconst deps_1 = require(\"./deps\");\n// eslint-disable-next-line new-cap\nconst m = (0, deps_1.default)()\n    // eslint-disable-next-line node/no-missing-require\n    .add('errors', () => require('./errors'))\n    // eslint-disable-next-line node/no-missing-require\n    .add('util', () => require('./util'));\nlet debug;\ntry {\n    // eslint-disable-next-line no-negated-condition\n    debug = process.env.CLI_FLAGS_DEBUG !== '1' ? () => { } : require('debug')('../parser');\n}\ncatch {\n    debug = () => { };\n}\nconst readStdin = async () => {\n    const { stdin } = process;\n    let result;\n    if (stdin.isTTY || stdin.isTTY === undefined)\n        return result;\n    result = '';\n    stdin.setEncoding('utf8');\n    for await (const chunk of stdin) {\n        result += chunk;\n    }\n    return result;\n};\nclass Parser {\n    constructor(input) {\n        this.input = input;\n        this.raw = [];\n        const { pickBy } = m.util;\n        this.context = input.context || {};\n        this.argv = [...input.argv];\n        this._setNames();\n        this.booleanFlags = pickBy(input.flags, f => f.type === 'boolean');\n        this.metaData = {};\n    }\n    async parse() {\n        this._debugInput();\n        const findLongFlag = (arg) => {\n            const name = arg.slice(2);\n            if (this.input.flags[name]) {\n                return name;\n            }\n            if (arg.startsWith('--no-')) {\n                const flag = this.booleanFlags[arg.slice(5)];\n                if (flag && flag.allowNo)\n                    return flag.name;\n            }\n        };\n        const findShortFlag = (arg) => {\n            return Object.keys(this.input.flags).find(k => this.input.flags[k].char === arg[1]);\n        };\n        const parseFlag = (arg) => {\n            const long = arg.startsWith('--');\n            const name = long ? findLongFlag(arg) : findShortFlag(arg);\n            if (!name) {\n                const i = arg.indexOf('=');\n                if (i !== -1) {\n                    const sliced = arg.slice(i + 1);\n                    this.argv.unshift(sliced);\n                    const equalsParsed = parseFlag(arg.slice(0, i));\n                    if (!equalsParsed) {\n                        this.argv.shift();\n                    }\n                    return equalsParsed;\n                }\n                return false;\n            }\n            const flag = this.input.flags[name];\n            if (flag.type === 'option') {\n                this.currentFlag = flag;\n                const input = long || arg.length < 3 ? this.argv.shift() : arg.slice(arg[2] === '=' ? 3 : 2);\n                if (typeof input !== 'string') {\n                    throw new m.errors.CLIError(`Flag --${name} expects a value`);\n                }\n                this.raw.push({ type: 'flag', flag: flag.name, input });\n            }\n            else {\n                this.raw.push({ type: 'flag', flag: flag.name, input: arg });\n                // push the rest of the short characters back on the stack\n                if (!long && arg.length > 2) {\n                    this.argv.unshift(`-${arg.slice(2)}`);\n                }\n            }\n            return true;\n        };\n        let parsingFlags = true;\n        while (this.argv.length > 0) {\n            const input = this.argv.shift();\n            if (parsingFlags && input.startsWith('-') && input !== '-') {\n                // attempt to parse as arg\n                if (this.input['--'] !== false && input === '--') {\n                    parsingFlags = false;\n                    continue;\n                }\n                if (parseFlag(input)) {\n                    continue;\n                }\n                // not actually a flag if it reaches here so parse as an arg\n            }\n            if (parsingFlags && this.currentFlag && this.currentFlag.multiple) {\n                this.raw.push({ type: 'flag', flag: this.currentFlag.name, input });\n                continue;\n            }\n            // not a flag, parse as arg\n            const arg = this.input.args[this._argTokens.length];\n            if (arg)\n                arg.input = input;\n            this.raw.push({ type: 'arg', input });\n        }\n        const argv = await this._argv();\n        const args = this._args(argv);\n        const flags = await this._flags();\n        this._debugOutput(argv, args, flags);\n        return {\n            args,\n            argv,\n            flags,\n            raw: this.raw,\n            metadata: this.metaData,\n        };\n    }\n    _args(argv) {\n        const args = {};\n        for (let i = 0; i < this.input.args.length; i++) {\n            const arg = this.input.args[i];\n            args[arg.name] = argv[i];\n        }\n        return args;\n    }\n    async _flags() {\n        const flags = {};\n        this.metaData.flags = {};\n        for (const token of this._flagTokens) {\n            const flag = this.input.flags[token.flag];\n            if (!flag)\n                throw new m.errors.CLIError(`Unexpected flag ${token.flag}`);\n            if (flag.type === 'boolean') {\n                if (token.input === `--no-${flag.name}`) {\n                    flags[token.flag] = false;\n                }\n                else {\n                    flags[token.flag] = true;\n                }\n                // eslint-disable-next-line no-await-in-loop\n                flags[token.flag] = await flag.parse(flags[token.flag], this.context, flag);\n            }\n            else {\n                const input = token.input;\n                this._validateOptions(flag, input);\n                // eslint-disable-next-line no-await-in-loop\n                const value = flag.parse ? await flag.parse(input, this.context, flag) : input;\n                if (flag.multiple) {\n                    flags[token.flag] = flags[token.flag] || [];\n                    flags[token.flag].push(value);\n                }\n                else {\n                    flags[token.flag] = value;\n                }\n            }\n        }\n        for (const k of Object.keys(this.input.flags)) {\n            const flag = this.input.flags[k];\n            if (flags[k])\n                continue;\n            if (flag.env) {\n                const input = process.env[flag.env];\n                if (flag.type === 'option') {\n                    if (input) {\n                        this._validateOptions(flag, input);\n                        // eslint-disable-next-line no-await-in-loop\n                        flags[k] = await flag.parse(input, this.context, flag);\n                    }\n                }\n                else if (flag.type === 'boolean') {\n                    // eslint-disable-next-line no-negated-condition\n                    flags[k] = input !== undefined ? ['true', 'TRUE', '1', 'yes', 'YES', 'y', 'Y'].includes(input) : false;\n                }\n            }\n            if (!(k in flags) && flag.default !== undefined) {\n                this.metaData.flags[k] = { setFromDefault: true };\n                // eslint-disable-next-line no-await-in-loop\n                const defaultValue = (typeof flag.default === 'function' ? await flag.default({ options: flag, flags, ...this.context }) : flag.default);\n                flags[k] = defaultValue;\n            }\n        }\n        return flags;\n    }\n    _validateOptions(flag, input) {\n        if (flag.options && !flag.options.includes(input))\n            throw new m.errors.FlagInvalidOptionError(flag, input);\n    }\n    async _argv() {\n        const args = [];\n        const tokens = this._argTokens;\n        let stdinRead = false;\n        for (let i = 0; i < Math.max(this.input.args.length, tokens.length); i++) {\n            const token = tokens[i];\n            const arg = this.input.args[i];\n            if (token) {\n                if (arg) {\n                    if (arg.options && !arg.options.includes(token.input)) {\n                        throw new m.errors.ArgInvalidOptionError(arg, token.input);\n                    }\n                    // eslint-disable-next-line no-await-in-loop\n                    args[i] = await arg.parse(token.input);\n                }\n                else {\n                    args[i] = token.input;\n                }\n            }\n            else if (!arg.ignoreStdin && !stdinRead) {\n                // eslint-disable-next-line no-await-in-loop\n                let stdin = await readStdin();\n                if (stdin) {\n                    stdin = stdin.trim();\n                    args[i] = stdin;\n                }\n                stdinRead = true;\n            }\n            if (!args[i] && 'default' in arg) {\n                if (typeof arg.default === 'function') {\n                    // eslint-disable-next-line no-await-in-loop\n                    const f = await arg.default();\n                    args[i] = f;\n                }\n                else {\n                    args[i] = arg.default;\n                }\n            }\n        }\n        return args;\n    }\n    _debugOutput(args, flags, argv) {\n        if (argv.length > 0) {\n            debug('argv: %o', argv);\n        }\n        if (Object.keys(args).length > 0) {\n            debug('args: %o', args);\n        }\n        if (Object.keys(flags).length > 0) {\n            debug('flags: %o', flags);\n        }\n    }\n    _debugInput() {\n        debug('input: %s', this.argv.join(' '));\n        if (this.input.args.length > 0) {\n            debug('available args: %s', this.input.args.map(a => a.name).join(' '));\n        }\n        if (Object.keys(this.input.flags).length === 0)\n            return;\n        debug('available flags: %s', Object.keys(this.input.flags)\n            .map(f => `--${f}`)\n            .join(' '));\n    }\n    get _argTokens() {\n        return this.raw.filter(o => o.type === 'arg');\n    }\n    get _flagTokens() {\n        return this.raw.filter(o => o.type === 'flag');\n    }\n    _setNames() {\n        for (const k of Object.keys(this.input.flags)) {\n            this.input.flags[k].name = k;\n        }\n    }\n}\nexports.Parser = Parser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}