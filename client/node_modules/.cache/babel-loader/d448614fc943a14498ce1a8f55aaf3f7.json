{"ast":null,"code":"\"use strict\";\n\nvar _a;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.create = exports.register = exports.getExtensions = exports.TSError = exports.normalizeSlashes = exports.parse = exports.split = exports.DEFAULTS = exports.VERSION = exports.debug = exports.INSPECT_CUSTOM = exports.REGISTER_INSTANCE = exports.createRepl = void 0;\n\nconst path_1 = require(\"path\");\n\nconst sourceMapSupport = require(\"source-map-support\");\n\nconst ynModule = require(\"yn\");\n\nconst make_error_1 = require(\"make-error\");\n\nconst util = require(\"util\");\n\nconst url_1 = require(\"url\");\n\nconst module_1 = require(\"module\"); // tslint:disable-next-line\n\n\nconst createRequire = (_a = module_1.createRequire !== null && module_1.createRequire !== void 0 ? module_1.createRequire : module_1.createRequireFromPath) !== null && _a !== void 0 ? _a : require('create-require');\n\nvar repl_1 = require(\"./repl\");\n\nObject.defineProperty(exports, \"createRepl\", {\n  enumerable: true,\n  get: function () {\n    return repl_1.createRepl;\n  }\n});\n/**\n * Does this version of node obey the package.json \"type\" field\n * and throw ERR_REQUIRE_ESM when attempting to require() an ESM modules.\n */\n\nconst engineSupportsPackageTypeField = parseInt(process.versions.node.split('.')[0], 10) >= 12; // Loaded conditionally so we don't need to support older node versions\n\nlet assertScriptCanLoadAsCJSImpl;\n/**\n * Assert that script can be loaded as CommonJS when we attempt to require it.\n * If it should be loaded as ESM, throw ERR_REQUIRE_ESM like node does.\n */\n\nfunction assertScriptCanLoadAsCJS(filename) {\n  if (!engineSupportsPackageTypeField) return;\n  if (!assertScriptCanLoadAsCJSImpl) assertScriptCanLoadAsCJSImpl = require('../dist-raw/node-cjs-loader-utils').assertScriptCanLoadAsCJSImpl;\n  assertScriptCanLoadAsCJSImpl(filename);\n}\n/**\n * Registered `ts-node` instance information.\n */\n\n\nexports.REGISTER_INSTANCE = Symbol.for('ts-node.register.instance');\n/**\n * @internal\n */\n\nexports.INSPECT_CUSTOM = util.inspect.custom || 'inspect';\n/**\n * Wrapper around yn module that returns `undefined` instead of `null`.\n * This is implemented by yn v4, but we're staying on v3 to avoid v4's node 10 requirement.\n */\n\nfunction yn(value) {\n  var _a;\n\n  return (_a = ynModule(value)) !== null && _a !== void 0 ? _a : undefined;\n}\n/**\n * Debugging `ts-node`.\n */\n\n\nconst shouldDebug = yn(process.env.TS_NODE_DEBUG);\n/** @internal */\n\nexports.debug = shouldDebug ? (...args) => console.log(`[ts-node ${new Date().toISOString()}]`, ...args) : () => undefined;\nconst debugFn = shouldDebug ? (key, fn) => {\n  let i = 0;\n  return x => {\n    exports.debug(key, x, ++i);\n    return fn(x);\n  };\n} : (_, fn) => fn;\n/**\n * Export the current version.\n */\n\nexports.VERSION = require('../package.json').version;\n/**\n * Like `Object.assign`, but ignores `undefined` properties.\n */\n\nfunction assign(initialValue, ...sources) {\n  for (const source of sources) {\n    for (const key of Object.keys(source)) {\n      const value = source[key];\n      if (value !== undefined) initialValue[key] = value;\n    }\n  }\n\n  return initialValue;\n}\n/**\n * Default register options, including values specified via environment\n * variables.\n */\n\n\nexports.DEFAULTS = {\n  dir: process.env.TS_NODE_DIR,\n  emit: yn(process.env.TS_NODE_EMIT),\n  scope: yn(process.env.TS_NODE_SCOPE),\n  files: yn(process.env.TS_NODE_FILES),\n  pretty: yn(process.env.TS_NODE_PRETTY),\n  compiler: process.env.TS_NODE_COMPILER,\n  compilerOptions: parse(process.env.TS_NODE_COMPILER_OPTIONS),\n  ignore: split(process.env.TS_NODE_IGNORE),\n  project: process.env.TS_NODE_PROJECT,\n  skipProject: yn(process.env.TS_NODE_SKIP_PROJECT),\n  skipIgnore: yn(process.env.TS_NODE_SKIP_IGNORE),\n  preferTsExts: yn(process.env.TS_NODE_PREFER_TS_EXTS),\n  ignoreDiagnostics: split(process.env.TS_NODE_IGNORE_DIAGNOSTICS),\n  transpileOnly: yn(process.env.TS_NODE_TRANSPILE_ONLY),\n  typeCheck: yn(process.env.TS_NODE_TYPE_CHECK),\n  compilerHost: yn(process.env.TS_NODE_COMPILER_HOST),\n  logError: yn(process.env.TS_NODE_LOG_ERROR),\n  experimentalEsmLoader: false\n};\n/**\n * TypeScript compiler option values required by `ts-node` which cannot be overridden.\n */\n\nconst TS_NODE_COMPILER_OPTIONS = {\n  sourceMap: true,\n  inlineSourceMap: false,\n  inlineSources: true,\n  declaration: false,\n  noEmit: false,\n  outDir: '.ts-node'\n};\n/**\n * Split a string array of values.\n */\n\nfunction split(value) {\n  return typeof value === 'string' ? value.split(/ *, */g) : undefined;\n}\n\nexports.split = split;\n/**\n * Parse a string as JSON.\n */\n\nfunction parse(value) {\n  return typeof value === 'string' ? JSON.parse(value) : undefined;\n}\n\nexports.parse = parse;\n/**\n * Replace backslashes with forward slashes.\n */\n\nfunction normalizeSlashes(value) {\n  return value.replace(/\\\\/g, '/');\n}\n\nexports.normalizeSlashes = normalizeSlashes;\n/**\n * TypeScript diagnostics error.\n */\n\nclass TSError extends make_error_1.BaseError {\n  constructor(diagnosticText, diagnosticCodes) {\n    super(`тип Unable to compile TypeScript:\\n${diagnosticText}`);\n    this.diagnosticText = diagnosticText;\n    this.diagnosticCodes = diagnosticCodes;\n    this.name = 'TSError';\n  }\n  /**\n   * @internal\n   */\n\n\n  [exports.INSPECT_CUSTOM]() {\n    return this.diagnosticText;\n  }\n\n}\n\nexports.TSError = TSError;\n/**\n * Cached fs operation wrapper.\n */\n\nfunction cachedLookup(fn) {\n  const cache = new Map();\n  return arg => {\n    if (!cache.has(arg)) {\n      cache.set(arg, fn(arg));\n    }\n\n    return cache.get(arg);\n  };\n}\n/** @internal */\n\n\nfunction getExtensions(config) {\n  const tsExtensions = ['.ts'];\n  const jsExtensions = []; // Enable additional extensions when JSX or `allowJs` is enabled.\n\n  if (config.options.jsx) tsExtensions.push('.tsx');\n  if (config.options.allowJs) jsExtensions.push('.js');\n  if (config.options.jsx && config.options.allowJs) jsExtensions.push('.jsx');\n  return {\n    tsExtensions,\n    jsExtensions\n  };\n}\n\nexports.getExtensions = getExtensions;\n/**\n * Register TypeScript compiler instance onto node.js\n */\n\nfunction register(opts = {}) {\n  const originalJsHandler = require.extensions['.js']; // tslint:disable-line\n\n  const service = create(opts);\n  const {\n    tsExtensions,\n    jsExtensions\n  } = getExtensions(service.config);\n  const extensions = [...tsExtensions, ...jsExtensions]; // Expose registered instance globally.\n\n  process[exports.REGISTER_INSTANCE] = service; // Register the extensions.\n\n  registerExtensions(service.options.preferTsExts, extensions, service, originalJsHandler);\n\n  module_1.Module._preloadModules(service.options.require);\n\n  return service;\n}\n\nexports.register = register;\n/**\n * Create TypeScript compiler instance.\n */\n\nfunction create(rawOptions = {}) {\n  var _a, _b;\n\n  const dir = (_a = rawOptions.dir) !== null && _a !== void 0 ? _a : exports.DEFAULTS.dir;\n  const compilerName = (_b = rawOptions.compiler) !== null && _b !== void 0 ? _b : exports.DEFAULTS.compiler;\n  const cwd = dir ? path_1.resolve(dir) : process.cwd();\n  /**\n   * Load the typescript compiler. It is required to load the tsconfig but might\n   * be changed by the tsconfig, so we sometimes have to do this twice.\n   */\n\n  function loadCompiler(name) {\n    const compiler = require.resolve(name || 'typescript', {\n      paths: [cwd, __dirname]\n    });\n\n    const ts = require(compiler);\n\n    return {\n      compiler,\n      ts\n    };\n  } // Compute minimum options to read the config file.\n\n\n  let {\n    compiler,\n    ts\n  } = loadCompiler(compilerName); // Read config file and merge new options between env and CLI options.\n\n  const {\n    config,\n    options: tsconfigOptions\n  } = readConfig(cwd, ts, rawOptions);\n  const options = assign({}, exports.DEFAULTS, tsconfigOptions || {}, rawOptions);\n  options.require = [...(tsconfigOptions.require || []), ...(rawOptions.require || [])]; // If `compiler` option changed based on tsconfig, re-load the compiler.\n\n  if (options.compiler !== compilerName) {\n    ({\n      compiler,\n      ts\n    } = loadCompiler(options.compiler));\n  }\n\n  const readFile = options.readFile || ts.sys.readFile;\n  const fileExists = options.fileExists || ts.sys.fileExists; // typeCheck can override transpileOnly, useful for CLI flag to override config file\n\n  const transpileOnly = options.transpileOnly === true && options.typeCheck !== true;\n  const transformers = options.transformers || undefined;\n  const ignoreDiagnostics = [6059, 18002, 18003, ...(options.ignoreDiagnostics || [])].map(Number);\n  const configDiagnosticList = filterDiagnostics(config.errors, ignoreDiagnostics);\n  const outputCache = new Map();\n  const isScoped = options.scope ? relname => relname.charAt(0) !== '.' : () => true;\n  const shouldIgnore = createIgnore(options.skipIgnore ? [] : (options.ignore || ['(?:^|/)node_modules/']).map(str => new RegExp(str)));\n  const diagnosticHost = {\n    getNewLine: () => ts.sys.newLine,\n    getCurrentDirectory: () => cwd,\n    getCanonicalFileName: ts.sys.useCaseSensitiveFileNames ? x => x : x => x.toLowerCase()\n  }; // Install source map support and read from memory cache.\n\n  sourceMapSupport.install({\n    environment: 'node',\n\n    retrieveFile(pathOrUrl) {\n      var _a;\n\n      let path = pathOrUrl; // If it's a file URL, convert to local path\n      // Note: fileURLToPath does not exist on early node v10\n      // I could not find a way to handle non-URLs except to swallow an error\n\n      if (options.experimentalEsmLoader && path.startsWith('file://')) {\n        try {\n          path = url_1.fileURLToPath(path);\n        } catch (e) {\n          /* swallow error */\n        }\n      }\n\n      path = normalizeSlashes(path);\n      return ((_a = outputCache.get(path)) === null || _a === void 0 ? void 0 : _a.content) || '';\n    }\n\n  });\n  const formatDiagnostics = process.stdout.isTTY || options.pretty ? ts.formatDiagnosticsWithColorAndContext || ts.formatDiagnostics : ts.formatDiagnostics;\n\n  function createTSError(diagnostics) {\n    const diagnosticText = formatDiagnostics(diagnostics, diagnosticHost);\n    const diagnosticCodes = diagnostics.map(x => x.code);\n    return new TSError(diagnosticText, diagnosticCodes);\n  }\n\n  function reportTSError(configDiagnosticList) {\n    const error = createTSError(configDiagnosticList);\n\n    if (options.logError) {\n      // Print error in red color and continue execution.\n      console.error('\\x1b[31m%s\\x1b[0m', error);\n    } else {\n      // Throw error and exit the script.\n      throw error;\n    }\n  } // Render the configuration errors.\n\n\n  if (configDiagnosticList.length) reportTSError(configDiagnosticList);\n  /**\n   * Get the extension for a transpiled file.\n   */\n\n  const getExtension = config.options.jsx === ts.JsxEmit.Preserve ? path => /\\.[tj]sx$/.test(path) ? '.jsx' : '.js' : _ => '.js';\n  /**\n   * Create the basic required function using transpile mode.\n   */\n\n  let getOutput;\n  let getTypeInfo;\n  const getCanonicalFileName = ts.createGetCanonicalFileName(ts.sys.useCaseSensitiveFileNames); // In a factory because these are shared across both CompilerHost and LanguageService codepaths\n\n  function createResolverFunctions(serviceHost) {\n    const moduleResolutionCache = ts.createModuleResolutionCache(cwd, getCanonicalFileName, config.options);\n    const knownInternalFilenames = new Set();\n    /** \"Buckets\" (module directories) whose contents should be marked \"internal\" */\n\n    const internalBuckets = new Set(); // Get bucket for a source filename.  Bucket is the containing `./node_modules/*/` directory\n    // For '/project/node_modules/foo/node_modules/bar/lib/index.js' bucket is '/project/node_modules/foo/node_modules/bar/'\n    // For '/project/node_modules/foo/node_modules/@scope/bar/lib/index.js' bucket is '/project/node_modules/foo/node_modules/@scope/bar/'\n\n    const moduleBucketRe = /.*\\/node_modules\\/(?:@[^\\/]+\\/)?[^\\/]+\\//;\n\n    function getModuleBucket(filename) {\n      const find = moduleBucketRe.exec(filename);\n      if (find) return find[0];\n      return '';\n    } // Mark that this file and all siblings in its bucket should be \"internal\"\n\n\n    function markBucketOfFilenameInternal(filename) {\n      internalBuckets.add(getModuleBucket(filename));\n    }\n\n    function isFileInInternalBucket(filename) {\n      return internalBuckets.has(getModuleBucket(filename));\n    }\n\n    function isFileKnownToBeInternal(filename) {\n      return knownInternalFilenames.has(filename);\n    }\n    /**\n     * If we need to emit JS for a file, force TS to consider it non-external\n     */\n\n\n    const fixupResolvedModule = resolvedModule => {\n      const {\n        resolvedFileName\n      } = resolvedModule;\n      if (resolvedFileName === undefined) return; // .ts is always switched to internal\n      // .js is switched on-demand\n\n      if (resolvedModule.isExternalLibraryImport && (resolvedFileName.endsWith('.ts') && !resolvedFileName.endsWith('.d.ts') || isFileKnownToBeInternal(resolvedFileName) || isFileInInternalBucket(resolvedFileName))) {\n        resolvedModule.isExternalLibraryImport = false;\n      }\n\n      if (!resolvedModule.isExternalLibraryImport) {\n        knownInternalFilenames.add(resolvedFileName);\n      }\n    };\n    /*\n     * NOTE:\n     * Older ts versions do not pass `redirectedReference` nor `options`.\n     * We must pass `redirectedReference` to newer ts versions, but cannot rely on `options`, hence the weird argument name\n     */\n\n\n    const resolveModuleNames = (moduleNames, containingFile, reusedNames, redirectedReference, optionsOnlyWithNewerTsVersions) => {\n      return moduleNames.map(moduleName => {\n        const {\n          resolvedModule\n        } = ts.resolveModuleName(moduleName, containingFile, config.options, serviceHost, moduleResolutionCache, redirectedReference);\n\n        if (resolvedModule) {\n          fixupResolvedModule(resolvedModule);\n        }\n\n        return resolvedModule;\n      });\n    }; // language service never calls this, but TS docs recommend that we implement it\n\n\n    const getResolvedModuleWithFailedLookupLocationsFromCache = (moduleName, containingFile) => {\n      const ret = ts.resolveModuleNameFromCache(moduleName, containingFile, moduleResolutionCache);\n\n      if (ret && ret.resolvedModule) {\n        fixupResolvedModule(ret.resolvedModule);\n      }\n\n      return ret;\n    };\n\n    const resolveTypeReferenceDirectives = (typeDirectiveNames, containingFile, redirectedReference, options) => {\n      // Note: seems to be called with empty typeDirectiveNames array for all files.\n      return typeDirectiveNames.map(typeDirectiveName => {\n        const {\n          resolvedTypeReferenceDirective\n        } = ts.resolveTypeReferenceDirective(typeDirectiveName, containingFile, config.options, serviceHost, redirectedReference);\n\n        if (resolvedTypeReferenceDirective) {\n          fixupResolvedModule(resolvedTypeReferenceDirective);\n        }\n\n        return resolvedTypeReferenceDirective;\n      });\n    };\n\n    return {\n      resolveModuleNames,\n      getResolvedModuleWithFailedLookupLocationsFromCache,\n      resolveTypeReferenceDirectives,\n      isFileKnownToBeInternal,\n      markBucketOfFilenameInternal\n    };\n  } // Use full language services when the fast option is disabled.\n\n\n  if (!transpileOnly) {\n    const fileContents = new Map();\n    const rootFileNames = new Set(config.fileNames);\n    const cachedReadFile = cachedLookup(debugFn('readFile', readFile)); // Use language services by default (TODO: invert next major version).\n\n    if (!options.compilerHost) {\n      let projectVersion = 1;\n      const fileVersions = new Map(Array.from(rootFileNames).map(fileName => [fileName, 0]));\n\n      const getCustomTransformers = () => {\n        if (typeof transformers === 'function') {\n          const program = service.getProgram();\n          return program ? transformers(program) : undefined;\n        }\n\n        return transformers;\n      }; // Create the compiler host for type checking.\n\n\n      const serviceHost = {\n        getProjectVersion: () => String(projectVersion),\n        getScriptFileNames: () => Array.from(rootFileNames),\n        getScriptVersion: fileName => {\n          const version = fileVersions.get(fileName);\n          return version ? version.toString() : '';\n        },\n\n        getScriptSnapshot(fileName) {\n          // TODO ordering of this with getScriptVersion?  Should they sync up?\n          let contents = fileContents.get(fileName); // Read contents into TypeScript memory cache.\n\n          if (contents === undefined) {\n            contents = cachedReadFile(fileName);\n            if (contents === undefined) return;\n            fileVersions.set(fileName, 1);\n            fileContents.set(fileName, contents);\n            projectVersion++;\n          }\n\n          return ts.ScriptSnapshot.fromString(contents);\n        },\n\n        readFile: cachedReadFile,\n        readDirectory: ts.sys.readDirectory,\n        getDirectories: cachedLookup(debugFn('getDirectories', ts.sys.getDirectories)),\n        fileExists: cachedLookup(debugFn('fileExists', fileExists)),\n        directoryExists: cachedLookup(debugFn('directoryExists', ts.sys.directoryExists)),\n        realpath: ts.sys.realpath ? cachedLookup(debugFn('realpath', ts.sys.realpath)) : undefined,\n        getNewLine: () => ts.sys.newLine,\n        useCaseSensitiveFileNames: () => ts.sys.useCaseSensitiveFileNames,\n        getCurrentDirectory: () => cwd,\n        getCompilationSettings: () => config.options,\n        getDefaultLibFileName: () => ts.getDefaultLibFilePath(config.options),\n        getCustomTransformers: getCustomTransformers\n      };\n      const {\n        resolveModuleNames,\n        getResolvedModuleWithFailedLookupLocationsFromCache,\n        resolveTypeReferenceDirectives,\n        isFileKnownToBeInternal,\n        markBucketOfFilenameInternal\n      } = createResolverFunctions(serviceHost);\n      serviceHost.resolveModuleNames = resolveModuleNames;\n      serviceHost.getResolvedModuleWithFailedLookupLocationsFromCache = getResolvedModuleWithFailedLookupLocationsFromCache;\n      serviceHost.resolveTypeReferenceDirectives = resolveTypeReferenceDirectives;\n      const registry = ts.createDocumentRegistry(ts.sys.useCaseSensitiveFileNames, cwd);\n      const service = ts.createLanguageService(serviceHost, registry);\n\n      const updateMemoryCache = (contents, fileName) => {\n        // Add to `rootFiles` as necessary, either to make TS include a file it has not seen,\n        // or to trigger a re-classification of files from external to internal.\n        if (!rootFileNames.has(fileName) && !isFileKnownToBeInternal(fileName)) {\n          markBucketOfFilenameInternal(fileName);\n          rootFileNames.add(fileName); // Increment project version for every change to rootFileNames.\n\n          projectVersion++;\n        }\n\n        const previousVersion = fileVersions.get(fileName) || 0;\n        const previousContents = fileContents.get(fileName); // Avoid incrementing cache when nothing has changed.\n\n        if (contents !== previousContents) {\n          fileVersions.set(fileName, previousVersion + 1);\n          fileContents.set(fileName, contents); // Increment project version for every file change.\n\n          projectVersion++;\n        }\n      };\n\n      let previousProgram = undefined;\n\n      getOutput = (code, fileName) => {\n        updateMemoryCache(code, fileName);\n        const programBefore = service.getProgram();\n\n        if (programBefore !== previousProgram) {\n          exports.debug(`compiler rebuilt Program instance when getting output for ${fileName}`);\n        }\n\n        const output = service.getEmitOutput(fileName); // Get the relevant diagnostics - this is 3x faster than `getPreEmitDiagnostics`.\n\n        const diagnostics = service.getSemanticDiagnostics(fileName).concat(service.getSyntacticDiagnostics(fileName));\n        const programAfter = service.getProgram();\n        exports.debug('invariant: Is service.getProject() identical before and after getting emit output and diagnostics? (should always be true) ', programBefore === programAfter);\n        previousProgram = programAfter;\n        const diagnosticList = filterDiagnostics(diagnostics, ignoreDiagnostics);\n        if (diagnosticList.length) reportTSError(diagnosticList);\n\n        if (output.emitSkipped) {\n          throw new TypeError(`${path_1.relative(cwd, fileName)}: Emit skipped`);\n        } // Throw an error when requiring `.d.ts` files.\n\n\n        if (output.outputFiles.length === 0) {\n          throw new TypeError(`Unable to require file: ${path_1.relative(cwd, fileName)}\\n` + 'This is usually the result of a faulty configuration or import. ' + 'Make sure there is a `.js`, `.json` or other executable extension with ' + 'loader attached before `ts-node` available.');\n        }\n\n        return [output.outputFiles[1].text, output.outputFiles[0].text];\n      };\n\n      getTypeInfo = (code, fileName, position) => {\n        updateMemoryCache(code, fileName);\n        const info = service.getQuickInfoAtPosition(fileName, position);\n        const name = ts.displayPartsToString(info ? info.displayParts : []);\n        const comment = ts.displayPartsToString(info ? info.documentation : []);\n        return {\n          name,\n          comment\n        };\n      };\n    } else {\n      const sys = Object.assign(Object.assign(Object.assign({}, ts.sys), diagnosticHost), {\n        readFile: fileName => {\n          const cacheContents = fileContents.get(fileName);\n          if (cacheContents !== undefined) return cacheContents;\n          const contents = cachedReadFile(fileName);\n          if (contents) fileContents.set(fileName, contents);\n          return contents;\n        },\n        readDirectory: ts.sys.readDirectory,\n        getDirectories: cachedLookup(debugFn('getDirectories', ts.sys.getDirectories)),\n        fileExists: cachedLookup(debugFn('fileExists', fileExists)),\n        directoryExists: cachedLookup(debugFn('directoryExists', ts.sys.directoryExists)),\n        resolvePath: cachedLookup(debugFn('resolvePath', ts.sys.resolvePath)),\n        realpath: ts.sys.realpath ? cachedLookup(debugFn('realpath', ts.sys.realpath)) : undefined\n      });\n      const host = ts.createIncrementalCompilerHost ? ts.createIncrementalCompilerHost(config.options, sys) : Object.assign(Object.assign({}, sys), {\n        getSourceFile: (fileName, languageVersion) => {\n          const contents = sys.readFile(fileName);\n          if (contents === undefined) return;\n          return ts.createSourceFile(fileName, contents, languageVersion);\n        },\n        getDefaultLibLocation: () => normalizeSlashes(path_1.dirname(compiler)),\n        getDefaultLibFileName: () => normalizeSlashes(path_1.join(path_1.dirname(compiler), ts.getDefaultLibFileName(config.options))),\n        useCaseSensitiveFileNames: () => sys.useCaseSensitiveFileNames\n      });\n      const {\n        resolveModuleNames,\n        resolveTypeReferenceDirectives,\n        isFileKnownToBeInternal,\n        markBucketOfFilenameInternal\n      } = createResolverFunctions(host);\n      host.resolveModuleNames = resolveModuleNames;\n      host.resolveTypeReferenceDirectives = resolveTypeReferenceDirectives; // Fallback for older TypeScript releases without incremental API.\n\n      let builderProgram = ts.createIncrementalProgram ? ts.createIncrementalProgram({\n        rootNames: Array.from(rootFileNames),\n        options: config.options,\n        host: host,\n        configFileParsingDiagnostics: config.errors,\n        projectReferences: config.projectReferences\n      }) : ts.createEmitAndSemanticDiagnosticsBuilderProgram(Array.from(rootFileNames), config.options, host, undefined, config.errors, config.projectReferences); // Read and cache custom transformers.\n\n      const customTransformers = typeof transformers === 'function' ? transformers(builderProgram.getProgram()) : transformers; // Set the file contents into cache manually.\n\n      const updateMemoryCache = (contents, fileName) => {\n        const previousContents = fileContents.get(fileName);\n        const contentsChanged = previousContents !== contents;\n\n        if (contentsChanged) {\n          fileContents.set(fileName, contents);\n        } // Add to `rootFiles` when discovered by compiler for the first time.\n\n\n        let addedToRootFileNames = false;\n\n        if (!rootFileNames.has(fileName) && !isFileKnownToBeInternal(fileName)) {\n          markBucketOfFilenameInternal(fileName);\n          rootFileNames.add(fileName);\n          addedToRootFileNames = true;\n        } // Update program when file changes.\n\n\n        if (addedToRootFileNames || contentsChanged) {\n          builderProgram = ts.createEmitAndSemanticDiagnosticsBuilderProgram(Array.from(rootFileNames), config.options, host, builderProgram, config.errors, config.projectReferences);\n        }\n      };\n\n      getOutput = (code, fileName) => {\n        const output = ['', ''];\n        updateMemoryCache(code, fileName);\n        const sourceFile = builderProgram.getSourceFile(fileName);\n        if (!sourceFile) throw new TypeError(`Unable to read file: ${fileName}`);\n        const program = builderProgram.getProgram();\n        const diagnostics = ts.getPreEmitDiagnostics(program, sourceFile);\n        const diagnosticList = filterDiagnostics(diagnostics, ignoreDiagnostics);\n        if (diagnosticList.length) reportTSError(diagnosticList);\n        const result = builderProgram.emit(sourceFile, (path, file, writeByteOrderMark) => {\n          if (path.endsWith('.map')) {\n            output[1] = file;\n          } else {\n            output[0] = file;\n          }\n\n          if (options.emit) sys.writeFile(path, file, writeByteOrderMark);\n        }, undefined, undefined, customTransformers);\n\n        if (result.emitSkipped) {\n          throw new TypeError(`${path_1.relative(cwd, fileName)}: Emit skipped`);\n        } // Throw an error when requiring files that cannot be compiled.\n\n\n        if (output[0] === '') {\n          if (program.isSourceFileFromExternalLibrary(sourceFile)) {\n            throw new TypeError(`Unable to compile file from external library: ${path_1.relative(cwd, fileName)}`);\n          }\n\n          throw new TypeError(`Unable to require file: ${path_1.relative(cwd, fileName)}\\n` + 'This is usually the result of a faulty configuration or import. ' + 'Make sure there is a `.js`, `.json` or other executable extension with ' + 'loader attached before `ts-node` available.');\n        }\n\n        return output;\n      };\n\n      getTypeInfo = (code, fileName, position) => {\n        updateMemoryCache(code, fileName);\n        const sourceFile = builderProgram.getSourceFile(fileName);\n        if (!sourceFile) throw new TypeError(`Unable to read file: ${fileName}`);\n        const node = getTokenAtPosition(ts, sourceFile, position);\n        const checker = builderProgram.getProgram().getTypeChecker();\n        const symbol = checker.getSymbolAtLocation(node);\n        if (!symbol) return {\n          name: '',\n          comment: ''\n        };\n        const type = checker.getTypeOfSymbolAtLocation(symbol, node);\n        const signatures = [...type.getConstructSignatures(), ...type.getCallSignatures()];\n        return {\n          name: signatures.length ? signatures.map(x => checker.signatureToString(x)).join('\\n') : checker.typeToString(type),\n          comment: ts.displayPartsToString(symbol ? symbol.getDocumentationComment(checker) : [])\n        };\n      }; // Write `.tsbuildinfo` when `--build` is enabled.\n\n\n      if (options.emit && config.options.incremental) {\n        process.on('exit', () => {\n          // Emits `.tsbuildinfo` to filesystem.\n          builderProgram.getProgram().emitBuildInfo();\n        });\n      }\n    }\n  } else {\n    if (typeof transformers === 'function') {\n      throw new TypeError('Transformers function is unavailable in \"--transpile-only\"');\n    }\n\n    getOutput = (code, fileName) => {\n      const result = ts.transpileModule(code, {\n        fileName,\n        compilerOptions: config.options,\n        reportDiagnostics: true,\n        transformers: transformers\n      });\n      const diagnosticList = filterDiagnostics(result.diagnostics || [], ignoreDiagnostics);\n      if (diagnosticList.length) reportTSError(diagnosticList);\n      return [result.outputText, result.sourceMapText];\n    };\n\n    getTypeInfo = () => {\n      throw new TypeError('Type information is unavailable in \"--transpile-only\"');\n    };\n  } // Create a simple TypeScript compiler proxy.\n\n\n  function compile(code, fileName, lineOffset = 0) {\n    const normalizedFileName = normalizeSlashes(fileName);\n    const [value, sourceMap] = getOutput(code, normalizedFileName);\n    const output = updateOutput(value, normalizedFileName, sourceMap, getExtension);\n    outputCache.set(normalizedFileName, {\n      content: output\n    });\n    return output;\n  }\n\n  let active = true;\n\n  const enabled = enabled => enabled === undefined ? active : active = !!enabled;\n\n  const extensions = getExtensions(config);\n\n  const ignored = fileName => {\n    if (!active) return true;\n    const ext = path_1.extname(fileName);\n\n    if (extensions.tsExtensions.includes(ext) || extensions.jsExtensions.includes(ext)) {\n      const relname = path_1.relative(cwd, fileName);\n      return !isScoped(relname) || shouldIgnore(relname);\n    }\n\n    return true;\n  };\n\n  return {\n    ts,\n    config,\n    compile,\n    getTypeInfo,\n    ignored,\n    enabled,\n    options\n  };\n}\n\nexports.create = create;\n/**\n * Check if the filename should be ignored.\n */\n\nfunction createIgnore(ignore) {\n  return relname => {\n    const path = normalizeSlashes(relname);\n    return ignore.some(x => x.test(path));\n  };\n}\n/**\n * \"Refreshes\" an extension on `require.extensions`.\n *\n * @param {string} ext\n */\n\n\nfunction reorderRequireExtension(ext) {\n  const old = require.extensions[ext]; // tslint:disable-line\n\n  delete require.extensions[ext]; // tslint:disable-line\n\n  require.extensions[ext] = old; // tslint:disable-line\n}\n/**\n * Register the extensions to support when importing files.\n */\n\n\nfunction registerExtensions(preferTsExts, extensions, service, originalJsHandler) {\n  // Register new extensions.\n  for (const ext of extensions) {\n    registerExtension(ext, service, originalJsHandler);\n  }\n\n  if (preferTsExts) {\n    // tslint:disable-next-line\n    const preferredExtensions = new Set([...extensions, ...Object.keys(require.extensions)]);\n\n    for (const ext of preferredExtensions) reorderRequireExtension(ext);\n  }\n}\n/**\n * Register the extension for node.\n */\n\n\nfunction registerExtension(ext, service, originalHandler) {\n  const old = require.extensions[ext] || originalHandler; // tslint:disable-line\n\n  require.extensions[ext] = function (m, filename) {\n    if (service.ignored(filename)) return old(m, filename);\n\n    if (service.options.experimentalEsmLoader) {\n      assertScriptCanLoadAsCJS(filename);\n    }\n\n    const _compile = m._compile;\n\n    m._compile = function (code, fileName) {\n      exports.debug('module._compile', fileName);\n      return _compile.call(this, service.compile(code, fileName), fileName);\n    };\n\n    return old(m, filename);\n  };\n}\n/**\n * Do post-processing on config options to support `ts-node`.\n */\n\n\nfunction fixConfig(ts, config) {\n  // Delete options that *should not* be passed through.\n  delete config.options.out;\n  delete config.options.outFile;\n  delete config.options.composite;\n  delete config.options.declarationDir;\n  delete config.options.declarationMap;\n  delete config.options.emitDeclarationOnly; // Target ES5 output by default (instead of ES3).\n\n  if (config.options.target === undefined) {\n    config.options.target = ts.ScriptTarget.ES5;\n  } // Target CommonJS modules by default (instead of magically switching to ES6 when the target is ES6).\n\n\n  if (config.options.module === undefined) {\n    config.options.module = ts.ModuleKind.CommonJS;\n  }\n\n  return config;\n}\n/**\n * Load TypeScript configuration. Returns the parsed TypeScript config and\n * any `ts-node` options specified in the config file.\n */\n\n\nfunction readConfig(cwd, ts, rawOptions) {\n  var _a, _b;\n\n  let config = {\n    compilerOptions: {}\n  };\n  let basePath = cwd;\n  let configFileName = undefined;\n  const {\n    fileExists = ts.sys.fileExists,\n    readFile = ts.sys.readFile,\n    skipProject = exports.DEFAULTS.skipProject,\n    project = exports.DEFAULTS.project\n  } = rawOptions; // Read project configuration when available.\n\n  if (!skipProject) {\n    configFileName = project ? path_1.resolve(cwd, project) : ts.findConfigFile(cwd, fileExists);\n\n    if (configFileName) {\n      const result = ts.readConfigFile(configFileName, readFile); // Return diagnostics.\n\n      if (result.error) {\n        return {\n          config: {\n            errors: [result.error],\n            fileNames: [],\n            options: {}\n          },\n          options: {}\n        };\n      }\n\n      config = result.config;\n      basePath = path_1.dirname(configFileName);\n    }\n  } // Fix ts-node options that come from tsconfig.json\n\n\n  const tsconfigOptions = Object.assign({}, config['ts-node']); // Remove resolution of \"files\".\n\n  const files = (_b = (_a = rawOptions.files) !== null && _a !== void 0 ? _a : tsconfigOptions.files) !== null && _b !== void 0 ? _b : exports.DEFAULTS.files;\n\n  if (!files) {\n    config.files = [];\n    config.include = [];\n  } // Override default configuration options `ts-node` requires.\n\n\n  config.compilerOptions = Object.assign({}, config.compilerOptions, exports.DEFAULTS.compilerOptions, tsconfigOptions.compilerOptions, rawOptions.compilerOptions, TS_NODE_COMPILER_OPTIONS);\n  const fixedConfig = fixConfig(ts, ts.parseJsonConfigFileContent(config, {\n    fileExists,\n    readFile,\n    readDirectory: ts.sys.readDirectory,\n    useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames\n  }, basePath, undefined, configFileName));\n\n  if (tsconfigOptions.require) {\n    // Modules are found relative to the tsconfig file, not the `dir` option\n    const tsconfigRelativeRequire = createRequire(configFileName);\n    tsconfigOptions.require = tsconfigOptions.require.map(path => {\n      return tsconfigRelativeRequire.resolve(path);\n    });\n  }\n\n  return {\n    config: fixedConfig,\n    options: tsconfigOptions\n  };\n}\n/**\n * Update the output remapping the source map.\n */\n\n\nfunction updateOutput(outputText, fileName, sourceMap, getExtension) {\n  const base64Map = Buffer.from(updateSourceMap(sourceMap, fileName), 'utf8').toString('base64');\n  const sourceMapContent = `data:application/json;charset=utf-8;base64,${base64Map}`;\n  const sourceMapLength = `${path_1.basename(fileName)}.map`.length + (getExtension(fileName).length - path_1.extname(fileName).length);\n  return outputText.slice(0, -sourceMapLength) + sourceMapContent;\n}\n/**\n * Update the source map contents for improved output.\n */\n\n\nfunction updateSourceMap(sourceMapText, fileName) {\n  const sourceMap = JSON.parse(sourceMapText);\n  sourceMap.file = fileName;\n  sourceMap.sources = [fileName];\n  delete sourceMap.sourceRoot;\n  return JSON.stringify(sourceMap);\n}\n/**\n * Filter diagnostics.\n */\n\n\nfunction filterDiagnostics(diagnostics, ignore) {\n  return diagnostics.filter(x => ignore.indexOf(x.code) === -1);\n}\n/**\n * Get token at file position.\n *\n * Reference: https://github.com/microsoft/TypeScript/blob/fcd9334f57d85b73dd66ad2d21c02e84822f4841/src/services/utilities.ts#L705-L731\n */\n\n\nfunction getTokenAtPosition(ts, sourceFile, position) {\n  let current = sourceFile;\n\n  outer: while (true) {\n    for (const child of current.getChildren(sourceFile)) {\n      const start = child.getFullStart();\n      if (start > position) break;\n      const end = child.getEnd();\n\n      if (position <= end) {\n        current = child;\n        continue outer;\n      }\n    }\n\n    return current;\n  }\n}","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { relative, basename, extname, resolve, dirname, join } from 'path'\nimport sourceMapSupport = require('source-map-support')\nimport * as ynModule from 'yn'\nimport { BaseError } from 'make-error'\nimport * as util from 'util'\nimport { fileURLToPath } from 'url'\nimport type * as _ts from 'typescript'\nimport { Module, createRequire as nodeCreateRequire, createRequireFromPath as nodeCreateRequireFromPath } from 'module'\nimport type _createRequire from 'create-require'\n// tslint:disable-next-line\nconst createRequire = nodeCreateRequire ?? nodeCreateRequireFromPath ?? require('create-require') as typeof _createRequire\n\nexport { createRepl, CreateReplOptions, ReplService } from './repl'\n\n/**\n * Does this version of node obey the package.json \"type\" field\n * and throw ERR_REQUIRE_ESM when attempting to require() an ESM modules.\n */\nconst engineSupportsPackageTypeField = parseInt(process.versions.node.split('.')[0], 10) >= 12\n\n// Loaded conditionally so we don't need to support older node versions\nlet assertScriptCanLoadAsCJSImpl: ((filename: string) => void) | undefined\n\n/**\n * Assert that script can be loaded as CommonJS when we attempt to require it.\n * If it should be loaded as ESM, throw ERR_REQUIRE_ESM like node does.\n */\nfunction assertScriptCanLoadAsCJS (filename: string) {\n  if (!engineSupportsPackageTypeField) return\n  if (!assertScriptCanLoadAsCJSImpl) assertScriptCanLoadAsCJSImpl = require('../dist-raw/node-cjs-loader-utils').assertScriptCanLoadAsCJSImpl\n  assertScriptCanLoadAsCJSImpl!(filename)\n}\n\n/**\n * Registered `ts-node` instance information.\n */\nexport const REGISTER_INSTANCE = Symbol.for('ts-node.register.instance')\n\n/**\n * Expose `REGISTER_INSTANCE` information on node.js `process`.\n */\ndeclare global {\n  namespace NodeJS {\n    interface Process {\n      [REGISTER_INSTANCE]?: Service\n    }\n  }\n}\n\n/**\n * @internal\n */\nexport const INSPECT_CUSTOM = util.inspect.custom || 'inspect'\n\n/**\n * Wrapper around yn module that returns `undefined` instead of `null`.\n * This is implemented by yn v4, but we're staying on v3 to avoid v4's node 10 requirement.\n */\nfunction yn (value: string | undefined) {\n  return ynModule(value) ?? undefined\n}\n\n/**\n * Debugging `ts-node`.\n */\nconst shouldDebug = yn(process.env.TS_NODE_DEBUG)\n/** @internal */\nexport const debug = shouldDebug ?\n  (...args: any) => console.log(`[ts-node ${new Date().toISOString()}]`, ...args)\n  : () => undefined\nconst debugFn = shouldDebug ?\n  <T, U>(key: string, fn: (arg: T) => U) => {\n    let i = 0\n    return (x: T) => {\n      debug(key, x, ++i)\n      return fn(x)\n    }\n  } :\n  <T, U>(_: string, fn: (arg: T) => U) => fn\n\n/**\n * Common TypeScript interfaces between versions.\n */\nexport interface TSCommon {\n  version: typeof _ts.version\n  sys: typeof _ts.sys\n  ScriptSnapshot: typeof _ts.ScriptSnapshot\n  displayPartsToString: typeof _ts.displayPartsToString\n  createLanguageService: typeof _ts.createLanguageService\n  getDefaultLibFilePath: typeof _ts.getDefaultLibFilePath\n  getPreEmitDiagnostics: typeof _ts.getPreEmitDiagnostics\n  flattenDiagnosticMessageText: typeof _ts.flattenDiagnosticMessageText\n  transpileModule: typeof _ts.transpileModule\n  ModuleKind: typeof _ts.ModuleKind\n  ScriptTarget: typeof _ts.ScriptTarget\n  findConfigFile: typeof _ts.findConfigFile\n  readConfigFile: typeof _ts.readConfigFile\n  parseJsonConfigFileContent: typeof _ts.parseJsonConfigFileContent\n  formatDiagnostics: typeof _ts.formatDiagnostics\n  formatDiagnosticsWithColorAndContext: typeof _ts.formatDiagnosticsWithColorAndContext\n}\n\n/**\n * Compiler APIs we use that are marked internal and not included in TypeScript's public API declarations\n */\ninterface TSInternal {\n  // https://github.com/microsoft/TypeScript/blob/4a34294908bed6701dcba2456ca7ac5eafe0ddff/src/compiler/core.ts#L1906-L1909\n  createGetCanonicalFileName (useCaseSensitiveFileNames: boolean): TSInternal.GetCanonicalFileName\n}\nnamespace TSInternal {\n  // https://github.com/microsoft/TypeScript/blob/4a34294908bed6701dcba2456ca7ac5eafe0ddff/src/compiler/core.ts#L1906\n  export type GetCanonicalFileName = (fileName: string) => string\n}\n\n/**\n * Export the current version.\n */\nexport const VERSION = require('../package.json').version\n\n/**\n * Options for creating a new TypeScript compiler instance.\n */\nexport interface CreateOptions {\n  /**\n   * Specify working directory for config resolution.\n   *\n   * @default process.cwd()\n   */\n  dir?: string\n  /**\n   * Emit output files into `.ts-node` directory.\n   *\n   * @default false\n   */\n  emit?: boolean\n  /**\n   * Scope compiler to files within `cwd`.\n   *\n   * @default false\n   */\n  scope?: boolean\n  /**\n   * Use pretty diagnostic formatter.\n   *\n   * @default false\n   */\n  pretty?: boolean\n  /**\n   * Use TypeScript's faster `transpileModule`.\n   *\n   * @default false\n   */\n  transpileOnly?: boolean\n  /**\n   * **DEPRECATED** Specify type-check is enabled (e.g. `transpileOnly == false`).\n   *\n   * @default true\n   */\n  typeCheck?: boolean\n  /**\n   * Use TypeScript's compiler host API.\n   *\n   * @default false\n   */\n  compilerHost?: boolean\n  /**\n   * Logs TypeScript errors to stderr instead of throwing exceptions.\n   *\n   * @default false\n   */\n  logError?: boolean\n  /**\n   * Load files from `tsconfig.json` on startup.\n   *\n   * @default false\n   */\n  files?: boolean\n  /**\n   * Specify a custom TypeScript compiler.\n   *\n   * @default \"typescript\"\n   */\n  compiler?: string\n  /**\n   * Override the path patterns to skip compilation.\n   *\n   * @default /node_modules/\n   * @docsDefault \"/node_modules/\"\n   */\n  ignore?: string[]\n  /**\n   * Path to TypeScript JSON project file.\n   */\n  project?: string\n  /**\n   * Skip project config resolution and loading.\n   *\n   * @default false\n   */\n  skipProject?: boolean\n  /**\n   * Skip ignore check.\n   *\n   * @default false\n   */\n  skipIgnore?: boolean\n  /**\n   * JSON object to merge with compiler options.\n   *\n   * @allOf [{\"$ref\": \"https://schemastore.azurewebsites.net/schemas/json/tsconfig.json#definitions/compilerOptionsDefinition/properties/compilerOptions\"}]\n   */\n  compilerOptions?: object\n  /**\n   * Ignore TypeScript warnings by diagnostic code.\n   */\n  ignoreDiagnostics?: Array<number | string>\n  /**\n   * Modules to require, like node's `--require` flag.\n   *\n   * If specified in tsconfig.json, the modules will be resolved relative to the tsconfig.json file.\n   *\n   * If specified programmatically, each input string should be pre-resolved to an absolute path for\n   * best results.\n   */\n  require?: Array<string>\n  readFile?: (path: string) => string | undefined\n  fileExists?: (path: string) => boolean\n  transformers?: _ts.CustomTransformers | ((p: _ts.Program) => _ts.CustomTransformers)\n  /**\n   * True if require() hooks should interop with experimental ESM loader.\n   * Enabled explicitly via a flag since it is a breaking change.\n   * @internal\n   */\n  experimentalEsmLoader?: boolean\n}\n\n/**\n * Options for registering a TypeScript compiler instance globally.\n */\nexport interface RegisterOptions extends CreateOptions {\n  /**\n   * Re-order file extensions so that TypeScript imports are preferred.\n   *\n   * @default false\n   */\n  preferTsExts?: boolean\n}\n\n/**\n * Must be an interface to support `typescript-json-schema`.\n */\nexport interface TsConfigOptions extends Omit<RegisterOptions,\n  | 'transformers'\n  | 'readFile'\n  | 'fileExists'\n  | 'skipProject'\n  | 'project'\n  | 'dir'\n  > {}\n\n/**\n * Like `Object.assign`, but ignores `undefined` properties.\n */\nfunction assign<T extends object> (initialValue: T, ...sources: Array<T>): T {\n  for (const source of sources) {\n    for (const key of Object.keys(source)) {\n      const value = (source as any)[key]\n      if (value !== undefined) (initialValue as any)[key] = value\n    }\n  }\n  return initialValue\n}\n\n/**\n * Information retrieved from type info check.\n */\nexport interface TypeInfo {\n  name: string\n  comment: string\n}\n\n/**\n * Default register options, including values specified via environment\n * variables.\n */\nexport const DEFAULTS: RegisterOptions = {\n  dir: process.env.TS_NODE_DIR,\n  emit: yn(process.env.TS_NODE_EMIT),\n  scope: yn(process.env.TS_NODE_SCOPE),\n  files: yn(process.env.TS_NODE_FILES),\n  pretty: yn(process.env.TS_NODE_PRETTY),\n  compiler: process.env.TS_NODE_COMPILER,\n  compilerOptions: parse(process.env.TS_NODE_COMPILER_OPTIONS),\n  ignore: split(process.env.TS_NODE_IGNORE),\n  project: process.env.TS_NODE_PROJECT,\n  skipProject: yn(process.env.TS_NODE_SKIP_PROJECT),\n  skipIgnore: yn(process.env.TS_NODE_SKIP_IGNORE),\n  preferTsExts: yn(process.env.TS_NODE_PREFER_TS_EXTS),\n  ignoreDiagnostics: split(process.env.TS_NODE_IGNORE_DIAGNOSTICS),\n  transpileOnly: yn(process.env.TS_NODE_TRANSPILE_ONLY),\n  typeCheck: yn(process.env.TS_NODE_TYPE_CHECK),\n  compilerHost: yn(process.env.TS_NODE_COMPILER_HOST),\n  logError: yn(process.env.TS_NODE_LOG_ERROR),\n  experimentalEsmLoader: false\n}\n\n/**\n * TypeScript compiler option values required by `ts-node` which cannot be overridden.\n */\nconst TS_NODE_COMPILER_OPTIONS = {\n  sourceMap: true,\n  inlineSourceMap: false,\n  inlineSources: true,\n  declaration: false,\n  noEmit: false,\n  outDir: '.ts-node'\n}\n\n/**\n * Split a string array of values.\n */\nexport function split (value: string | undefined) {\n  return typeof value === 'string' ? value.split(/ *, */g) : undefined\n}\n\n/**\n * Parse a string as JSON.\n */\nexport function parse (value: string | undefined): object | undefined {\n  return typeof value === 'string' ? JSON.parse(value) : undefined\n}\n\n/**\n * Replace backslashes with forward slashes.\n */\nexport function normalizeSlashes (value: string): string {\n  return value.replace(/\\\\/g, '/')\n}\n\n/**\n * TypeScript diagnostics error.\n */\nexport class TSError extends BaseError {\n  name = 'TSError'\n\n  constructor (public diagnosticText: string, public diagnosticCodes: number[]) {\n    super(`тип Unable to compile TypeScript:\\n${diagnosticText}`)\n  }\n\n  /**\n   * @internal\n   */\n  [INSPECT_CUSTOM] () {\n    return this.diagnosticText\n  }\n}\n\n/**\n * Primary ts-node service, which wraps the TypeScript API and can compile TypeScript to JavaScript\n */\nexport interface Service {\n  ts: TSCommon\n  config: _ts.ParsedCommandLine\n  options: RegisterOptions\n  enabled (enabled?: boolean): boolean\n  ignored (fileName: string): boolean\n  compile (code: string, fileName: string, lineOffset?: number): string\n  getTypeInfo (code: string, fileName: string, position: number): TypeInfo\n}\n\n/**\n * Re-export of `Service` interface for backwards-compatibility\n * @deprecated use `Service` instead\n * @see Service\n */\nexport type Register = Service\n\n/**\n * Cached fs operation wrapper.\n */\nfunction cachedLookup<T> (fn: (arg: string) => T): (arg: string) => T {\n  const cache = new Map<string, T>()\n\n  return (arg: string): T => {\n    if (!cache.has(arg)) {\n      cache.set(arg, fn(arg))\n    }\n\n    return cache.get(arg)!\n  }\n}\n\n/** @internal */\nexport function getExtensions (config: _ts.ParsedCommandLine) {\n  const tsExtensions = ['.ts']\n  const jsExtensions = []\n\n  // Enable additional extensions when JSX or `allowJs` is enabled.\n  if (config.options.jsx) tsExtensions.push('.tsx')\n  if (config.options.allowJs) jsExtensions.push('.js')\n  if (config.options.jsx && config.options.allowJs) jsExtensions.push('.jsx')\n  return { tsExtensions, jsExtensions }\n}\n\n/**\n * Register TypeScript compiler instance onto node.js\n */\nexport function register (opts: RegisterOptions = {}): Service {\n  const originalJsHandler = require.extensions['.js'] // tslint:disable-line\n  const service = create(opts)\n  const { tsExtensions, jsExtensions } = getExtensions(service.config)\n  const extensions = [...tsExtensions, ...jsExtensions]\n\n  // Expose registered instance globally.\n  process[REGISTER_INSTANCE] = service\n\n  // Register the extensions.\n  registerExtensions(service.options.preferTsExts, extensions, service, originalJsHandler)\n\n  // Require specified modules before start-up.\n  ;(Module as any)._preloadModules(service.options.require)\n\n  return service\n}\n\n/**\n * Create TypeScript compiler instance.\n */\nexport function create (rawOptions: CreateOptions = {}): Service {\n  const dir = rawOptions.dir ?? DEFAULTS.dir\n  const compilerName = rawOptions.compiler ?? DEFAULTS.compiler\n  const cwd = dir ? resolve(dir) : process.cwd()\n\n  /**\n   * Load the typescript compiler. It is required to load the tsconfig but might\n   * be changed by the tsconfig, so we sometimes have to do this twice.\n   */\n  function loadCompiler (name: string | undefined) {\n    const compiler = require.resolve(name || 'typescript', { paths: [cwd, __dirname] })\n    const ts: typeof _ts = require(compiler)\n    return { compiler, ts }\n  }\n\n  // Compute minimum options to read the config file.\n  let { compiler, ts } = loadCompiler(compilerName)\n\n  // Read config file and merge new options between env and CLI options.\n  const { config, options: tsconfigOptions } = readConfig(cwd, ts, rawOptions)\n  const options = assign<RegisterOptions>({}, DEFAULTS, tsconfigOptions || {}, rawOptions)\n  options.require = [\n    ...tsconfigOptions.require || [],\n    ...rawOptions.require || []\n  ]\n\n  // If `compiler` option changed based on tsconfig, re-load the compiler.\n  if (options.compiler !== compilerName) {\n    ({ compiler, ts } = loadCompiler(options.compiler))\n  }\n\n  const readFile = options.readFile || ts.sys.readFile\n  const fileExists = options.fileExists || ts.sys.fileExists\n  // typeCheck can override transpileOnly, useful for CLI flag to override config file\n  const transpileOnly = options.transpileOnly === true && options.typeCheck !== true\n  const transformers = options.transformers || undefined\n  const ignoreDiagnostics = [\n    6059, // \"'rootDir' is expected to contain all source files.\"\n    18002, // \"The 'files' list in config file is empty.\"\n    18003, // \"No inputs were found in config file.\"\n    ...(options.ignoreDiagnostics || [])\n  ].map(Number)\n\n  const configDiagnosticList = filterDiagnostics(config.errors, ignoreDiagnostics)\n  const outputCache = new Map<string, {\n    content: string\n  }>()\n\n  const isScoped = options.scope ? (relname: string) => relname.charAt(0) !== '.' : () => true\n  const shouldIgnore = createIgnore(options.skipIgnore ? [] : (\n    options.ignore || ['(?:^|/)node_modules/']\n  ).map(str => new RegExp(str)))\n\n  const diagnosticHost: _ts.FormatDiagnosticsHost = {\n    getNewLine: () => ts.sys.newLine,\n    getCurrentDirectory: () => cwd,\n    getCanonicalFileName: ts.sys.useCaseSensitiveFileNames ? x => x : x => x.toLowerCase()\n  }\n\n  // Install source map support and read from memory cache.\n  sourceMapSupport.install({\n    environment: 'node',\n    retrieveFile (pathOrUrl: string) {\n      let path = pathOrUrl\n      // If it's a file URL, convert to local path\n      // Note: fileURLToPath does not exist on early node v10\n      // I could not find a way to handle non-URLs except to swallow an error\n      if (options.experimentalEsmLoader && path.startsWith('file://')) {\n        try {\n          path = fileURLToPath(path)\n        } catch (e) {/* swallow error */}\n      }\n      path = normalizeSlashes(path)\n      return outputCache.get(path)?.content || ''\n    }\n  })\n\n  const formatDiagnostics = process.stdout.isTTY || options.pretty\n    ? (ts.formatDiagnosticsWithColorAndContext || ts.formatDiagnostics)\n    : ts.formatDiagnostics\n\n  function createTSError (diagnostics: ReadonlyArray<_ts.Diagnostic>) {\n    const diagnosticText = formatDiagnostics(diagnostics, diagnosticHost)\n    const diagnosticCodes = diagnostics.map(x => x.code)\n    return new TSError(diagnosticText, diagnosticCodes)\n  }\n\n  function reportTSError (configDiagnosticList: _ts.Diagnostic[]) {\n    const error = createTSError(configDiagnosticList)\n    if (options.logError) {\n      // Print error in red color and continue execution.\n      console.error('\\x1b[31m%s\\x1b[0m', error)\n    } else {\n      // Throw error and exit the script.\n      throw error\n    }\n  }\n\n  // Render the configuration errors.\n  if (configDiagnosticList.length) reportTSError(configDiagnosticList)\n\n  /**\n   * Get the extension for a transpiled file.\n   */\n  const getExtension = config.options.jsx === ts.JsxEmit.Preserve ?\n    ((path: string) => /\\.[tj]sx$/.test(path) ? '.jsx' : '.js') :\n    ((_: string) => '.js')\n\n  /**\n   * Create the basic required function using transpile mode.\n   */\n  let getOutput: (code: string, fileName: string) => SourceOutput\n  let getTypeInfo: (_code: string, _fileName: string, _position: number) => TypeInfo\n\n  const getCanonicalFileName = (ts as unknown as TSInternal).createGetCanonicalFileName(ts.sys.useCaseSensitiveFileNames)\n\n  // In a factory because these are shared across both CompilerHost and LanguageService codepaths\n  function createResolverFunctions (serviceHost: _ts.ModuleResolutionHost) {\n    const moduleResolutionCache = ts.createModuleResolutionCache(cwd, getCanonicalFileName, config.options)\n    const knownInternalFilenames = new Set<string>()\n    /** \"Buckets\" (module directories) whose contents should be marked \"internal\" */\n    const internalBuckets = new Set<string>()\n\n    // Get bucket for a source filename.  Bucket is the containing `./node_modules/*/` directory\n    // For '/project/node_modules/foo/node_modules/bar/lib/index.js' bucket is '/project/node_modules/foo/node_modules/bar/'\n    // For '/project/node_modules/foo/node_modules/@scope/bar/lib/index.js' bucket is '/project/node_modules/foo/node_modules/@scope/bar/'\n    const moduleBucketRe = /.*\\/node_modules\\/(?:@[^\\/]+\\/)?[^\\/]+\\//\n    function getModuleBucket (filename: string) {\n      const find = moduleBucketRe.exec(filename)\n      if (find) return find[0]\n      return ''\n    }\n\n    // Mark that this file and all siblings in its bucket should be \"internal\"\n    function markBucketOfFilenameInternal (filename: string) {\n      internalBuckets.add(getModuleBucket(filename))\n    }\n\n    function isFileInInternalBucket (filename: string) {\n      return internalBuckets.has(getModuleBucket(filename))\n    }\n\n    function isFileKnownToBeInternal (filename: string) {\n      return knownInternalFilenames.has(filename)\n    }\n\n    /**\n     * If we need to emit JS for a file, force TS to consider it non-external\n     */\n    const fixupResolvedModule = (resolvedModule: _ts.ResolvedModule | _ts.ResolvedTypeReferenceDirective) => {\n      const { resolvedFileName } = resolvedModule\n      if (resolvedFileName === undefined) return\n      // .ts is always switched to internal\n      // .js is switched on-demand\n      if (\n        resolvedModule.isExternalLibraryImport && (\n          (resolvedFileName.endsWith('.ts') && !resolvedFileName.endsWith('.d.ts')) ||\n          isFileKnownToBeInternal(resolvedFileName) ||\n          isFileInInternalBucket(resolvedFileName)\n        )\n      ) {\n        resolvedModule.isExternalLibraryImport = false\n      }\n      if (!resolvedModule.isExternalLibraryImport) {\n        knownInternalFilenames.add(resolvedFileName)\n      }\n    }\n    /*\n     * NOTE:\n     * Older ts versions do not pass `redirectedReference` nor `options`.\n     * We must pass `redirectedReference` to newer ts versions, but cannot rely on `options`, hence the weird argument name\n     */\n    const resolveModuleNames: _ts.LanguageServiceHost['resolveModuleNames'] = (moduleNames: string[], containingFile: string, reusedNames: string[] | undefined, redirectedReference: _ts.ResolvedProjectReference | undefined, optionsOnlyWithNewerTsVersions: _ts.CompilerOptions): (_ts.ResolvedModule | undefined)[] => {\n      return moduleNames.map(moduleName => {\n        const { resolvedModule } = ts.resolveModuleName(moduleName, containingFile, config.options, serviceHost, moduleResolutionCache, redirectedReference)\n        if (resolvedModule) {\n          fixupResolvedModule(resolvedModule)\n        }\n        return resolvedModule\n      })\n    }\n\n    // language service never calls this, but TS docs recommend that we implement it\n    const getResolvedModuleWithFailedLookupLocationsFromCache: _ts.LanguageServiceHost['getResolvedModuleWithFailedLookupLocationsFromCache'] = (moduleName, containingFile): _ts.ResolvedModuleWithFailedLookupLocations | undefined => {\n      const ret = ts.resolveModuleNameFromCache(moduleName, containingFile, moduleResolutionCache)\n      if (ret && ret.resolvedModule) {\n        fixupResolvedModule(ret.resolvedModule)\n      }\n      return ret\n    }\n\n    const resolveTypeReferenceDirectives: _ts.LanguageServiceHost['resolveTypeReferenceDirectives'] = (typeDirectiveNames: string[], containingFile: string, redirectedReference: _ts.ResolvedProjectReference | undefined, options: _ts.CompilerOptions): (_ts.ResolvedTypeReferenceDirective | undefined)[] => {\n      // Note: seems to be called with empty typeDirectiveNames array for all files.\n      return typeDirectiveNames.map(typeDirectiveName => {\n        const { resolvedTypeReferenceDirective } = ts.resolveTypeReferenceDirective(typeDirectiveName, containingFile, config.options, serviceHost, redirectedReference)\n        if (resolvedTypeReferenceDirective) {\n          fixupResolvedModule(resolvedTypeReferenceDirective)\n        }\n        return resolvedTypeReferenceDirective\n      })\n    }\n\n    return {\n      resolveModuleNames,\n      getResolvedModuleWithFailedLookupLocationsFromCache,\n      resolveTypeReferenceDirectives,\n      isFileKnownToBeInternal,\n      markBucketOfFilenameInternal\n    }\n  }\n\n  // Use full language services when the fast option is disabled.\n  if (!transpileOnly) {\n    const fileContents = new Map<string, string>()\n    const rootFileNames = new Set(config.fileNames)\n    const cachedReadFile = cachedLookup(debugFn('readFile', readFile))\n\n    // Use language services by default (TODO: invert next major version).\n    if (!options.compilerHost) {\n      let projectVersion = 1\n      const fileVersions = new Map(Array.from(rootFileNames).map(fileName => [fileName, 0]))\n\n      const getCustomTransformers = () => {\n        if (typeof transformers === 'function') {\n          const program = service.getProgram()\n          return program ? transformers(program) : undefined\n        }\n\n        return transformers\n      }\n\n      // Create the compiler host for type checking.\n      const serviceHost: _ts.LanguageServiceHost & Required<Pick<_ts.LanguageServiceHost, 'fileExists' | 'readFile'>> = {\n        getProjectVersion: () => String(projectVersion),\n        getScriptFileNames: () => Array.from(rootFileNames),\n        getScriptVersion: (fileName: string) => {\n          const version = fileVersions.get(fileName)\n          return version ? version.toString() : ''\n        },\n        getScriptSnapshot (fileName: string) {\n          // TODO ordering of this with getScriptVersion?  Should they sync up?\n          let contents = fileContents.get(fileName)\n\n          // Read contents into TypeScript memory cache.\n          if (contents === undefined) {\n            contents = cachedReadFile(fileName)\n            if (contents === undefined) return\n\n            fileVersions.set(fileName, 1)\n            fileContents.set(fileName, contents)\n            projectVersion++\n          }\n\n          return ts.ScriptSnapshot.fromString(contents)\n        },\n        readFile: cachedReadFile,\n        readDirectory: ts.sys.readDirectory,\n        getDirectories: cachedLookup(debugFn('getDirectories', ts.sys.getDirectories)),\n        fileExists: cachedLookup(debugFn('fileExists', fileExists)),\n        directoryExists: cachedLookup(debugFn('directoryExists', ts.sys.directoryExists)),\n        realpath: ts.sys.realpath ? cachedLookup(debugFn('realpath', ts.sys.realpath)) : undefined,\n        getNewLine: () => ts.sys.newLine,\n        useCaseSensitiveFileNames: () => ts.sys.useCaseSensitiveFileNames,\n        getCurrentDirectory: () => cwd,\n        getCompilationSettings: () => config.options,\n        getDefaultLibFileName: () => ts.getDefaultLibFilePath(config.options),\n        getCustomTransformers: getCustomTransformers\n      }\n      const { resolveModuleNames, getResolvedModuleWithFailedLookupLocationsFromCache, resolveTypeReferenceDirectives, isFileKnownToBeInternal, markBucketOfFilenameInternal } = createResolverFunctions(serviceHost)\n      serviceHost.resolveModuleNames = resolveModuleNames\n      serviceHost.getResolvedModuleWithFailedLookupLocationsFromCache = getResolvedModuleWithFailedLookupLocationsFromCache\n      serviceHost.resolveTypeReferenceDirectives = resolveTypeReferenceDirectives\n\n      const registry = ts.createDocumentRegistry(ts.sys.useCaseSensitiveFileNames, cwd)\n      const service = ts.createLanguageService(serviceHost, registry)\n\n      const updateMemoryCache = (contents: string, fileName: string) => {\n        // Add to `rootFiles` as necessary, either to make TS include a file it has not seen,\n        // or to trigger a re-classification of files from external to internal.\n        if (!rootFileNames.has(fileName) && !isFileKnownToBeInternal(fileName)) {\n          markBucketOfFilenameInternal(fileName)\n          rootFileNames.add(fileName)\n          // Increment project version for every change to rootFileNames.\n          projectVersion++\n        }\n\n        const previousVersion = fileVersions.get(fileName) || 0\n        const previousContents = fileContents.get(fileName)\n        // Avoid incrementing cache when nothing has changed.\n        if (contents !== previousContents) {\n          fileVersions.set(fileName, previousVersion + 1)\n          fileContents.set(fileName, contents)\n          // Increment project version for every file change.\n          projectVersion++\n        }\n      }\n\n      let previousProgram: _ts.Program | undefined = undefined\n\n      getOutput = (code: string, fileName: string) => {\n        updateMemoryCache(code, fileName)\n\n        const programBefore = service.getProgram()\n        if (programBefore !== previousProgram) {\n          debug(`compiler rebuilt Program instance when getting output for ${fileName}`)\n        }\n\n        const output = service.getEmitOutput(fileName)\n\n        // Get the relevant diagnostics - this is 3x faster than `getPreEmitDiagnostics`.\n        const diagnostics = service.getSemanticDiagnostics(fileName)\n          .concat(service.getSyntacticDiagnostics(fileName))\n\n        const programAfter = service.getProgram()\n\n        debug(\n          'invariant: Is service.getProject() identical before and after getting emit output and diagnostics? (should always be true) ',\n          programBefore === programAfter\n        )\n\n        previousProgram = programAfter\n\n        const diagnosticList = filterDiagnostics(diagnostics, ignoreDiagnostics)\n        if (diagnosticList.length) reportTSError(diagnosticList)\n\n        if (output.emitSkipped) {\n          throw new TypeError(`${relative(cwd, fileName)}: Emit skipped`)\n        }\n\n        // Throw an error when requiring `.d.ts` files.\n        if (output.outputFiles.length === 0) {\n          throw new TypeError(\n            `Unable to require file: ${relative(cwd, fileName)}\\n` +\n            'This is usually the result of a faulty configuration or import. ' +\n            'Make sure there is a `.js`, `.json` or other executable extension with ' +\n            'loader attached before `ts-node` available.'\n          )\n        }\n\n        return [output.outputFiles[1].text, output.outputFiles[0].text]\n      }\n\n      getTypeInfo = (code: string, fileName: string, position: number) => {\n        updateMemoryCache(code, fileName)\n\n        const info = service.getQuickInfoAtPosition(fileName, position)\n        const name = ts.displayPartsToString(info ? info.displayParts : [])\n        const comment = ts.displayPartsToString(info ? info.documentation : [])\n\n        return { name, comment }\n      }\n    } else {\n      const sys: _ts.System & _ts.FormatDiagnosticsHost = {\n        ...ts.sys,\n        ...diagnosticHost,\n        readFile: (fileName: string) => {\n          const cacheContents = fileContents.get(fileName)\n          if (cacheContents !== undefined) return cacheContents\n          const contents = cachedReadFile(fileName)\n          if (contents) fileContents.set(fileName, contents)\n          return contents\n        },\n        readDirectory: ts.sys.readDirectory,\n        getDirectories: cachedLookup(debugFn('getDirectories', ts.sys.getDirectories)),\n        fileExists: cachedLookup(debugFn('fileExists', fileExists)),\n        directoryExists: cachedLookup(debugFn('directoryExists', ts.sys.directoryExists)),\n        resolvePath: cachedLookup(debugFn('resolvePath', ts.sys.resolvePath)),\n        realpath: ts.sys.realpath ? cachedLookup(debugFn('realpath', ts.sys.realpath)) : undefined\n      }\n\n      const host: _ts.CompilerHost = ts.createIncrementalCompilerHost\n        ? ts.createIncrementalCompilerHost(config.options, sys)\n        : {\n          ...sys,\n          getSourceFile: (fileName, languageVersion) => {\n            const contents = sys.readFile(fileName)\n            if (contents === undefined) return\n            return ts.createSourceFile(fileName, contents, languageVersion)\n          },\n          getDefaultLibLocation: () => normalizeSlashes(dirname(compiler)),\n          getDefaultLibFileName: () => normalizeSlashes(join(dirname(compiler), ts.getDefaultLibFileName(config.options))),\n          useCaseSensitiveFileNames: () => sys.useCaseSensitiveFileNames\n        }\n      const { resolveModuleNames, resolveTypeReferenceDirectives, isFileKnownToBeInternal, markBucketOfFilenameInternal } = createResolverFunctions(host)\n      host.resolveModuleNames = resolveModuleNames\n      host.resolveTypeReferenceDirectives = resolveTypeReferenceDirectives\n\n      // Fallback for older TypeScript releases without incremental API.\n      let builderProgram = ts.createIncrementalProgram\n        ? ts.createIncrementalProgram({\n          rootNames: Array.from(rootFileNames),\n          options: config.options,\n          host: host,\n          configFileParsingDiagnostics: config.errors,\n          projectReferences: config.projectReferences\n        })\n        : ts.createEmitAndSemanticDiagnosticsBuilderProgram(\n          Array.from(rootFileNames),\n          config.options,\n          host,\n          undefined,\n          config.errors,\n          config.projectReferences\n        )\n\n      // Read and cache custom transformers.\n      const customTransformers = typeof transformers === 'function'\n        ? transformers(builderProgram.getProgram())\n        : transformers\n\n      // Set the file contents into cache manually.\n      const updateMemoryCache = (contents: string, fileName: string) => {\n        const previousContents = fileContents.get(fileName)\n        const contentsChanged = previousContents !== contents\n        if (contentsChanged) {\n          fileContents.set(fileName, contents)\n        }\n\n        // Add to `rootFiles` when discovered by compiler for the first time.\n        let addedToRootFileNames = false\n        if (!rootFileNames.has(fileName) && !isFileKnownToBeInternal(fileName)) {\n          markBucketOfFilenameInternal(fileName)\n          rootFileNames.add(fileName)\n          addedToRootFileNames = true\n        }\n\n        // Update program when file changes.\n        if (addedToRootFileNames || contentsChanged) {\n          builderProgram = ts.createEmitAndSemanticDiagnosticsBuilderProgram(\n            Array.from(rootFileNames),\n            config.options,\n            host,\n            builderProgram,\n            config.errors,\n            config.projectReferences\n          )\n        }\n      }\n\n      getOutput = (code: string, fileName: string) => {\n        const output: [string, string] = ['', '']\n\n        updateMemoryCache(code, fileName)\n\n        const sourceFile = builderProgram.getSourceFile(fileName)\n        if (!sourceFile) throw new TypeError(`Unable to read file: ${fileName}`)\n\n        const program = builderProgram.getProgram()\n        const diagnostics = ts.getPreEmitDiagnostics(program, sourceFile)\n        const diagnosticList = filterDiagnostics(diagnostics, ignoreDiagnostics)\n        if (diagnosticList.length) reportTSError(diagnosticList)\n\n        const result = builderProgram.emit(sourceFile, (path, file, writeByteOrderMark) => {\n          if (path.endsWith('.map')) {\n            output[1] = file\n          } else {\n            output[0] = file\n          }\n\n          if (options.emit) sys.writeFile(path, file, writeByteOrderMark)\n        }, undefined, undefined, customTransformers)\n\n        if (result.emitSkipped) {\n          throw new TypeError(`${relative(cwd, fileName)}: Emit skipped`)\n        }\n\n        // Throw an error when requiring files that cannot be compiled.\n        if (output[0] === '') {\n          if (program.isSourceFileFromExternalLibrary(sourceFile)) {\n            throw new TypeError(`Unable to compile file from external library: ${relative(cwd, fileName)}`)\n          }\n\n          throw new TypeError(\n            `Unable to require file: ${relative(cwd, fileName)}\\n` +\n            'This is usually the result of a faulty configuration or import. ' +\n            'Make sure there is a `.js`, `.json` or other executable extension with ' +\n            'loader attached before `ts-node` available.'\n          )\n        }\n\n        return output\n      }\n\n      getTypeInfo = (code: string, fileName: string, position: number) => {\n        updateMemoryCache(code, fileName)\n\n        const sourceFile = builderProgram.getSourceFile(fileName)\n        if (!sourceFile) throw new TypeError(`Unable to read file: ${fileName}`)\n\n        const node = getTokenAtPosition(ts, sourceFile, position)\n        const checker = builderProgram.getProgram().getTypeChecker()\n        const symbol = checker.getSymbolAtLocation(node)\n\n        if (!symbol) return { name: '', comment: '' }\n\n        const type = checker.getTypeOfSymbolAtLocation(symbol, node)\n        const signatures = [...type.getConstructSignatures(), ...type.getCallSignatures()]\n\n        return {\n          name: signatures.length ? signatures.map(x => checker.signatureToString(x)).join('\\n') : checker.typeToString(type),\n          comment: ts.displayPartsToString(symbol ? symbol.getDocumentationComment(checker) : [])\n        }\n      }\n\n      // Write `.tsbuildinfo` when `--build` is enabled.\n      if (options.emit && config.options.incremental) {\n        process.on('exit', () => {\n          // Emits `.tsbuildinfo` to filesystem.\n          (builderProgram.getProgram() as any).emitBuildInfo()\n        })\n      }\n    }\n  } else {\n    if (typeof transformers === 'function') {\n      throw new TypeError('Transformers function is unavailable in \"--transpile-only\"')\n    }\n\n    getOutput = (code: string, fileName: string): SourceOutput => {\n      const result = ts.transpileModule(code, {\n        fileName,\n        compilerOptions: config.options,\n        reportDiagnostics: true,\n        transformers: transformers\n      })\n\n      const diagnosticList = filterDiagnostics(result.diagnostics || [], ignoreDiagnostics)\n      if (diagnosticList.length) reportTSError(diagnosticList)\n\n      return [result.outputText, result.sourceMapText as string]\n    }\n\n    getTypeInfo = () => {\n      throw new TypeError('Type information is unavailable in \"--transpile-only\"')\n    }\n  }\n\n  // Create a simple TypeScript compiler proxy.\n  function compile (code: string, fileName: string, lineOffset = 0) {\n    const normalizedFileName = normalizeSlashes(fileName)\n    const [value, sourceMap] = getOutput(code, normalizedFileName)\n    const output = updateOutput(value, normalizedFileName, sourceMap, getExtension)\n    outputCache.set(normalizedFileName, { content: output })\n    return output\n  }\n\n  let active = true\n  const enabled = (enabled?: boolean) => enabled === undefined ? active : (active = !!enabled)\n  const extensions = getExtensions(config)\n  const ignored = (fileName: string) => {\n    if (!active) return true\n    const ext = extname(fileName)\n    if (extensions.tsExtensions.includes(ext) || extensions.jsExtensions.includes(ext)) {\n      const relname = relative(cwd, fileName)\n      return !isScoped(relname) || shouldIgnore(relname)\n    }\n    return true\n  }\n\n  return { ts, config, compile, getTypeInfo, ignored, enabled, options }\n}\n\n/**\n * Check if the filename should be ignored.\n */\nfunction createIgnore (ignore: RegExp[]) {\n  return (relname: string) => {\n    const path = normalizeSlashes(relname)\n\n    return ignore.some(x => x.test(path))\n  }\n}\n\n/**\n * \"Refreshes\" an extension on `require.extensions`.\n *\n * @param {string} ext\n */\nfunction reorderRequireExtension (ext: string) {\n  const old = require.extensions[ext] // tslint:disable-line\n  delete require.extensions[ext] // tslint:disable-line\n  require.extensions[ext] = old // tslint:disable-line\n}\n\n/**\n * Register the extensions to support when importing files.\n */\nfunction registerExtensions (\n  preferTsExts: boolean | null | undefined,\n  extensions: string[],\n  service: Service,\n  originalJsHandler: (m: NodeModule, filename: string) => any\n) {\n  // Register new extensions.\n  for (const ext of extensions) {\n    registerExtension(ext, service, originalJsHandler)\n  }\n\n  if (preferTsExts) {\n    // tslint:disable-next-line\n    const preferredExtensions = new Set([...extensions, ...Object.keys(require.extensions)])\n\n    for (const ext of preferredExtensions) reorderRequireExtension(ext)\n  }\n}\n\n/**\n * Register the extension for node.\n */\nfunction registerExtension (\n  ext: string,\n  service: Service,\n  originalHandler: (m: NodeModule, filename: string) => any\n) {\n  const old = require.extensions[ext] || originalHandler // tslint:disable-line\n\n  require.extensions[ext] = function (m: any, filename) { // tslint:disable-line\n    if (service.ignored(filename)) return old(m, filename)\n\n    if (service.options.experimentalEsmLoader) {\n      assertScriptCanLoadAsCJS(filename)\n    }\n\n    const _compile = m._compile\n\n    m._compile = function (code: string, fileName: string) {\n      debug('module._compile', fileName)\n\n      return _compile.call(this, service.compile(code, fileName), fileName)\n    }\n\n    return old(m, filename)\n  }\n}\n\n/**\n * Do post-processing on config options to support `ts-node`.\n */\nfunction fixConfig (ts: TSCommon, config: _ts.ParsedCommandLine) {\n  // Delete options that *should not* be passed through.\n  delete config.options.out\n  delete config.options.outFile\n  delete config.options.composite\n  delete config.options.declarationDir\n  delete config.options.declarationMap\n  delete config.options.emitDeclarationOnly\n\n  // Target ES5 output by default (instead of ES3).\n  if (config.options.target === undefined) {\n    config.options.target = ts.ScriptTarget.ES5\n  }\n\n  // Target CommonJS modules by default (instead of magically switching to ES6 when the target is ES6).\n  if (config.options.module === undefined) {\n    config.options.module = ts.ModuleKind.CommonJS\n  }\n\n  return config\n}\n\n/**\n * Load TypeScript configuration. Returns the parsed TypeScript config and\n * any `ts-node` options specified in the config file.\n */\nfunction readConfig (\n  cwd: string,\n  ts: TSCommon,\n  rawOptions: CreateOptions\n): {\n  // Parsed TypeScript configuration.\n  config: _ts.ParsedCommandLine\n  // Options pulled from `tsconfig.json`.\n  options: TsConfigOptions\n} {\n  let config: any = { compilerOptions: {} }\n  let basePath = cwd\n  let configFileName: string | undefined = undefined\n\n  const {\n    fileExists = ts.sys.fileExists,\n    readFile = ts.sys.readFile,\n    skipProject = DEFAULTS.skipProject,\n    project = DEFAULTS.project\n  } = rawOptions\n\n  // Read project configuration when available.\n  if (!skipProject) {\n    configFileName = project\n      ? resolve(cwd, project)\n      : ts.findConfigFile(cwd, fileExists)\n\n    if (configFileName) {\n      const result = ts.readConfigFile(configFileName, readFile)\n\n      // Return diagnostics.\n      if (result.error) {\n        return {\n          config: { errors: [result.error], fileNames: [], options: {} },\n          options: {}\n        }\n      }\n\n      config = result.config\n      basePath = dirname(configFileName)\n    }\n  }\n\n  // Fix ts-node options that come from tsconfig.json\n  const tsconfigOptions: TsConfigOptions = Object.assign({}, config['ts-node'])\n\n  // Remove resolution of \"files\".\n  const files = rawOptions.files ?? tsconfigOptions.files ?? DEFAULTS.files\n  if (!files) {\n    config.files = []\n    config.include = []\n  }\n\n  // Override default configuration options `ts-node` requires.\n  config.compilerOptions = Object.assign(\n    {},\n    config.compilerOptions,\n    DEFAULTS.compilerOptions,\n    tsconfigOptions.compilerOptions,\n    rawOptions.compilerOptions,\n    TS_NODE_COMPILER_OPTIONS\n  )\n\n  const fixedConfig = fixConfig(ts, ts.parseJsonConfigFileContent(config, {\n    fileExists,\n    readFile,\n    readDirectory: ts.sys.readDirectory,\n    useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames\n  }, basePath, undefined, configFileName))\n\n  if (tsconfigOptions.require) {\n    // Modules are found relative to the tsconfig file, not the `dir` option\n    const tsconfigRelativeRequire = createRequire(configFileName!)\n    tsconfigOptions.require = tsconfigOptions.require.map((path: string) => {\n      return tsconfigRelativeRequire.resolve(path)\n    })\n  }\n\n  return { config: fixedConfig, options: tsconfigOptions }\n}\n\n/**\n * Internal source output.\n */\ntype SourceOutput = [string, string]\n\n/**\n * Update the output remapping the source map.\n */\nfunction updateOutput (outputText: string, fileName: string, sourceMap: string, getExtension: (fileName: string) => string) {\n  const base64Map = Buffer.from(updateSourceMap(sourceMap, fileName), 'utf8').toString('base64')\n  const sourceMapContent = `data:application/json;charset=utf-8;base64,${base64Map}`\n  const sourceMapLength = `${basename(fileName)}.map`.length + (getExtension(fileName).length - extname(fileName).length)\n\n  return outputText.slice(0, -sourceMapLength) + sourceMapContent\n}\n\n/**\n * Update the source map contents for improved output.\n */\nfunction updateSourceMap (sourceMapText: string, fileName: string) {\n  const sourceMap = JSON.parse(sourceMapText)\n  sourceMap.file = fileName\n  sourceMap.sources = [fileName]\n  delete sourceMap.sourceRoot\n  return JSON.stringify(sourceMap)\n}\n\n/**\n * Filter diagnostics.\n */\nfunction filterDiagnostics (diagnostics: readonly _ts.Diagnostic[], ignore: number[]) {\n  return diagnostics.filter(x => ignore.indexOf(x.code) === -1)\n}\n\n/**\n * Get token at file position.\n *\n * Reference: https://github.com/microsoft/TypeScript/blob/fcd9334f57d85b73dd66ad2d21c02e84822f4841/src/services/utilities.ts#L705-L731\n */\nfunction getTokenAtPosition (ts: typeof _ts, sourceFile: _ts.SourceFile, position: number): _ts.Node {\n  let current: _ts.Node = sourceFile\n\n  outer: while (true) {\n    for (const child of current.getChildren(sourceFile)) {\n      const start = child.getFullStart()\n      if (start > position) break\n\n      const end = child.getEnd()\n      if (position <= end) {\n        current = child\n        continue outer\n      }\n    }\n\n    return current\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}