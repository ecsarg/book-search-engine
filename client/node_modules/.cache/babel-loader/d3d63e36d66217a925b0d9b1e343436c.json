{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n/**\n *  Copyright (c) Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the license found in the\n *  LICENSE file in the root directory of this source tree.\n *\n *  \n */\n\n/**\n * Builds an online immutable parser, designed to be used as part of a syntax\n * highlighting and code intelligence tools.\n *\n * Options:\n *\n *     eatWhitespace: (\n *       stream: Stream | CodeMirror.StringStream | CharacterStream\n *     ) => boolean\n *       Use CodeMirror API.\n *\n *     LexRules: { [name: string]: RegExp }, Includes `Punctuation`, `Comment`.\n *\n *     ParseRules: { [name: string]: Array<Rule> }, Includes `Document`.\n *\n *     editorConfig: { [name: string]: any }, Provides an editor-specific\n *       configurations set.\n *\n */\n\n\nexports.default = onlineParser;\n\nvar _Rules = require('./Rules');\n\nfunction onlineParser() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    eatWhitespace: function eatWhitespace(stream) {\n      return stream.eatWhile(_Rules.isIgnored);\n    },\n    lexRules: _Rules.LexRules,\n    parseRules: _Rules.ParseRules,\n    editorConfig: {}\n  };\n  return {\n    startState: function startState() {\n      var initialState = {\n        level: 0,\n        step: 0,\n        name: null,\n        kind: null,\n        type: null,\n        rule: null,\n        needsSeperator: false,\n        prevState: null\n      };\n      pushRule(options.parseRules, initialState, 'Document');\n      return initialState;\n    },\n    token: function token(stream, state) {\n      return getToken(stream, state, options);\n    }\n  };\n}\n\nfunction getToken(stream, state, options) {\n  var lexRules = options.lexRules,\n      parseRules = options.parseRules,\n      eatWhitespace = options.eatWhitespace,\n      editorConfig = options.editorConfig; // Restore state after an empty-rule.\n\n  if (state.rule && state.rule.length === 0) {\n    popRule(state);\n  } else if (state.needsAdvance) {\n    state.needsAdvance = false;\n    advanceRule(state, true);\n  } // Remember initial indentation\n\n\n  if (stream.sol()) {\n    var tabSize = editorConfig && editorConfig.tabSize || 2;\n    state.indentLevel = Math.floor(stream.indentation() / tabSize);\n  } // Consume spaces and ignored characters\n\n\n  if (eatWhitespace(stream)) {\n    return 'ws';\n  } // Get a matched token from the stream, using lex\n\n\n  var token = lex(lexRules, stream); // If there's no matching token, skip ahead.\n\n  if (!token) {\n    stream.match(/\\S+/);\n    pushRule(SpecialParseRules, state, 'Invalid');\n    return 'invalidchar';\n  } // If the next token is a Comment, insert a Comment parsing rule.\n\n\n  if (token.kind === 'Comment') {\n    pushRule(SpecialParseRules, state, 'Comment');\n    return 'comment';\n  } // Save state before continuing.\n\n\n  var backupState = assign({}, state); // Handle changes in expected indentation level\n\n  if (token.kind === 'Punctuation') {\n    if (/^[{([]/.test(token.value)) {\n      // Push on the stack of levels one level deeper than the current level.\n      state.levels = (state.levels || []).concat(state.indentLevel + 1);\n    } else if (/^[})\\]]/.test(token.value)) {\n      // Pop from the stack of levels.\n      // If the top of the stack is lower than the current level, lower the\n      // current level to match.\n      var levels = state.levels = (state.levels || []).slice(0, -1);\n\n      if (state.indentLevel) {\n        if (levels.length > 0 && levels[levels.length - 1] < state.indentLevel) {\n          state.indentLevel = levels[levels.length - 1];\n        }\n      }\n    }\n  }\n\n  while (state.rule) {\n    // If this is a forking rule, determine what rule to use based on\n    var expected = typeof state.rule === 'function' ? state.step === 0 ? state.rule(token, stream) : null : state.rule[state.step]; // Seperator between list elements if necessary.\n\n    if (state.needsSeperator) {\n      expected = expected && expected.separator;\n    }\n\n    if (expected) {\n      // Un-wrap optional/list parseRules.\n      if (expected.ofRule) {\n        expected = expected.ofRule;\n      } // A string represents a Rule\n\n\n      if (typeof expected === 'string') {\n        pushRule(parseRules, state, expected);\n        continue;\n      } // Otherwise, match a Terminal.\n\n\n      if (expected.match && expected.match(token)) {\n        if (expected.update) {\n          expected.update(state, token);\n        } // If this token was a punctuator, advance the parse rule, otherwise\n        // mark the state to be advanced before the next token. This ensures\n        // that tokens which can be appended to keep the appropriate state.\n\n\n        if (token.kind === 'Punctuation') {\n          advanceRule(state, true);\n        } else {\n          state.needsAdvance = true;\n        }\n\n        return expected.style;\n      }\n    }\n\n    unsuccessful(state);\n  } // The parser does not know how to interpret this token, do not affect state.\n\n\n  assign(state, backupState);\n  pushRule(SpecialParseRules, state, 'Invalid');\n  return 'invalidchar';\n} // Utility function to assign from object to another object.\n\n\nfunction assign(to, from) {\n  var keys = Object.keys(from);\n\n  for (var i = 0; i < keys.length; i++) {\n    to[keys[i]] = from[keys[i]];\n  }\n\n  return to;\n} // A special rule set for parsing comment tokens.\n\n\nvar SpecialParseRules = {\n  Invalid: [],\n  Comment: []\n}; // Push a new rule onto the state.\n\nfunction pushRule(rules, state, ruleKind) {\n  if (!rules[ruleKind]) {\n    throw new TypeError('Unknown rule: ' + ruleKind);\n  }\n\n  state.prevState = _extends({}, state);\n  state.kind = ruleKind;\n  state.name = null;\n  state.type = null;\n  state.rule = rules[ruleKind];\n  state.step = 0;\n  state.needsSeperator = false;\n} // Pop the current rule from the state.\n\n\nfunction popRule(state) {\n  // Check if there's anything to pop\n  if (!state.prevState) {\n    return;\n  }\n\n  state.kind = state.prevState.kind;\n  state.name = state.prevState.name;\n  state.type = state.prevState.type;\n  state.rule = state.prevState.rule;\n  state.step = state.prevState.step;\n  state.needsSeperator = state.prevState.needsSeperator;\n  state.prevState = state.prevState.prevState;\n} // Advance the step of the current rule.\n\n\nfunction advanceRule(state, successful) {\n  // If this is advancing successfully and the current state is a list, give\n  // it an opportunity to repeat itself.\n  if (isList(state)) {\n    if (state.rule && state.rule[state.step].separator) {\n      var separator = state.rule[state.step].separator;\n      state.needsSeperator = !state.needsSeperator; // If the separator was optional, then give it an opportunity to repeat.\n\n      if (!state.needsSeperator && separator.ofRule) {\n        return;\n      }\n    } // If this was a successful list parse, then allow it to repeat itself.\n\n\n    if (successful) {\n      return;\n    }\n  } // Advance the step in the rule. If the rule is completed, pop\n  // the rule and advance the parent rule as well (recursively).\n\n\n  state.needsSeperator = false;\n  state.step++; // While the current rule is completed.\n\n  while (state.rule && !(Array.isArray(state.rule) && state.step < state.rule.length)) {\n    popRule(state);\n\n    if (state.rule) {\n      // Do not advance a List step so it has the opportunity to repeat itself.\n      if (isList(state)) {\n        if (state.rule && state.rule[state.step].separator) {\n          state.needsSeperator = !state.needsSeperator;\n        }\n      } else {\n        state.needsSeperator = false;\n        state.step++;\n      }\n    }\n  }\n}\n\nfunction isList(state) {\n  return Array.isArray(state.rule) && typeof state.rule[state.step] !== 'string' && state.rule[state.step].isList;\n} // Unwind the state after an unsuccessful match.\n\n\nfunction unsuccessful(state) {\n  // Fall back to the parent rule until you get to an optional or list rule or\n  // until the entire stack of rules is empty.\n  while (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {\n    popRule(state);\n  } // If there is still a rule, it must be an optional or list rule.\n  // Consider this rule a success so that we may move past it.\n\n\n  if (state.rule) {\n    advanceRule(state, false);\n  }\n} // Given a stream, returns a { kind, value } pair, or null.\n\n\nfunction lex(lexRules, stream) {\n  var kinds = Object.keys(lexRules);\n\n  for (var i = 0; i < kinds.length; i++) {\n    var match = stream.match(lexRules[kinds[i]]);\n\n    if (match && match instanceof Array) {\n      return {\n        kind: kinds[i],\n        value: match[0]\n      };\n    }\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","default","onlineParser","_Rules","require","options","undefined","eatWhitespace","stream","eatWhile","isIgnored","lexRules","LexRules","parseRules","ParseRules","editorConfig","startState","initialState","level","step","name","kind","type","rule","needsSeperator","prevState","pushRule","token","state","getToken","popRule","needsAdvance","advanceRule","sol","tabSize","indentLevel","Math","floor","indentation","lex","match","SpecialParseRules","backupState","test","levels","concat","slice","expected","separator","ofRule","update","style","unsuccessful","to","from","keys","Invalid","Comment","rules","ruleKind","TypeError","successful","isList","Array","isArray","kinds"],"sources":["/Users/Ellie/Desktop/projects/book-search-engine/client/node_modules/@apollographql/graphql-language-service-parser/dist/onlineParser.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /**\n                                                                                                                                                                                                                                                                   *  Copyright (c) Facebook, Inc.\n                                                                                                                                                                                                                                                                   *  All rights reserved.\n                                                                                                                                                                                                                                                                   *\n                                                                                                                                                                                                                                                                   *  This source code is licensed under the license found in the\n                                                                                                                                                                                                                                                                   *  LICENSE file in the root directory of this source tree.\n                                                                                                                                                                                                                                                                   *\n                                                                                                                                                                                                                                                                   *  \n                                                                                                                                                                                                                                                                   */\n\n/**\n * Builds an online immutable parser, designed to be used as part of a syntax\n * highlighting and code intelligence tools.\n *\n * Options:\n *\n *     eatWhitespace: (\n *       stream: Stream | CodeMirror.StringStream | CharacterStream\n *     ) => boolean\n *       Use CodeMirror API.\n *\n *     LexRules: { [name: string]: RegExp }, Includes `Punctuation`, `Comment`.\n *\n *     ParseRules: { [name: string]: Array<Rule> }, Includes `Document`.\n *\n *     editorConfig: { [name: string]: any }, Provides an editor-specific\n *       configurations set.\n *\n */\n\nexports.default = onlineParser;\n\nvar _Rules = require('./Rules');\n\nfunction onlineParser() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    eatWhitespace: function eatWhitespace(stream) {\n      return stream.eatWhile(_Rules.isIgnored);\n    },\n    lexRules: _Rules.LexRules,\n    parseRules: _Rules.ParseRules,\n    editorConfig: {}\n  };\n\n  return {\n    startState: function startState() {\n      var initialState = {\n        level: 0,\n        step: 0,\n        name: null,\n        kind: null,\n        type: null,\n        rule: null,\n        needsSeperator: false,\n        prevState: null\n      };\n      pushRule(options.parseRules, initialState, 'Document');\n      return initialState;\n    },\n    token: function token(stream, state) {\n      return getToken(stream, state, options);\n    }\n  };\n}\n\nfunction getToken(stream, state, options) {\n  var lexRules = options.lexRules,\n      parseRules = options.parseRules,\n      eatWhitespace = options.eatWhitespace,\n      editorConfig = options.editorConfig;\n  // Restore state after an empty-rule.\n\n  if (state.rule && state.rule.length === 0) {\n    popRule(state);\n  } else if (state.needsAdvance) {\n    state.needsAdvance = false;\n    advanceRule(state, true);\n  }\n\n  // Remember initial indentation\n  if (stream.sol()) {\n    var tabSize = editorConfig && editorConfig.tabSize || 2;\n    state.indentLevel = Math.floor(stream.indentation() / tabSize);\n  }\n\n  // Consume spaces and ignored characters\n  if (eatWhitespace(stream)) {\n    return 'ws';\n  }\n\n  // Get a matched token from the stream, using lex\n  var token = lex(lexRules, stream);\n\n  // If there's no matching token, skip ahead.\n  if (!token) {\n    stream.match(/\\S+/);\n    pushRule(SpecialParseRules, state, 'Invalid');\n    return 'invalidchar';\n  }\n\n  // If the next token is a Comment, insert a Comment parsing rule.\n  if (token.kind === 'Comment') {\n    pushRule(SpecialParseRules, state, 'Comment');\n    return 'comment';\n  }\n\n  // Save state before continuing.\n  var backupState = assign({}, state);\n\n  // Handle changes in expected indentation level\n  if (token.kind === 'Punctuation') {\n    if (/^[{([]/.test(token.value)) {\n      // Push on the stack of levels one level deeper than the current level.\n      state.levels = (state.levels || []).concat(state.indentLevel + 1);\n    } else if (/^[})\\]]/.test(token.value)) {\n      // Pop from the stack of levels.\n      // If the top of the stack is lower than the current level, lower the\n      // current level to match.\n      var levels = state.levels = (state.levels || []).slice(0, -1);\n      if (state.indentLevel) {\n        if (levels.length > 0 && levels[levels.length - 1] < state.indentLevel) {\n          state.indentLevel = levels[levels.length - 1];\n        }\n      }\n    }\n  }\n\n  while (state.rule) {\n    // If this is a forking rule, determine what rule to use based on\n    var expected = typeof state.rule === 'function' ? state.step === 0 ? state.rule(token, stream) : null : state.rule[state.step];\n\n    // Seperator between list elements if necessary.\n    if (state.needsSeperator) {\n      expected = expected && expected.separator;\n    }\n\n    if (expected) {\n      // Un-wrap optional/list parseRules.\n      if (expected.ofRule) {\n        expected = expected.ofRule;\n      }\n\n      // A string represents a Rule\n      if (typeof expected === 'string') {\n        pushRule(parseRules, state, expected);\n        continue;\n      }\n\n      // Otherwise, match a Terminal.\n      if (expected.match && expected.match(token)) {\n        if (expected.update) {\n          expected.update(state, token);\n        }\n\n        // If this token was a punctuator, advance the parse rule, otherwise\n        // mark the state to be advanced before the next token. This ensures\n        // that tokens which can be appended to keep the appropriate state.\n        if (token.kind === 'Punctuation') {\n          advanceRule(state, true);\n        } else {\n          state.needsAdvance = true;\n        }\n\n        return expected.style;\n      }\n    }\n    unsuccessful(state);\n  }\n\n  // The parser does not know how to interpret this token, do not affect state.\n  assign(state, backupState);\n  pushRule(SpecialParseRules, state, 'Invalid');\n  return 'invalidchar';\n}\n\n// Utility function to assign from object to another object.\nfunction assign(to, from) {\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    to[keys[i]] = from[keys[i]];\n  }\n  return to;\n}\n\n// A special rule set for parsing comment tokens.\nvar SpecialParseRules = {\n  Invalid: [],\n  Comment: []\n};\n\n// Push a new rule onto the state.\nfunction pushRule(rules, state, ruleKind) {\n  if (!rules[ruleKind]) {\n    throw new TypeError('Unknown rule: ' + ruleKind);\n  }\n  state.prevState = _extends({}, state);\n  state.kind = ruleKind;\n  state.name = null;\n  state.type = null;\n  state.rule = rules[ruleKind];\n  state.step = 0;\n  state.needsSeperator = false;\n}\n\n// Pop the current rule from the state.\nfunction popRule(state) {\n  // Check if there's anything to pop\n  if (!state.prevState) {\n    return;\n  }\n  state.kind = state.prevState.kind;\n  state.name = state.prevState.name;\n  state.type = state.prevState.type;\n  state.rule = state.prevState.rule;\n  state.step = state.prevState.step;\n  state.needsSeperator = state.prevState.needsSeperator;\n  state.prevState = state.prevState.prevState;\n}\n\n// Advance the step of the current rule.\nfunction advanceRule(state, successful) {\n  // If this is advancing successfully and the current state is a list, give\n  // it an opportunity to repeat itself.\n  if (isList(state)) {\n    if (state.rule && state.rule[state.step].separator) {\n      var separator = state.rule[state.step].separator;\n      state.needsSeperator = !state.needsSeperator;\n      // If the separator was optional, then give it an opportunity to repeat.\n      if (!state.needsSeperator && separator.ofRule) {\n        return;\n      }\n    }\n    // If this was a successful list parse, then allow it to repeat itself.\n    if (successful) {\n      return;\n    }\n  }\n\n  // Advance the step in the rule. If the rule is completed, pop\n  // the rule and advance the parent rule as well (recursively).\n  state.needsSeperator = false;\n  state.step++;\n\n  // While the current rule is completed.\n  while (state.rule && !(Array.isArray(state.rule) && state.step < state.rule.length)) {\n    popRule(state);\n\n    if (state.rule) {\n      // Do not advance a List step so it has the opportunity to repeat itself.\n      if (isList(state)) {\n        if (state.rule && state.rule[state.step].separator) {\n          state.needsSeperator = !state.needsSeperator;\n        }\n      } else {\n        state.needsSeperator = false;\n        state.step++;\n      }\n    }\n  }\n}\n\nfunction isList(state) {\n  return Array.isArray(state.rule) && typeof state.rule[state.step] !== 'string' && state.rule[state.step].isList;\n}\n\n// Unwind the state after an unsuccessful match.\nfunction unsuccessful(state) {\n  // Fall back to the parent rule until you get to an optional or list rule or\n  // until the entire stack of rules is empty.\n  while (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {\n    popRule(state);\n  }\n\n  // If there is still a rule, it must be an optional or list rule.\n  // Consider this rule a success so that we may move past it.\n  if (state.rule) {\n    advanceRule(state, false);\n  }\n}\n\n// Given a stream, returns a { kind, value } pair, or null.\nfunction lex(lexRules, stream) {\n  var kinds = Object.keys(lexRules);\n  for (var i = 0; i < kinds.length; i++) {\n    var match = stream.match(lexRules[kinds[i]]);\n    if (match && match instanceof Array) {\n      return { kind: kinds[i], value: match[0] };\n    }\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}